/*! vitepress-theme-teek v1.5.1 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vitepress/theme'), require('vue'), require('vitepress'), require('vitepress-theme-teek/theme-chalk/tk-copy-banner.css'), require('@iconify/vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vitepress/theme', 'vue', 'vitepress', 'vitepress-theme-teek/theme-chalk/tk-copy-banner.css', '@iconify/vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Teek = {}, global.VitePressTheme, global.Vue, global.VitePress, null, global.IconifyVue));
})(this, (function (exports, DefaultTheme, Vue, vitepress, tkCopyBanner_css, vue) { 'use strict';

  function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n.default = e;
    return Object.freeze(n);
  }

  var Vue__namespace = /*#__PURE__*/_interopNamespaceDefault(Vue);

  const isExternal = (path) => /^(http?:|https?:|mailto:|tel:)/.test(path);
  const isValidURL = (url) => {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  };
  const isType = (val) => {
    if (val === null) return "null";
    if (typeof val !== "object") return typeof val;
    else return Object.prototype.toString.call(val).slice(8, -1).toLocaleLowerCase();
  };
  const is = (val, type) => {
    return Object.prototype.toString.call(val) === `[object ${type}]`;
  };
  const isPlainFunction = (val) => {
    return is(val, "Function");
  };
  const isFunction = (val) => {
    return is(val, "Function") || isAsyncFunction(val);
  };
  const isDef = (val) => {
    return val !== void 0;
  };
  const isUnDef = (val) => {
    return val === void 0;
  };
  const isObject$2 = (val) => {
    return val !== null && is(val, "Object");
  };
  const isDate = (val) => {
    return is(val, "Date");
  };
  const isNumber = (val) => {
    return is(val, "Number") && !Number.isNaN(val);
  };
  const isStringNumber = (val) => {
    if (!isString$1(val)) return false;
    return !Number.isNaN(Number(val));
  };
  const isAsyncFunction = (val) => {
    return is(val, "AsyncFunction");
  };
  const isPromise = (val) => {
    return is(val, "Promise") && isObject$2(val) && isFunction(val.then) && isFunction(val.catch);
  };
  const isString$1 = (val) => {
    return is(val, "String");
  };
  const isBoolean$1 = (val) => {
    return is(val, "Boolean");
  };
  const isArray$1 = (val) => {
    if (typeof Array.isArray === "undefined") {
      return Object.prototype.toString.call(val) === "[object Array]";
    }
    return Array.isArray(val);
  };
  const isElement = (val) => {
    if (typeof Element === "undefined") return false;
    return val instanceof Element;
  };
  const isNull$1 = (val) => {
    return val === null;
  };
  const isNullAndUnDef = (val) => {
    return val === null && val === void 0;
  };
  const isNullOrUnDef = (val) => {
    return val === null || val === void 0;
  };
  const isPhone = (val) => {
    return /^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$/.test(val);
  };
  const isImagePath = (path) => {
    return /(https?:\/\/|data:image\/).*?\.(png|jpg|jpeg|gif|svg|webp|ico)/gi.test(path);
  };
  const isImageDom = (o) => {
    return o && ["IMAGE", "IMG"].includes(o.tagName);
  };
  const isIos = () => {
    return isClient && window?.navigator?.userAgent && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || window?.navigator?.maxTouchPoints > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
  };
  const isEmpty = (val, checkComplexType = true) => {
    if (isNumber(val) && isNaN(val)) return true;
    if (val === "" || val === null || val === void 0) return true;
    if (!checkComplexType) return false;
    if (isArray$1(val) && !val.length) return true;
    if (isObject$2(val) && !Object.keys(val).length) return true;
    return false;
  };
  const isFocusable = (element) => {
    if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
      return true;
    }
    if (element.tabIndex < 0 || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true") {
      return false;
    }
    switch (element.nodeName) {
      case "A": {
        return !!element.href && element.rel !== "ignore";
      }
      case "INPUT": {
        return !(element.type === "hidden" || element.type === "file");
      }
      case "BUTTON":
      case "SELECT":
      case "TEXTAREA": {
        return true;
      }
      default: {
        return false;
      }
    }
  };
  const isClient = typeof window !== "undefined" && typeof document !== "undefined";
  const isServer = !isClient;
  const inBrowser = isClient;

  const getNowDate = (format = "yyyy-MM-dd hh:mm:ss", utc = true) => {
    return formatDate(/* @__PURE__ */ new Date(), format, utc);
  };
  const formatDate = (date, format = "yyyy-MM-dd hh:mm:ss", utc = true) => {
    if (!date) return "";
    const dateObj = new Date(date);
    const year = utc ? dateObj.getUTCFullYear() : dateObj.getFullYear();
    const month = String((utc ? dateObj.getUTCMonth() : dateObj.getMonth()) + 1).padStart(2, "0");
    const day = String(utc ? dateObj.getUTCDate() : dateObj.getDate()).padStart(2, "0");
    const hours = String(utc ? dateObj.getUTCHours() : dateObj.getHours()).padStart(2, "0");
    const minutes = String(utc ? dateObj.getUTCMinutes() : dateObj.getMinutes()).padStart(2, "0");
    const seconds = String(utc ? dateObj.getUTCSeconds() : dateObj.getSeconds()).padStart(2, "0");
    return format.replace("yyyy", year.toString()).replace("MM", month).replace("dd", day).replace("hh", hours).replace("mm", minutes).replace("ss", seconds);
  };
  const formatDiffDate = (startDate, endDate) => {
    const start = +new Date(startDate);
    const end = endDate ? +new Date(endDate) : +/* @__PURE__ */ new Date();
    const diff = Math.abs(end - start);
    const oneSeconds = 1e3;
    const oneMinute = oneSeconds * 60;
    const oneHour = oneMinute * 60;
    const oneDay = oneHour * 24;
    const oneWeek = oneDay * 7;
    const oneMonth = oneDay * 30;
    const oneYear = oneMonth * 12;
    if (diff < 1) return "\u521A\u521A";
    if (diff < oneMinute) return `${Math.floor(diff / oneSeconds)} \u79D2\u524D`;
    if (diff < oneHour) return `${Math.floor(diff / oneMinute)} \u5206\u524D`;
    if (diff < oneDay) return `${Math.floor(diff / oneHour)} \u65F6\u524D`;
    if (diff < oneWeek) return `${Math.floor(diff / oneDay)} \u5929\u524D`;
    if (diff < oneMonth) return `${Math.floor(diff / oneWeek)} \u5468\u524D`;
    if (diff < oneYear) return `${Math.floor(diff / oneMonth)} \u6708\u524D`;
    return `${Math.floor(diff / oneYear)} \u5E74\u524D`;
  };
  const formatDiffDateToDay = (startDate, endDate) => {
    const start = +new Date(startDate);
    const end = endDate ? +new Date(endDate) : +/* @__PURE__ */ new Date();
    return Math.floor(Math.abs(start - end) / (1e3 * 60 * 60 * 24));
  };

  const withBase = (base, path) => {
    if (!path) return;
    return /^(?:[a-z]+:|\/\/)/i.test(path) || !path.startsWith("/") ? path : `${base}${path}`.replace(/\/+/g, "/");
  };
  const upperFirst = (str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };
  const addUnit = (value, defaultUnit = "px") => {
    if (!value) return "";
    if (isNumber(value) || isStringNumber(value)) return `${value}${defaultUnit}`;
    else if (isString$1(value)) return value;
    return "";
  };
  const removeUnit = (value, defaultUnit = "px") => {
    if (!value) return;
    if (isNumber(value)) return value;
    if (isString$1(value)) return Number(value.replace(defaultUnit, ""));
    else return;
  };
  const get = (object, path, defaultValue) => {
    let obj = { ...object };
    if (!path.includes(".")) return obj[path] || defaultValue;
    else {
      path.split(".").forEach((item) => obj = obj[item] ?? "");
      return obj || defaultValue;
    }
  };
  const removeStorageItem = (key, storage, vague = false) => {
    if (!vague) return storage.removeItem(key);
    const keysToRemove = [];
    for (let i = 0; i < storage.length; i++) {
      const key2 = storage.key(i);
      if (key2 && key2.startsWith(key2)) {
        keysToRemove.push(key2);
      }
    }
    keysToRemove.forEach((key2) => storage.removeItem(key2));
  };

  const hexToRgb = (str) => {
    let hex = "";
    const reg = /^\#?[0-9A-Fa-f]{6}$/;
    if (!reg.test(str)) return console.error("[Teek Error] \u8F93\u5165\u9519\u8BEF\u7684 hex");
    str = str.replace("#", "");
    hex = str.match(/../g);
    for (let i = 0; i < 3; i++) hex[i] = parseInt(hex[i], 16);
    return hex;
  };
  const rgbToHex = (r, g, b) => {
    const reg = /^\d{1,3}$/;
    if (!reg.test(r) || !reg.test(g) || !reg.test(b)) return console.error("[Teek Error] \u8F93\u5165\u9519\u8BEF\u7684 rgb \u989C\u8272\u503C");
    const hex = [r.toString(16), g.toString(16), b.toString(16)];
    for (let i = 0; i < 3; i++) if (hex[i].length === 1) hex[i] = `0${hex[i]}`;
    return `#${hex.join("")}`;
  };
  const getDarkColor = (color, level) => {
    const reg = /^\#?[0-9A-Fa-f]{6}$/;
    if (!reg.test(color)) return console.error("[Teek Error] \u8F93\u5165\u9519\u8BEF\u7684 hex \u989C\u8272\u503C");
    const rgb = hexToRgb(color);
    for (let i = 0; i < 3; i++) rgb[i] = Math.round(20.5 * level + rgb[i] * (1 - level));
    return rgbToHex(rgb[0], rgb[1], rgb[2]);
  };
  const getLightColor = (color, level) => {
    const reg = /^\#?[0-9A-Fa-f]{6}$/;
    if (!reg.test(color)) return console.error("[Teek Error] \u8F93\u5165\u9519\u8BEF\u7684 hex \u989C\u8272\u503C");
    const rgb = hexToRgb(color);
    for (let i = 0; i < 3; i++) rgb[i] = Math.round(255 * level + rgb[i] * (1 - level));
    return rgbToHex(rgb[0], rgb[1], rgb[2]);
  };

  const baiduAnalytics = (options) => {
    if (!isClient) return;
    const { id, production = true } = options || {};
    if (production && process.env.NODE_ENV !== "production") return;
    if (!id) return console.warn("[Teek Warning] Baidu analytics id is empty");
    if (!document.querySelector(`#baidu-analytics-${id}`)) {
      window._hmt = window._hmt || [];
      const script = document.createElement("script");
      script.id = `baidu-analytics-${id}`;
      script.async = true;
      script.src = `https://hm.baidu.com/hm.js?${id}`;
      document.querySelector("head")?.appendChild(script);
    }
  };
  const trackPageview = (options, pageUrl) => {
    if (!isClient) return;
    const { id, production = true } = options || {};
    if (production && process.env.NODE_ENV !== "production") return;
    if (!id) return;
    if (!pageUrl || !isString$1(pageUrl)) pageUrl = "/";
    if (pageUrl.startsWith("http")) {
      const urlFragment = pageUrl.split("/");
      const origin = `${urlFragment[0]}//${urlFragment[2]}`;
      pageUrl = pageUrl.replace(origin, "");
    }
    if (window._hmt) {
      window._hmt.push(["_setAccount", id]);
      window._hmt.push(["_trackPageview", pageUrl]);
    }
  };

  const googleAnalytics = (options) => {
    if (!isClient) return;
    if (window.dataLayer && window.gtag) return;
    const { id, production = true } = options || {};
    if (production && process.env.NODE_ENV !== "production") return;
    if (!id) return console.warn("[Teek Warning] Google analytics id is empty");
    if (!document.querySelector(`#google-analytics-${id}`)) {
      const gtagScript = document.createElement("script");
      gtagScript.id = `google-analytics-${id}`;
      gtagScript.src = `https://www.googletagmanager.com/gtag/js?id=${id}`;
      gtagScript.async = true;
      document.head.appendChild(gtagScript);
      window.dataLayer = window.dataLayer || [];
      window.gtag = function() {
        dataLayer.push(arguments);
      };
      gtag("js", /* @__PURE__ */ new Date());
      gtag("config", id);
    }
  };

  const umamiAnalytics = (options, production = true) => {
    if (!isClient) return;
    if (production && process.env.NODE_ENV !== "production") return;
    let properties = [];
    if (Array.isArray(options)) properties.push(...options);
    else properties.push(options);
    properties = properties.filter((property) => Boolean(property.id));
    if (!properties.length) return;
    for (const property of properties) {
      const { id, src } = property;
      if (!document.querySelector(`#umami-analytics-${id}`)) {
        const script = document.createElement("script");
        script.id = `umami-analytics-${id}`;
        script.async = true;
        script.defer = true;
        script.setAttribute("data-website-id", id);
        script.src = src;
        document.head.appendChild(script);
      }
    }
  };

  const useScopeDispose = (fn) => {
    if (!Vue.getCurrentScope()) return false;
    Vue.onScopeDispose(fn);
    return true;
  };

  const useEventListener = (target, event, handler, options) => {
    const cleanups = [];
    const cleanup = () => {
      cleanups.forEach((fn) => fn());
      cleanups.length = 0;
    };
    const register = (el2, event2, listener, options2) => {
      el2.addEventListener(event2, listener, options2);
      return () => el2.removeEventListener(event2, listener, options2);
    };
    const el = Vue.computed(() => {
      if (!isClient) return;
      const plain = Vue.toValue(target) || window;
      return plain?.$el ?? plain;
    });
    const stopWatch = Vue.watch(
      el,
      (val) => {
        cleanup();
        if (!val) return;
        cleanups.push(register(val, event, handler, options));
      },
      { flush: "post", immediate: true }
      // flush: "post" 确保在组件挂载后执行
    );
    const stop = () => {
      stopWatch();
      cleanup();
    };
    useScopeDispose(cleanup);
    return stop;
  };

  let _iOSWorkaround = false;
  const onClickOutside = (target, handler, options = {}) => {
    const { ignore = [], capture = true, detectIframe = false, controls = false } = options;
    if (!isClient) {
      return controls ? { stop: () => {
      }, cancel: () => {
      }, trigger: () => {
      } } : () => {
      };
    }
    if (isIos() && !_iOSWorkaround) {
      _iOSWorkaround = true;
      const listenerOptions = { passive: true };
      Array.from(window.document.body.children).forEach((el) => useEventListener(el, "click", () => {
      }, listenerOptions));
      useEventListener(window.document.documentElement, "click", () => {
      }, listenerOptions);
    }
    let shouldListen = true;
    const shouldIgnore = (event) => {
      return Vue.toValue(ignore).some((target2) => {
        if (typeof target2 === "string") {
          return Array.from(window.document.querySelectorAll(target2)).some(
            (el) => el === event.target || event.composedPath().includes(el)
          );
        } else {
          const el = Vue.toValue(target2);
          return el && (event.target === el || event.composedPath().includes(el));
        }
      });
    };
    function hasMultipleRoots(target2) {
      const vm = Vue.toValue(target2);
      return vm && vm.$.subTree.shapeFlag === 16;
    }
    function checkMultipleRoots(target2, event) {
      const vm = Vue.toValue(target2);
      const children = vm.$.subTree && vm.$.subTree.children;
      if (children == null || !Array.isArray(children)) return false;
      return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));
    }
    const listener = (event) => {
      const plain = Vue.toValue(target);
      const el = plain?.$el ?? plain;
      if (event.target == null) return;
      if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event)) return;
      if (!el || el === event.target || event.composedPath().includes(el)) return;
      if ("detail" in event && event.detail === 0) shouldListen = !shouldIgnore(event);
      if (!shouldListen) {
        shouldListen = true;
        return;
      }
      handler(event);
    };
    let isProcessingClick = false;
    const cleanup = [
      useEventListener(
        window,
        "click",
        (event) => {
          if (!isProcessingClick) {
            isProcessingClick = true;
            setTimeout(() => {
              isProcessingClick = false;
            }, 0);
            listener(event);
          }
        },
        { passive: true, capture }
      ),
      useEventListener(
        window,
        "pointerdown",
        (e) => {
          const plain = Vue.toValue(target);
          const el = plain?.$el ?? plain;
          shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));
        },
        { passive: true }
      ),
      detectIframe && useEventListener(
        window,
        "blur",
        (event) => {
          setTimeout(() => {
            const plain = Vue.toValue(target);
            const el = plain?.$el ?? plain;
            if (window.document.activeElement?.tagName === "IFRAME" && !el?.contains(window.document.activeElement)) {
              handler(event);
            }
          }, 0);
        },
        { passive: true }
      )
    ].filter(Boolean);
    const stop = () => cleanup.forEach((fn) => fn());
    if (controls) {
      return {
        stop,
        cancel: () => {
          shouldListen = false;
        },
        trigger: (event) => {
          shouldListen = true;
          listener(event);
          shouldListen = false;
        }
      };
    }
    return stop;
  };

  const useMounted = (fn, options = {}) => {
    const { sync = false, nexTick = true } = options;
    const isMounted = Vue.shallowRef(false);
    const instance = Vue.getCurrentInstance();
    if (instance) {
      Vue.onMounted(() => {
        isMounted.value = true;
        fn?.();
      }, instance);
    } else if (sync) fn?.();
    else if (nexTick) Vue.nextTick(fn);
    return isMounted;
  };

  const useAnchorScroll = () => {
    const { theme } = vitepress.useData();
    const currentAnchor = Vue.reactive({ id: "", top: -1 });
    const calculateCurrentAnchor = () => {
      const anchors = document.querySelectorAll(".content-container .main :is(h1, h2, h3, h4, h5, h6)");
      for (let i = 0; i < anchors.length; i++) {
        const anchor = anchors[i];
        const computedStyle = window.getComputedStyle(anchor);
        if (computedStyle.display === "none") break;
        const rect = anchor.getBoundingClientRect();
        if (rect.top <= 150 && anchor.id !== currentAnchor.id) {
          currentAnchor.id = anchor.id;
          currentAnchor.top = rect.top;
        }
      }
    };
    useMounted(() => {
      useEventListener(window, "scroll", calculateCurrentAnchor);
    });
    const startWatch = () => {
      if (theme.value.anchorScroll === false) return;
      Vue.watch(
        () => currentAnchor.id,
        (val) => {
          if (!isClient || !val) return;
          window.history.replaceState(history.state || null, "", `#${val}`);
        }
      );
    };
    return { startWatch };
  };

  const DEFAULT_SITE_PV = 9999;
  const DEFAULT_SITE_UV = 9999;
  const DEFAULT_PAGE_PV = 9999;
  const DEFAULT_PAGE_UV = 9999;
  const DEFAULT_TODAY_DATA = {
    site_pv: 9999,
    site_uv: 9999,
    page_pv: 9999,
    page_uv: 9999
  };
  const DEFAULT_YESTERDAY_DATA = {
    site_pv: 9999,
    site_uv: 9999,
    page_pv: 9999,
    page_uv: 9999
  };
  const useUvPv = (immediate = false, options = {}) => {
    const { url, provider = "busuanzi", tryRequest = false, tryCount = 5, tryIterationTime = 2e3, requestFn } = options;
    const sitePv = Vue.ref(0);
    const siteUv = Vue.ref(0);
    const pagePv = Vue.ref(0);
    const pageUv = Vue.ref(0);
    const today = Vue.ref({ site_pv: 0, site_uv: 0, page_pv: 0, page_uv: 0 });
    const yesterday = Vue.ref({ site_pv: 0, site_uv: 0, page_pv: 0, page_uv: 0 });
    const isGet = Vue.ref(true);
    const request = () => {
      if (!isClient) return;
      if (isGet.value === false) return;
      isGet.value = false;
      const call = async (url2) => {
        if (requestFn) {
          const response = await requestFn(url2, createScript);
          window.dispatchEvent(new CustomEvent("views", { detail: response }));
          return Promise.resolve(response);
        }
        switch (provider) {
          case "busuanzi":
            return callBusuanzi(url2);
          case "vercount":
            return callVercount(url2);
          default:
            return callBusuanzi(url2);
        }
      };
      call(url || void 0).then((data) => {
        sitePv.value = data.site_pv || DEFAULT_SITE_PV;
        siteUv.value = data.site_uv || DEFAULT_SITE_UV;
        pagePv.value = data.page_pv || DEFAULT_PAGE_PV;
        pageUv.value = data.page_uv || DEFAULT_PAGE_UV;
        today.value = data.today || DEFAULT_TODAY_DATA;
        yesterday.value = data.yesterday || DEFAULT_YESTERDAY_DATA;
        isGet.value = true;
        window.dispatchEvent(new CustomEvent("views", { detail: data }));
      });
    };
    immediate && Vue.nextTick(request);
    if (tryRequest) {
      let i = 0;
      const clearTimer = (timer2) => {
        if (timer2) {
          clearInterval(timer2);
          timer2 = null;
        }
      };
      const timer = setInterval(() => {
        if (isGet.value) return clearTimer(timer);
        request();
        i += tryIterationTime;
        if (i > tryIterationTime * tryCount) clearTimer(timer);
      }, tryIterationTime);
      useScopeDispose(() => clearTimer(timer));
    }
    return {
      sitePv: Vue.readonly(sitePv),
      siteUv: Vue.readonly(siteUv),
      pagePv: Vue.readonly(pagePv),
      pageUv: Vue.readonly(pageUv),
      today: Vue.readonly(today),
      yesterday: Vue.readonly(yesterday),
      isGet: Vue.readonly(isGet),
      request
    };
  };
  const createScript = (url, immediate = true) => {
    const scriptDom = document.createElement("script");
    scriptDom.type = "text/javascript";
    scriptDom.defer = true;
    scriptDom.src = url;
    immediate && document.body.appendChild(scriptDom);
    return scriptDom;
  };
  const callBusuanzi = (url = "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback") => {
    const jsonpCallback = "BusuanziCallback_" + Math.floor(1099511627776 * Math.random());
    url = url.replace("=BusuanziCallback", "=" + jsonpCallback);
    const scriptDom = createScript(url);
    scriptDom.referrerPolicy = "no-referrer-when-downgrade";
    let response;
    window[jsonpCallback] = (data) => response = data;
    return new Promise((resolve, reject) => {
      scriptDom.onload = () => {
        resolve(response);
        setTimeout(() => {
          document.body.removeChild(scriptDom);
        }, 10);
      };
      scriptDom.onerror = () => reject("Error Loading " + url);
    });
  };
  const callVercount = async (url = "//events.vercount.one/js", timeout = 5e3) => {
    localStorage.removeItem("visitorCountData");
    const scriptDom = createScript(url);
    return new Promise((resolve, reject) => {
      scriptDom.onload = () => {
        const intervalTime = 500;
        let count = timeout / intervalTime;
        const timer = setInterval(() => {
          count--;
          if (count <= 0) {
            clearInterval(timer);
            resolve({});
          }
          const visitorCountData = localStorage.getItem("visitorCountData");
          if (visitorCountData) {
            clearInterval(timer);
            resolve(JSON.parse(visitorCountData));
          }
        }, intervalTime);
        setTimeout(() => {
          document.body.removeChild(scriptDom);
        }, 10);
      };
      scriptDom.onerror = () => reject("Error Loading " + url);
    });
  };

  const useClipboard = (timeout = 1500) => {
    const copied = Vue.ref(false);
    const text = Vue.ref("");
    const isSupported = Vue.ref(false);
    if (isClient && !!navigator.clipboard && !!document.execCommand) isSupported.value = true;
    else isSupported.value = true;
    const copy = async (str, size = -1) => {
      if (!isClient) return;
      if (navigator.clipboard) {
        return await navigator.clipboard.writeText(str).then(() => {
          text.value = str;
          copied.value = true;
          resetCopied();
        });
      }
      const input = document.createElement("input");
      input.setAttribute("readonly", "readonly");
      input.setAttribute("value", str);
      document.body.appendChild(input);
      input.select();
      if (size > 0) input.setSelectionRange(0, size);
      if (document.execCommand("copy")) {
        text.value = str;
        document.execCommand("copy");
        copied.value = true;
        resetCopied();
      }
      document.body.removeChild(input);
    };
    const resetCopied = () => {
      setTimeout(() => {
        copied.value = false;
      }, timeout);
    };
    return { copy, text, copied, isSupported };
  };

  var namespaceModule = {"namespace":"tk"};

  const useNamespace = (block = "", namespaceOverrides) => {
    const finalNamespace = namespaceOverrides || namespaceModule.namespace;
    const b = (blockSuffix) => {
      return createBem(finalNamespace, block, blockSuffix);
    };
    const e = (element) => {
      return createBem(finalNamespace, block, "", element);
    };
    const m = (modifier) => {
      return createBem(finalNamespace, block, "", "", modifier);
    };
    const be = (blockSuffix, element) => {
      return createBem(finalNamespace, block, blockSuffix, element);
    };
    const bm = (blockSuffix, modifier) => {
      return createBem(finalNamespace, block, blockSuffix, "", modifier);
    };
    const em = (element, modifier) => {
      return createBem(finalNamespace, block, "", element, modifier);
    };
    const bem = (blockSuffix, element, modifier) => {
      return createBem(finalNamespace, block, blockSuffix, element, modifier);
    };
    const is = (name, bool = true) => {
      return bool ? `is-${name}` : "";
    };
    const has = (name, bool = true) => {
      return bool ? `has-${name}` : "";
    };
    const createBem = (namespace, block2, blockSuffix, element, modifier) => {
      let space = `${namespace}-${block2}`;
      if (blockSuffix) space += `-${blockSuffix}`;
      if (element) space += `__${element}`;
      if (modifier) space += `--${modifier}`;
      return space;
    };
    const join = (scope) => {
      return `${finalNamespace}-${scope}`;
    };
    const cssVar = (name) => `var(--${finalNamespace}-${name})`;
    const cssVarName = (name) => `--${finalNamespace}-${name}`;
    const storageKey = (...key) => `${finalNamespace}:${key.join(":")}`;
    return {
      namespaceModule,
      namespace: namespaceModule.namespace,
      b,
      e,
      m,
      be,
      bm,
      em,
      bem,
      is,
      has,
      createBem,
      join,
      cssVar,
      cssVarName,
      storageKey
    };
  };

  const useCopyBanner = (text = "\u590D\u5236\u6210\u529F\uFF0C\u590D\u5236\u548C\u8F6C\u8F7D\u8BF7\u6807\u6CE8\u672C\u6587\u5730\u5740", timeout = 3e3) => {
    if (!isClient) return;
    const ns = useNamespace("copy-banner");
    const listenerCopy = () => {
      if (!window.getSelection()?.toString().trim()) return;
      hideAllCopyBanner();
      const slideClass = ns.e("slide");
      const banner = document.createElement("div");
      const slide = document.createElement("div");
      banner.className = ns.b();
      banner.innerHTML = `
      <div class="${ns.e("content")}">
        <p class="${ns.e("desc")}">${text}</p>
      </div>
    `;
      slide.className = slideClass;
      banner.appendChild(slide);
      document.body.appendChild(banner);
      setTimeout(() => {
        banner.classList.add("is-show");
        slide.style.width = "100%";
      }, 10);
      setTimeout(() => {
        banner.classList.add("is-hide");
      }, timeout);
    };
    const hideAllCopyBanner = () => {
      const banner = document.querySelector(`.${ns.b()}`);
      if (!banner) return;
      banner.remove();
    };
    useEventListener(document, "copy", listenerCopy, { passive: true });
  };

  const useDebounce = (func, delay = 0, immediate = false) => {
    let timer;
    return (...args) => {
      const callNow = immediate && !timer;
      if (callNow) func(...args);
      const clearTimer = () => {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      };
      const later = () => {
        clearTimer();
        if (!immediate) func(...args);
      };
      clearTimer();
      timer = setTimeout(later, delay);
    };
  };

  const useElementHover = (el, options = {}) => {
    const { delayEnter = 0, delayLeave = 0 } = options;
    const isHovered = Vue.shallowRef(false);
    let timer;
    const toggle = (entering) => {
      const delay = entering ? delayEnter : delayLeave;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      if (delay) timer = setTimeout(() => isHovered.value = entering, delay);
      else isHovered.value = entering;
    };
    if (!isClient) return isHovered;
    useEventListener(el, "mouseenter", () => toggle(true), { passive: true });
    useEventListener(el, "mouseleave", () => toggle(false), { passive: true });
    return isHovered;
  };

  var zhCn = {
    lang: "zh-CN",
    tk: {
      archives: {
        label: "\u5F52\u6863\u9875",
        title: "\u5F52\u6863",
        totalCount: "\u603B\u5171 {count} \u7BC7\u6587\u7AE0",
        year: "\u5E74",
        month: "\u6708",
        count: "\u7BC7",
        notFound: "\u672A\u6307\u5B9A"
      },
      articleAnalyze: {
        label: "\u6587\u7AE0\u5206\u6790",
        wordCount: "\u6587\u7AE0\u5B57\u6570",
        readingTime: "\u9884\u8BA1\u9605\u8BFB\u65F6\u957F",
        pageView: "\u6D4F\u89C8\u91CF"
      },
      articleAppreciation: {
        label: "\u6587\u7AE0\u8D5E\u8D4F",
        contentLabel: "\u8D5E\u8D4F\u65B9\u5F0F"
      },
      articleBreadcrumb: {
        label: "\u6587\u7AE0\u9762\u5305\u5C51",
        home: "\u9996\u9875"
      },
      breadcrumb: {
        label: "\u9762\u5305\u5C51"
      },
      articleInfo: {
        label: "\u6587\u7AE0\u4FE1\u606F",
        author: "\u4F5C\u8005",
        createTime: "\u521B\u5EFA\u65F6\u95F4",
        updateTime: "\u66F4\u65B0\u65F6\u95F4",
        category: "\u5206\u7C7B",
        tag: "\u6807\u7B7E"
      },
      articleOverview: {
        label: "\u6587\u7AE0\u6E05\u5355",
        overview: " \u6E05\u5355",
        category: " \u76EE\u5F55",
        name: "\u6587\u7AE0\u76EE\u5F55",
        title: "\u6587\u7AE0\u6807\u9898",
        date: "\u53D1\u5E03\u65F6\u95F4",
        wordCount: "\u6587\u7AE0\u5B57\u6570",
        readingTime: "\u9884\u9605\u8BFB\u65F6\u957F"
      },
      articleShare: {
        label: "\u6587\u7AE0\u5206\u4EAB",
        text: "\u5206\u4EAB\u6B64\u9875\u9762",
        copiedText: "\u94FE\u63A5\u5DF2\u590D\u5236"
      },
      articleTitle: {
        label: "\u6587\u7AE0\u6807\u9898"
      },
      articleUpdate: {
        label: "\u6700\u8FD1\u66F4\u65B0"
      },
      catalogue: {
        label: "\u76EE\u5F55\u9875",
        title: "\u76EE\u5F55"
      },
      demoCode: {
        playground: "\u5728 Playground \u4E2D\u7F16\u8F91",
        github: "\u5728 Github \u4E2D\u7F16\u8F91",
        copy: "\u590D\u5236\u4EE3\u7801",
        collapseSource: "\u67E5\u770B\u6E90\u4EE3\u7801",
        expandSource: "\u9690\u85CF\u6E90\u4EE3\u7801",
        notSupport: "\u6D4F\u89C8\u5668\u4E0D\u652F\u6301\u590D\u5236",
        copySuccess: "\u590D\u5236\u6210\u529F",
        copyFail: "\u590D\u5236\u5931\u8D25"
      },
      footerInfo: {
        label: "\u9875\u811A\u4FE1\u606F",
        socialLabel: "\u793E\u4EA4\u5A92\u4F53",
        infoLabel: "\u9875\u811A\u5185\u5BB9"
      },
      home: {
        label: "\u9996\u9875",
        postLabel: "\u6587\u7AE0\u5217\u8868",
        cardLabel: "\u4FA7\u8FB9\u5361\u7247\u680F"
      },
      homeBanner: {
        label: "\u9996\u9875\u6A2A\u5E45",
        wavesLabel: "\u9996\u9875\u6A2A\u5E45\u6CE2\u6D6A",
        bgImgLabel: "\u9996\u9875\u6A2A\u5E45\u80CC\u666F\u56FE",
        maskLabel: "\u9996\u9875\u6A2A\u5E45\u906E\u7F69\u5C42",
        bgPureLabel: "\u9996\u9875\u6A2A\u5E45\u80CC\u666F\u8272",
        contentLabel: "\u9996\u9875\u6A2A\u5E45\u5185\u5BB9",
        titleLabel: "\u9996\u9875\u6A2A\u5E45\u6807\u9898",
        descLabel: "\u9996\u9875\u6A2A\u5E45\u63CF\u8FF0",
        descSwitchLabel: "\u63CF\u8FF0\u52A8\u6001\u5207\u6362",
        descTypedLabel: "\u63CF\u8FF0\u6253\u5B57\u673A\u6548\u679C",
        featureLabel: "\u9996\u9875\u6A2A\u5E45\u529F\u80FD\u7279\u6027"
      },
      homePost: {
        label: "\u6587\u7AE0\u5217\u8868",
        emptyLabel: "\u6682\u65E0\u6587\u7AE0",
        pageLabel: "\u5206\u9875\u5BFC\u822A",
        moreLabel: "\u9605\u8BFB\u5168\u6587 >",
        pin: "\u7F6E\u9876\uFF1A{sticky}",
        pinLabel: "\u7F6E\u9876\u6807\u5FD7",
        excerptLabel: "\u6587\u7AE0\u6458\u8981",
        infoLabel: "\u6587\u7AE0\u4FE1\u606F",
        coverImgLabel: "\u6587\u7AE0\u5C01\u9762\u56FE"
      },
      pageCard: {
        label: "\u9996\u9875\u5361\u7247",
        prev: "\u4E0A\u4E00\u9875",
        next: "\u4E0B\u4E00\u9875"
      },
      categoryCard: {
        pageTitle: "{icon}\u5168\u90E8\u5206\u7C7B",
        homeTitle: "{icon}\u6587\u7AE0\u5206\u7C7B",
        label: "\u9996\u9875\u5206\u7C7B\u5361\u7247",
        emptyLabel: "\u6682\u65E0\u6587\u7AE0\u5206\u7C7B",
        listLabel: "\u5206\u7C7B\u5217\u8868",
        moreLabel: "\u66F4\u591A ..."
      },
      docAnalysisCard: {
        title: "{icon}\u7AD9\u70B9\u4FE1\u606F",
        totalPosts: "\u6587\u7AE0\u6570\u76EE",
        weekAddNum: "\u8FD1\u4E00\u5468\u65B0\u589E",
        monthAddNum: "\u8FD1\u4E00\u6708\u65B0\u589E",
        runtime: "\u5DF2\u8FD0\u884C\u65F6\u95F4",
        totalWordCount: "\u672C\u7AD9\u603B\u5B57\u6570",
        lastActiveTime: "\u6700\u540E\u6D3B\u52A8\u65F6\u95F4",
        viewCount: "\u672C\u7AD9\u88AB\u8BBF\u95EE\u4E86",
        visitCount: "\u672C\u7AD9\u66FE\u6765\u8BBF\u8FC7",
        fileUnit: "\u7BC7",
        runtimeLess: "\u4E0D\u5230\u4E00\u5929",
        runtimeUnit: "\u5929",
        wordCountUnit: "\u5B57",
        viewCountUnit: "\u6B21",
        visitCountUnit: "\u4EBA",
        label: "\u9996\u9875\u7AD9\u70B9\u5206\u6790\u5361\u7247"
      },
      friendLinkCard: {
        title: "{icon}\u53CB\u60C5\u94FE\u63A5",
        emptyLabel: "\u6682\u65E0\u53CB\u60C5\u94FE\u63A5",
        label: "\u9996\u9875\u53CB\u60C5\u94FE\u63A5\u5361\u7247",
        listLabel: "\u53CB\u60C5\u94FE\u63A5\u5217\u8868"
      },
      myCard: {
        label: "\u6211\u7684\u4FE1\u606F\u5361\u7247",
        avatarAlt: "\u535A\u4E3B\u5934\u50CF",
        avatarTitle: "\u6211\u597D\u770B\u5417",
        socialLabel: "\u793E\u4EA4\u94FE\u63A5",
        bloggerLabel: "\u535A\u4E3B\u4FE1\u606F"
      },
      tagCard: {
        pageTitle: "{icon}\u5168\u90E8\u6807\u7B7E",
        homeTitle: "{icon}\u70ED\u95E8\u6807\u7B7E",
        label: "\u9996\u9875\u6807\u7B7E\u5361\u7247",
        emptyLabel: "\u6682\u65E0\u6807\u7B7E",
        listLabel: "\u6807\u7B7E\u5217\u8868",
        moreLabel: "\u66F4\u591A ..."
      },
      topArticleCard: {
        title: "{icon}\u7CBE\u9009\u6587\u7AE0",
        label: "\u9996\u9875\u7CBE\u9009\u6587\u7AE0\u5361\u7247",
        emptyLabel: "\u6682\u65E0\u7CBE\u9009\u6587\u7AE0",
        listLabel: "\u7CBE\u9009\u6587\u7AE0\u5217\u8868"
      },
      image: {
        error: "\u52A0\u8F7D\u5931\u8D25"
      },
      notice: {
        label: "\u516C\u544A\u680F",
        title: "\u516C\u544A",
        openLabel: "\u6253\u5F00\u516C\u544A\u5F39\u7A97",
        closeLabel: "\u5173\u95ED\u516C\u544A\u5F39\u7A97",
        headLabel: "\u516C\u544A\u5934\u90E8\u533A\u57DF",
        contentLabel: "\u516C\u544A\u5185\u5BB9"
      },
      pagination: {
        goto: "\u524D\u5F80",
        pagesize: "\u6761/\u9875",
        total: "\u5171 {total} \u6761",
        pageClassifier: "\u9875",
        page: "\u9875",
        prev: "\u4E0A\u4E00\u9875",
        next: "\u4E0B\u4E00\u9875",
        currentPage: "\u7B2C {pager} \u9875",
        prevPages: "\u5411\u524D {pager} \u9875",
        nextPages: "\u5411\u540E {pager} \u9875"
      },
      rightBottomButton: {
        backTopTitle: "\u8FD4\u56DE\u9876\u90E8",
        themeSizeTitle: "\u4E3B\u9898\u5C3A\u5BF8\u5207\u6362",
        themeStyleTitle: "\u4E3B\u9898\u98CE\u683C\u5207\u6362",
        toComment: "\u524D\u5F80\u8BC4\u8BBA"
      },
      themeEnhance: {
        title: "\u5E03\u5C40\u589E\u5F3A",
        layoutSwitch: {
          title: "\u5E03\u5C40\u5207\u6362",
          helpDesc: "\u8C03\u6574 VitePress \u7684\u5E03\u5C40\u6837\u5F0F\uFF0C\u4EE5\u9002\u914D\u4E0D\u540C\u7684\u9605\u8BFB\u4E60\u60EF\u548C\u5C4F\u5E55\u73AF\u5883\u3002",
          fullWidthTipTitle: "\u5168\u90E8\u5C55\u5F00",
          fullWidthHelpTipContent: "\u4F7F\u4FA7\u8FB9\u680F\u548C\u5185\u5BB9\u533A\u57DF\u5360\u636E\u6574\u4E2A\u5C4F\u5E55\u7684\u5168\u90E8\u5BBD\u5EA6\u3002",
          sidebarWidthAdjustableOnlyTipTitle: "\u5168\u90E8\u5C55\u5F00\uFF0C\u4F46\u4FA7\u8FB9\u680F\u5BBD\u5EA6\u53EF\u8C03",
          sidebarWidthAdjustableOnlyHelpTipContent: "\u4FA7\u8FB9\u680F\u5BBD\u5EA6\u53EF\u8C03\uFF0C\u4F46\u5185\u5BB9\u533A\u57DF\u5BBD\u5EA6\u4E0D\u53D8\uFF0C\u8C03\u6574\u540E\u7684\u4FA7\u8FB9\u680F\u5C06\u53EF\u4EE5\u5360\u636E\u6574\u4E2A\u5C4F\u5E55\u7684\u6700\u5927\u5BBD\u5EA6\u3002",
          bothWidthAdjustableTipTitle: "\u5168\u90E8\u5C55\u5F00\uFF0C\u4E14\u4FA7\u8FB9\u680F\u548C\u5185\u5BB9\u533A\u57DF\u5BBD\u5EA6\u5747\u53EF\u8C03",
          bothWidthAdjustableHelpTipContent: "\u4FA7\u8FB9\u680F\u548C\u5185\u5BB9\u533A\u57DF\u5BBD\u5EA6\u5747\u53EF\u8C03\uFF0C\u8C03\u6574\u540E\u7684\u4FA7\u8FB9\u680F\u548C\u5185\u5BB9\u533A\u57DF\u5C06\u53EF\u4EE5\u5360\u636E\u6574\u4E2A\u5C4F\u5E55\u7684\u6700\u5927\u5BBD\u5EA6\u3002",
          originalWidthTipTitle: "\u539F\u59CB\u5BBD\u5EA6",
          originalWidthHelpTipContent: "\u539F\u59CB\u7684 VitePress \u9ED8\u8BA4\u5E03\u5C40\u5BBD\u5EA6"
        },
        docLayoutMaxWidth: {
          title: "\u6587\u6863\u5185\u5BB9\u6700\u5927\u5BBD\u5EA6",
          helpDesc: "\u8C03\u6574 VitePress \u5E03\u5C40\u4E2D\u6587\u6863\u5185\u5BB9\u533A\u57DF\u7684\u5BBD\u5EA6\uFF0C\u4EE5\u9002\u914D\u4E0D\u540C\u7684\u9605\u8BFB\u4E60\u60EF\u548C\u5C4F\u5E55\u73AF\u5883\u3002",
          helpTipTitle: "\u8C03\u6574\u6587\u6863\u5185\u5BB9\u6700\u5927\u5BBD\u5EA6",
          helpTipContent: "\u4E00\u4E2A\u53EF\u8C03\u6574\u7684\u6ED1\u5757\uFF0C\u7528\u4E8E\u9009\u62E9\u548C\u81EA\u5B9A\u4E49\u6587\u6863\u5185\u5BB9\u6700\u5927\u5BBD\u5EA6\u3002"
        },
        pageLayoutMaxWidth: {
          title: "\u9875\u9762\u6700\u5927\u5BBD\u5EA6",
          helpDesc: "\u8C03\u6574 VitePress \u5E03\u5C40\u4E2D\u9875\u9762\u7684\u5BBD\u5EA6\uFF0C\u4EE5\u9002\u914D\u4E0D\u540C\u7684\u9605\u8BFB\u4E60\u60EF\u548C\u5C4F\u5E55\u73AF\u5883\u3002",
          helpTipTitle: "\u8C03\u6574\u9875\u9762\u6700\u5927\u5BBD\u5EA6",
          helpTipContent: "\u4E00\u4E2A\u53EF\u8C03\u6574\u7684\u6ED1\u5757\uFF0C\u7528\u4E8E\u9009\u62E9\u548C\u81EA\u5B9A\u4E49\u9875\u9762\u6700\u5927\u5BBD\u5EA6\u3002"
        },
        themeColor: {
          title: "\u4E3B\u9898\u8272",
          speedLabel: "\u6269\u6563",
          vpLabel: "VitePress \u4E3B\u9898",
          epLabel: "ElementPlus \u4E3B\u9898",
          vpTip: "VitePress \u4E3B\u9898",
          epTip: "ElementPlus \u4E3B\u9898",
          defaultLabel: "\u9884\u8BBE",
          blueLabel: "\u84DD\u8272",
          greenLabel: "\u7EFF\u8272",
          yellowLabel: "\u9EC4\u8272",
          redLabel: "\u7EA2\u8272",
          helpDesc: "\u63D0\u4F9B VitePress \u7684\u57FA\u7840\u8272\u677F\u548C ElementPlus \u7684\u57FA\u7840\u8272\u677F\u8FDB\u884C\u9009\u62E9\uFF0C\u901A\u8FC7\u6269\u6563\u5F00\u5173\u53EF\u4EE5\u5C06\u4E3B\u9898\u8272\u6269\u6563\u81F3\u5176\u4ED6\u5143\u7D20\uFF0C\u5982\u4FA7\u8FB9\u680F\u80CC\u666F\u8272\u3001\u5B57\u4F53\u8272\u7B49",
          vpHelpTipTitle: "VitePress \u57FA\u7840\u8272\u677F",
          vpHelpTipContent: "\u63D0\u4F9B\u84DD\uFF08\u9884\u8BBE\uFF09\u3001\u7EFF\u3001\u9EC4\u3001\u7EA2 4 \u79CD VitePress \u57FA\u7840\u8272\u677F",
          epHelpTipTitle: "ElementPlus \u57FA\u7840\u8272\u677F",
          epHelpTipContent: "\u63D0\u4F9B\u84DD\u3001\u7EFF\u3001\u9EC4\u3001\u7EA2 4 \u79CD ElementPlus \u57FA\u7840\u8272\u677F"
        },
        spotlight: {
          title: "\u805A\u5149\u706F",
          helpDesc: "\u652F\u6301\u5728\u6B63\u6587\u4E2D\u9AD8\u4EAE\u5F53\u524D\u9F20\u6807\u60AC\u505C\u7684\u884C\u548C\u5143\u7D20\uFF0C\u4EE5\u4F18\u5316\u9605\u8BFB\u548C\u4E13\u6CE8\u56F0\u96BE\u7684\u7528\u6237\u7684\u9605\u8BFB\u4F53\u9A8C\u3002",
          onTipTitle: "\u5F00\u542F",
          onHelpTipContent: "\u5F00\u542F\u805A\u5149\u706F\u3002",
          offTipTitle: "\u5173\u95ED",
          offHelpTipContent: "\u5173\u95ED\u805A\u5149\u706F\u3002"
        },
        spotlightStyles: {
          title: "\u805A\u5149\u706F\u6837\u5F0F",
          helpDesc: "\u8C03\u6574\u805A\u5149\u706F\u7684\u6837\u5F0F\u3002",
          asideTipTitle: "\u7F6E\u4E8E\u4FA7\u8FB9",
          asideHelpTipContent: "\u5728\u5F53\u524D\u9F20\u6807\u60AC\u505C\u7684\u5143\u7D20\u65C1\u8FB9\u6DFB\u52A0\u4E00\u6761\u56FA\u5B9A\u7684\u7EAF\u8272\u7EBF\u4EE5\u7A81\u51FA\u663E\u793A\u5F53\u524D\u9F20\u6807\u60AC\u505C\u7684\u4F4D\u7F6E\u3002",
          underTipTitle: "\u7F6E\u4E8E\u5E95\u90E8",
          underHelpTipContent: "\u5728\u5F53\u524D\u9F20\u6807\u60AC\u505C\u7684\u5143\u7D20\u4E0B\u65B9\u6DFB\u52A0\u4E00\u4E2A\u7EAF\u8272\u80CC\u666F\u4EE5\u7A81\u51FA\u663E\u793A\u5F53\u524D\u9F20\u6807\u60AC\u505C\u7684\u4F4D\u7F6E\u3002"
        }
      },
      login: {
        label: "\u767B\u5F55\u9875",
        reset: "\u91CD\u7F6E",
        login: "\u767B\u5F55",
        loginSuccess: "\u767B\u5F55\u6210\u529F\uFF01",
        loginError: "\u7528\u6237\u540D\u6216\u8005\u5BC6\u7801\u9519\u8BEF\uFF01",
        loginInfoNonNull: "\u8BF7\u8F93\u5165\u7528\u6237\u540D\u548C\u5BC6\u7801\uFF01",
        usernamePlaceholder: "\u8BF7\u8F93\u5165\u7528\u6237\u540D",
        passwordPlaceholder: "\u8BF7\u8F93\u5165\u5BC6\u7801",
        verifyCodePlaceholder: "\u8BF7\u8F93\u5165\u9A8C\u8BC1\u7801",
        verifyCodeNonNull: "\u8BF7\u8F93\u5165\u9A8C\u8BC1\u7801",
        verifyCodeError: "\u8BF7\u8F93\u5165\u6B63\u786E\u7684\u9A8C\u8BC1\u7801"
      },
      riskLink: {
        label: "\u98CE\u9669\u94FE\u63A5\u63D0\u793A\u9875",
        title: "\u5373\u5C06\u79BB\u5F00 {name}\uFF0C\u8BF7\u6CE8\u610F\u8D22\u4EA7\u5B89\u5168",
        linkIllegal: "\u94FE\u63A5\u5B89\u5168\u6027\u6821\u9A8C\u4E2D\uFF0C\u8BF7\u7A0D\u540E ...",
        confirmButtonText: "\u7EE7\u7EED\u8BBF\u95EE"
      },
      sidebarTrigger: {
        label: "\u4FA7\u8FB9\u680F\u5C55\u5F00/\u6298\u53E0"
      }
    }
  };

  var en = {
    lang: "en-US",
    tk: {
      archives: {
        label: "Archive Page",
        title: "Archive",
        totalCount: "Total {count} articles",
        year: "Year",
        month: "Month",
        count: "Articles",
        notFound: "Not specified"
      },
      articleAnalyze: {
        label: "Article Analysis",
        wordCount: "Word Count",
        readingTime: "Estimated Reading Time",
        pageView: "Page Views"
      },
      articleAppreciation: {
        label: "Article Appreciation",
        contentLabel: "Appreciation Method"
      },
      articleBreadcrumb: {
        label: "Article Breadcrumb",
        home: "Home"
      },
      breadcrumb: {
        label: "Breadcrumb"
      },
      articleInfo: {
        label: "Article Information",
        author: "Author",
        createTime: "Create Time",
        updateTime: "Update Time",
        category: "Category",
        tag: "Tag"
      },
      articleOverview: {
        label: "Article Overview",
        overview: " Overview",
        category: " Category",
        name: "Category",
        title: "Title",
        date: "Publish Time",
        wordCount: "Word Count",
        readingTime: "Reading Time"
      },
      articleShare: {
        label: "Article Sharing",
        text: "Share this page",
        copiedText: "Link copied"
      },
      articleTitle: {
        label: "Article Title"
      },
      articleUpdate: {
        label: "Recent Update"
      },
      catalogue: {
        label: "Catalogue Page",
        title: "Table of Contents"
      },
      demoCode: {
        playground: "Edit in Playground",
        github: "Edit in GitHub",
        copy: "Copy Code",
        collapseSource: "View Source Code",
        expandSource: "Hide Source Code",
        notSupport: "Browser does not support copying",
        copySuccess: "Copy successful",
        copyFail: "Copy failed"
      },
      footerInfo: {
        label: "Footer Information",
        socialLabel: "Social Media",
        infoLabel: "Footer Content"
      },
      home: {
        label: "Home",
        postLabel: "Article List",
        cardLabel: "Sidebar Card Bar"
      },
      homeBanner: {
        label: "Home Banner",
        wavesLabel: "Home Banner Waves",
        bgImgLabel: "Home Banner Background Image",
        maskLabel: "Home Banner Mask Layer",
        bgPureLabel: "Home Banner Background Color",
        contentLabel: "Home Banner Content",
        titleLabel: "Home Banner Title",
        descLabel: "Home Banner Description",
        descSwitchLabel: "Dynamic Description Switching",
        descTypedLabel: "Typewriter Effect Description",
        featureLabel: "Home Banner Features"
      },
      homePost: {
        label: "Article List",
        emptyLabel: "No articles available",
        pageLabel: "Pagination Navigation",
        moreLabel: "Read More >",
        pin: "Sticky: {sticky}",
        pinLabel: "Sticky Mark",
        excerptLabel: "Article Summary",
        infoLabel: "Article Information",
        coverImgLabel: "Article Cover Image"
      },
      pageCard: {
        label: "Home Card",
        prev: "Previous Page",
        next: "Next Page"
      },
      categoryCard: {
        pageTitle: "{icon} All Categories",
        homeTitle: "{icon} Article Categories",
        label: "Home Category Card",
        emptyLabel: "No categories available",
        listLabel: "Category List",
        moreLabel: "More ..."
      },
      docAnalysisCard: {
        title: "{icon} Site Information",
        totalPosts: "Number of Articles",
        weekAddNum: "Added in the Last Week",
        monthAddNum: "Added in the Last Month",
        runtime: "Running Time",
        totalWordCount: "Total Word Count",
        lastActiveTime: "Last Activity Time",
        viewCount: "This site has been visited",
        visitCount: "This site has had visitors",
        fileUnit: "Articles",
        runtimeLess: "Less than a day",
        runtimeUnit: "Days",
        wordCountUnit: "Words",
        viewCountUnit: "Times",
        visitCountUnit: "People",
        label: "Home Site Analysis Card"
      },
      friendLinkCard: {
        title: "{icon} Friend Links",
        emptyLabel: "No friend links available",
        label: "Home Friend Link Card",
        listLabel: "Friend Link List"
      },
      myCard: {
        label: "My Information Card",
        avatarAlt: "Blogger Avatar",
        avatarTitle: "Do I look good?",
        socialLabel: "Social Links",
        bloggerLabel: "Blogger Information"
      },
      tagCard: {
        pageTitle: "{icon} All Tags",
        homeTitle: "{icon} Popular Tags",
        label: "Home Tag Card",
        emptyLabel: "No tags available",
        listLabel: "Tag List",
        moreLabel: "More ..."
      },
      topArticleCard: {
        title: "{icon} Featured Articles",
        label: "Home Featured Article Card",
        emptyLabel: "No featured articles available",
        listLabel: "Featured Article List"
      },
      image: {
        error: "Failed to load"
      },
      notice: {
        label: "Announcement Bar",
        title: "Announcement",
        openLabel: "Open Announcement Popup",
        closeLabel: "Close Announcement Popup",
        headLabel: "Announcement Header Area",
        contentLabel: "Announcement Content"
      },
      pagination: {
        goto: "Go to",
        pagesize: "Items/Page",
        total: "Total {total} items",
        pageClassifier: "Page",
        page: "Page",
        prev: "Previous Page",
        next: "Next Page",
        currentPage: "Page {pager}",
        prevPages: "Previous {pager} Pages",
        nextPages: "Next {pager} Pages"
      },
      rightBottomButton: {
        backTopTitle: "Back to Top",
        themeSizeTitle: "Theme Size Switch",
        themeStyleTitle: "Theme Style Switch",
        toComment: "Go to Comment"
      },
      themeEnhance: {
        title: "Theme Enhancement",
        layoutSwitch: {
          title: "Layout Switch",
          helpDesc: "Adjust VitePress layout styles to adapt to different reading habits and screen environments.",
          fullWidthTipTitle: "Full Width",
          fullWidthHelpTipContent: "Make the sidebar and content area occupy the full width of the screen.",
          sidebarWidthAdjustableOnlyTipTitle: "Full Width, but Sidebar Width Adjustable",
          sidebarWidthAdjustableOnlyHelpTipContent: "The sidebar width is adjustable, but the content area width remains unchanged. The adjusted sidebar can occupy the maximum width of the screen.",
          bothWidthAdjustableTipTitle: "Full Width, and Both Sidebar and Content Area Widths Adjustable",
          bothWidthAdjustableHelpTipContent: "Both the sidebar and content area widths are adjustable. The adjusted sidebar and content area can occupy the maximum width of the screen.",
          originalWidthTipTitle: "Original Width",
          originalWidthHelpTipContent: "The original default VitePress layout width."
        },
        docLayoutMaxWidth: {
          title: "Document Content Maximum Width",
          helpDesc: "Adjust the width of the document content area in the VitePress layout to adapt to different reading habits and screen environments.",
          helpTipTitle: "Adjust Document Content Maximum Width",
          helpTipContent: "A slider to select and customize the maximum width of the document content."
        },
        pageLayoutMaxWidth: {
          title: "Page Maximum Width",
          helpDesc: "Adjust the width of the page in the VitePress layout to adapt to different reading habits and screen environments.",
          helpTipTitle: "Adjust Page Maximum Width",
          helpTipContent: "A slider to select and customize the maximum width of the page."
        },
        themeColor: {
          title: "Layout Theme Color",
          speedLabel: "Speed",
          vpLabel: "VitePress Theme",
          epLabel: "ElementPlus Theme",
          vpTip: "VitePress Theme",
          epTip: "ElementPlus Theme",
          defaultLabel: "Default",
          blueLabel: "Blue",
          greenLabel: "Green",
          yellowLabel: "Yellow",
          redLabel: "Red",
          helpDesc: "Provide VitePress base color palette and ElementPlus base color palette for selection. The theme color can be diffused to other elements such as sidebar background color, font color, etc. through the diffusion switch.",
          vpHelpTipTitle: "VitePress Base Color Palette",
          vpHelpTipContent: "Provides 4 VitePress base color palettes: Blue (default), Green, Yellow, Red.",
          epHelpTipTitle: "ElementPlus Base Color Palette",
          epHelpTipContent: "Provides 4 ElementPlus base color palettes: Blue, Green, Yellow, Red."
        },
        spotlight: {
          title: "Spotlight",
          helpDesc: "Highlight the current line or element under the mouse pointer in the main text to optimize the reading experience for users with focus difficulties.",
          onTipTitle: "Enable",
          onHelpTipContent: "Turn on the spotlight.",
          offTipTitle: "Disable",
          offHelpTipContent: "Turn off the spotlight."
        },
        spotlightStyles: {
          title: "Spotlight Styles",
          helpDesc: "Adjust the style of the spotlight.",
          asideTipTitle: "Place Aside",
          asideHelpTipContent: "Add a fixed solid line next to the current element under the mouse pointer to highlight its position.",
          underTipTitle: "Place Under",
          underHelpTipContent: "Add a solid background below the current element under the mouse pointer to highlight its position."
        }
      },
      login: {
        label: "Login Page",
        reset: "Reset",
        login: "Login",
        loginSuccess: "Login succeeded!",
        loginError: "Username or password incorrect!",
        loginInfoNull: "Please input your username and password!",
        usernamePlaceholder: "Please input a username",
        passwordPlaceholder: "Please input a password",
        verifyCodePlaceholder: "Please input the verification code",
        verifyCodeNonNull: "Please input the verification code",
        verifyCodeError: "Please input the correct verification code"
      },
      riskLink: {
        label: "Risk Link Page",
        title: "Leaving {name} soon, please pay attention to property safety",
        linkIllegal: "Link security verification in progress, please wait ...",
        confirmButtonText: "Continue to visit"
      },
      sidebarTrigger: {
        label: "Sidebar expand/collapse"
      }
    }
  };

  const localeContextKey = Symbol("localeContextKey");
  const useLocale = (localeOverride) => {
    const locale = localeOverride || Vue.inject(localeContextKey, Vue.ref());
    const finalLocale = Vue.computed(() => locale?.value || zhCn);
    const lang = Vue.computed(() => finalLocale.value.lang);
    const localeRef = Vue.isRef(finalLocale) ? finalLocale : Vue.ref(finalLocale);
    const translate = (path, option, locale2) => {
      return get(locale2, path, path).replace(/\{(\w+)\}/g, (_, key) => `${option?.[key] ?? `{${key}}`}`);
    };
    return {
      lang,
      locale: localeRef,
      t: (path, option) => {
        return translate(path, option, finalLocale.value);
      },
      translate
    };
  };

  const useMediaQuery = (query, match = true) => {
    const isSupported = Vue.shallowRef(false);
    useMounted(() => {
      isSupported.value = window && "matchMedia" in window && typeof window.matchMedia === "function";
    });
    const mediaQuery = Vue.shallowRef();
    const matches = Vue.shallowRef(false);
    const handler = (event) => {
      matches.value = event.matches;
    };
    Vue.watchEffect(() => {
      if (!isSupported.value) return;
      mediaQuery.value = window.matchMedia(Vue.toValue(query));
      matches.value = mediaQuery.value.matches;
    });
    useEventListener(mediaQuery, "change", handler, { passive: true });
    return Vue.computed(() => match ? matches.value : !matches.value);
  };

  const useWindowSize = (sizeChangedCallback, options = {}) => {
    const {
      initialWidth = Number.POSITIVE_INFINITY,
      initialHeight = Number.POSITIVE_INFINITY,
      includeScrollbar = true,
      type = "inner"
    } = options;
    const width = Vue.shallowRef(initialWidth);
    const height = Vue.shallowRef(initialHeight);
    let stop = () => {
    };
    const update = useDebounce(() => {
      if (!isClient) return;
      if (type === "outer") {
        width.value = window.outerWidth;
        height.value = window.outerHeight;
      } else if (type === "visual" && window.visualViewport) {
        const { width: visualViewportWidth, height: visualViewportHeight, scale } = window.visualViewport;
        width.value = Math.round(visualViewportWidth * scale);
        height.value = Math.round(visualViewportHeight * scale);
      } else if (includeScrollbar) {
        width.value = window.innerWidth;
        height.value = window.innerHeight;
      } else {
        width.value = window.document.documentElement.clientWidth;
        height.value = window.document.documentElement.clientHeight;
      }
      sizeChangedCallback?.(width.value, height.value);
    }, 100);
    update();
    useMounted(update);
    stop = useEventListener(() => window, "resize", update, { passive: true });
    if (isClient && type === "visual" && window.visualViewport) {
      stop = useEventListener(window.visualViewport, "resize", update, { passive: true });
    }
    return { width, height, update, stop };
  };

  const useScrollbarSize = () => {
    const width = Vue.ref(0);
    const height = Vue.ref(0);
    let measureElement = null;
    const createMeasureElement = () => {
      if (measureElement) return measureElement;
      document.querySelector("#measure-element")?.remove();
      measureElement = document.createElement("div");
      measureElement.id = "measure-element";
      measureElement.style.cssText = `
        position: fixed;
        top: -9999px;
        left: 0;
        width: 100px;
        height: 100px;
        overflow: scroll;
        visibility: hidden;
      `;
      document.body.appendChild(measureElement);
      return measureElement;
    };
    const clearMeasureElement = () => {
      if (!measureElement) return;
      if (document.body.contains(measureElement)) {
        document.body.removeChild(measureElement);
        measureElement = null;
      }
    };
    const calculate = () => {
      if (!isClient) return;
      const docElem = document.documentElement;
      const isQuirksMode = document.compatMode === "BackCompat";
      const hasVertical = isQuirksMode ? document.body.scrollHeight > document.body.clientHeight : docElem.scrollHeight > docElem.clientHeight;
      const hasHorizontal = isQuirksMode ? document.body.scrollWidth > document.body.clientWidth : docElem.scrollWidth > docElem.clientWidth;
      if (!hasVertical && !hasHorizontal) {
        width.value = 0;
        height.value = 0;
        return;
      }
      const measure = createMeasureElement();
      width.value = hasVertical ? measure.offsetWidth - measure.clientWidth : 0;
      height.value = hasHorizontal ? measure.offsetHeight - measure.clientHeight : 0;
    };
    const update = () => {
      calculate();
    };
    useEventListener(() => window, "resize", update);
    useMounted(() => {
      createMeasureElement();
      calculate();
    });
    calculate();
    useScopeDispose(clearMeasureElement);
    return { width, height, update };
  };

  const AUTO = "auto";
  const defaultSpace = 10;
  const usePopoverSize = (trigger, popover, options = {}) => {
    const { placement = "bottom", offset = 0, xOffset = 0, yOffset = 0 } = options;
    const top = Vue.ref(AUTO);
    const right = Vue.ref(AUTO);
    const bottom = Vue.ref(AUTO);
    const left = Vue.ref(AUTO);
    const { width: windowWidth, height: windowHeight } = useWindowSize();
    const { width: scrollbarWidth, height: scrollbarHeight } = useScrollbarSize();
    const triggerEl = Vue.computed(() => {
      const plain = Vue.toValue(trigger);
      return plain?.$el ?? plain;
    });
    const popoverEl = Vue.computed(() => {
      const plain = Vue.toValue(popover);
      return plain?.$el ?? plain;
    });
    const calculatePosition = async () => {
      if (!isClient || !triggerEl.value || !popoverEl.value) return;
      await Vue.nextTick();
      const {
        top: triggerTop,
        right: triggerLeftWidth,
        // 等于 left + width
        bottom: triggerTopHeigh,
        // 等于 top + height
        left: triggerLeft,
        width: triggerWidth,
        height: triggerHeight
      } = triggerEl.value.getBoundingClientRect();
      const triggerRight = windowWidth.value - triggerLeftWidth;
      const triggerBottom = windowHeight.value - triggerTopHeigh;
      const popoverWidth = popoverEl.value.offsetWidth;
      const popoverHeight = popoverEl.value.offsetHeight;
      const x = window.scrollX + (offset || xOffset);
      const y = window.scrollY + (offset || yOffset);
      let popoverTop = AUTO;
      let popoverRight = AUTO;
      let popoverBottom = AUTO;
      let popoverLeft = AUTO;
      const placementIsY = ["top", "bottom"].some((item) => placement.startsWith(item));
      const placementIsX = ["left", "right"].some((item) => placement.startsWith(item));
      const expectTop = () => triggerTop + triggerHeight + y;
      const expectRight = () => triggerRight + triggerWidth - x - scrollbarWidth.value;
      const expectBottom = () => triggerBottom + triggerHeight - y - scrollbarHeight.value;
      const expectLeft = () => triggerLeft + triggerWidth + x;
      if (placementIsY) {
        if (placement.endsWith("start")) popoverLeft = expectLeft() - triggerWidth;
        else if (placement.endsWith("end")) popoverRight = expectRight() - triggerWidth;
        else popoverLeft = triggerLeft + triggerWidth / 2 - popoverWidth / 2 + x;
      } else if (placementIsX) {
        if (placement.endsWith("start")) popoverTop = expectTop() - triggerHeight;
        else if (placement.endsWith("end")) popoverBottom = expectBottom() - triggerHeight;
        else popoverTop = triggerTop + triggerHeight / 2 - popoverHeight / 2 + y;
      }
      if (placement.startsWith("top")) popoverBottom = expectBottom() + defaultSpace;
      else if (placement.startsWith("right")) popoverLeft = expectLeft() + defaultSpace;
      else if (placement.startsWith("bottom")) popoverTop = expectTop() + defaultSpace;
      else if (placement.startsWith("left")) popoverRight = expectRight() + defaultSpace;
      const isOverTop = () => !isString$1(popoverBottom) && popoverBottom + popoverHeight > windowHeight.value - y;
      const isOverRight = () => !isString$1(popoverLeft) && popoverLeft + popoverWidth > windowWidth.value + x;
      const isOverBottom = () => !isString$1(popoverTop) && popoverTop + popoverHeight > windowHeight.value + y;
      const isOverLeft = () => !isString$1(popoverRight) && popoverRight + popoverWidth > windowWidth.value - x;
      if (isOverTop()) {
        popoverTop = (placementIsX ? expectTop() - triggerHeight : expectTop()) + defaultSpace;
        if (isOverBottom()) popoverTop = AUTO;
        else popoverBottom = AUTO;
      }
      if (isOverBottom()) {
        popoverBottom = (placementIsX ? expectBottom() - triggerHeight : expectBottom()) + defaultSpace;
        if (isOverTop()) popoverBottom = AUTO;
        else popoverTop = AUTO;
      }
      if (isOverRight()) {
        popoverRight = (placementIsY ? expectRight() - triggerWidth : expectRight()) + defaultSpace;
        if (isOverLeft()) popoverRight = AUTO;
        else popoverLeft = AUTO;
      }
      if (isOverLeft()) {
        popoverLeft = (placementIsY ? expectLeft() - triggerWidth : expectLeft()) + defaultSpace;
        if (isOverRight()) popoverLeft = AUTO;
        else popoverRight = AUTO;
      }
      top.value = popoverTop;
      right.value = popoverRight;
      bottom.value = popoverBottom;
      left.value = popoverLeft;
    };
    calculatePosition();
    const update = () => {
      calculatePosition();
    };
    useEventListener(() => window, "scroll", update);
    useEventListener(() => window, "resize", update);
    return { top, right, bottom, left, update };
  };

  const useScrollData = (data, limit, options = {}) => {
    const { intervalTime = 3e3, reloadWhenDataChanged = false } = options;
    const dataComputed = Vue.computed(() => Vue.toValue(data) || []);
    const visibleData = Vue.ref(dataComputed.value.slice(0, limit));
    let currentIndex = limit;
    let timer = null;
    const scrollData = () => {
      const nextIndex = (currentIndex + 1) % dataComputed.value.length;
      visibleData.value.push(dataComputed.value[nextIndex]);
      visibleData.value.shift();
      currentIndex = nextIndex;
    };
    const start = () => {
      scrollData();
      timer = setInterval(() => {
        scrollData();
      }, intervalTime);
    };
    const stop = (restore = false) => {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      if (restore) {
        visibleData.value = dataComputed.value.slice(0, limit);
        currentIndex = limit;
      }
    };
    const restart = () => {
      stop(true);
      start();
    };
    if (reloadWhenDataChanged) Vue.watch(dataComputed, () => restart());
    useScopeDispose(stop);
    return {
      data: visibleData,
      start,
      stop,
      restart
    };
  };

  const StorageSerializers = {
    boolean: { read: (v) => v === "true", write: (v) => String(v) },
    object: { read: (v) => JSON.parse(v), write: (v) => JSON.stringify(v) },
    number: { read: (v) => Number.parseFloat(v), write: (v) => String(v) },
    any: { read: (v) => v, write: (v) => String(v) },
    string: { read: (v) => v, write: (v) => String(v) },
    map: {
      read: (v) => new Map(JSON.parse(v)),
      write: (v) => JSON.stringify(Array.from(v.entries()))
    },
    set: { read: (v) => new Set(JSON.parse(v)), write: (v) => JSON.stringify(Array.from(v)) },
    date: { read: (v) => new Date(v), write: (v) => v.toISOString() }
  };
  const guessSerializerType = (rawInit) => {
    if (rawInit == null) return "any";
    if (rawInit instanceof Set) return "set";
    if (rawInit instanceof Map) return "map";
    if (rawInit instanceof Date) return "date";
    if (typeof rawInit === "boolean") return "boolean";
    if (typeof rawInit === "string") return "string";
    if (typeof rawInit === "number") return "number";
    if (typeof rawInit === "object") return "object";
    return "any";
  };
  const useStorage = (key, defaults, storageType = "localStorage", options = {}) => {
    const { flush = "pre", deep = true, writeDefaults = true, mergeDefaults = false, initOnMounted } = options;
    const rawInit = Vue.toValue(defaults);
    const data = Vue.ref(rawInit);
    if (!isClient) return data;
    const type = guessSerializerType(rawInit);
    const serializer = StorageSerializers[type];
    const keyComputed = Vue.computed(() => Vue.toValue(key));
    const storage = storageType === "localStorage" ? localStorage : sessionStorage;
    Vue.watch(keyComputed, () => update(), { flush });
    Vue.watch(data, () => write(data.value), { flush, deep });
    useMounted(() => {
      if (initOnMounted) update();
    });
    const dispatchWriteEvent = (oldValue, newValue) => {
      if (window) {
        const payload = { key: keyComputed.value, oldValue, newValue, storageArea: storage };
        window.dispatchEvent(new StorageEvent("storage", payload));
      }
    };
    const write = (val) => {
      const oldValue = storage.getItem(keyComputed.value);
      if (val == null) {
        dispatchWriteEvent(oldValue, null);
        storage.removeItem(keyComputed.value);
      } else {
        const serialized = serializer.write(val);
        if (oldValue !== serialized) {
          storage.setItem(keyComputed.value, serialized);
          dispatchWriteEvent(oldValue, serialized);
        }
      }
    };
    const read = (event) => {
      const rawValue = event ? event.newValue : storage.getItem(keyComputed.value);
      if (rawValue == null) {
        if (writeDefaults && rawInit != null) storage.setItem(keyComputed.value, serializer.write(rawInit));
        return rawInit;
      }
      if (!event && mergeDefaults) {
        const value = serializer.read(rawValue);
        if (typeof mergeDefaults === "function") return mergeDefaults(value, rawInit);
        if (type === "object" && !Array.isArray(value)) return { ...rawInit, ...value };
        return value;
      }
      if (typeof rawValue !== "string") return rawValue;
      else return serializer.read(rawValue);
    };
    const update = (event) => {
      if (event && event.storageArea !== storage) return;
      if (event && event.key == null) {
        data.value = rawInit;
        return;
      }
      if (event && event.key !== keyComputed.value) return;
      if (event?.newValue !== serializer.write(data.value)) data.value = read(event);
    };
    if (!initOnMounted) update();
    useEventListener(() => window, "storage", update, { passive: true });
    return data;
  };

  const useSwitchData = (dataList, options = {}) => {
    const {
      timeout = 4e3,
      shuffle = false,
      reloadWhenDataChanged = false,
      onBeforeUpdate,
      onUpdate,
      onAfterUpdate
    } = options;
    const dataListComputed = Vue.computed(() => Vue.toValue(dataList) || []);
    const index = Vue.ref(-1);
    let timer;
    const splitOutRandom = (dataList2) => {
      let newIndex;
      do {
        newIndex = Math.floor(Math.random() * dataList2.length);
      } while (newIndex === index.value);
      index.value = newIndex;
      return dataList2[newIndex];
    };
    const data = Vue.ref(shuffle ? splitOutRandom(dataListComputed.value) : dataListComputed.value[0]);
    const splitOutOrder = (dataList2) => {
      index.value = (index.value + 1) % dataList2.length;
      return dataList2[index.value];
    };
    const clearTimer = () => {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const startTimer = () => {
      clearTimer();
      if (timeout > 0) {
        timer = setTimeout(start, timeout);
      }
    };
    const start = () => {
      const dataListConst = dataListComputed.value;
      if (dataListConst.length < 1) return;
      if (dataListConst.length === 1) {
        data.value = dataListConst[0];
        return;
      }
      startTimer();
      let newValue;
      if (shuffle) newValue = splitOutRandom(dataListConst);
      else newValue = splitOutOrder(dataListConst);
      if (newValue === data.value) return;
      onBeforeUpdate?.(newValue);
      if (onUpdate) return onUpdate(data, newValue);
      data.value = newValue;
      onAfterUpdate?.(newValue);
    };
    const stop = (restore = false) => {
      clearTimer();
      if (restore) index.value = -1;
    };
    const restart = () => {
      stop(true);
      start();
    };
    if (reloadWhenDataChanged) Vue.watch(dataListComputed, () => restart());
    useScopeDispose(stop);
    return { data, index, start, stop, restart };
  };

  const useTextTypes = (data, options = {}) => {
    const { inputTime = 200, outputTime = 100, nextTime = 800, shuffle = false, reloadWhenDataChanged = false } = options;
    const dataComputed = Vue.computed(() => Vue.toValue(data) || []);
    const text = Vue.ref("");
    const isFinished = Vue.ref(false);
    let originText = "";
    let inputTimer;
    let outputTimer;
    let textIndex = 0;
    let dataIndex = 0;
    const clearInputTimer = () => {
      if (inputTimer) {
        clearInterval(inputTimer);
        inputTimer = null;
      }
    };
    const clearOutputTimer = () => {
      if (outputTimer) {
        clearInterval(outputTimer);
        outputTimer = null;
      }
    };
    const typesIn = () => {
      isFinished.value = false;
      originText = dataComputed.value[dataIndex];
      if (!originText) return stop();
      text.value = originText.substring(0, textIndex++);
      if (textIndex > originText.length) {
        clearInputTimer();
        isFinished.value = true;
        setTimeout(() => {
          outputTimer = setInterval(() => {
            typesOut();
          }, outputTime);
        }, nextTime);
      }
    };
    const typesOut = () => {
      if (textIndex >= 0) {
        isFinished.value = false;
        text.value = originText.substring(0, textIndex--);
      } else {
        clearOutputTimer();
        isFinished.value = true;
        setTimeout(() => {
          if (shuffle) {
            let newIndex;
            do {
              newIndex = Math.floor(Math.random() * dataComputed.value.length);
            } while (newIndex === dataIndex);
            dataIndex = newIndex;
          } else {
            dataIndex = (dataIndex + 1) % dataComputed.value.length;
          }
          inputTimer = setInterval(() => {
            typesIn();
          }, inputTime);
        }, nextTime);
      }
    };
    const start = () => {
      isFinished.value = false;
      inputTimer = setInterval(() => {
        typesIn();
      }, inputTime);
    };
    const stop = (restore = false) => {
      clearInputTimer();
      clearOutputTimer();
      isFinished.value = false;
      if (restore) {
        text.value = "";
        originText = "";
        textIndex = 0;
        dataIndex = 0;
      }
    };
    const restart = () => {
      stop(true);
      start();
    };
    if (reloadWhenDataChanged) Vue.watch(dataComputed, () => restart());
    useScopeDispose(stop);
    return { text, isFinished, start, stop, restart };
  };

  const vpBrand1 = "--vp-c-brand-1";
  const vpBrand2 = "--vp-c-brand-2";
  const vpBrand3 = "--vp-c-brand-3";
  const vpBrandSoft = "--vp-c-brand-soft";
  const vpBg = "--vp-c-bg";
  const vpBgAlt = "--vp-c-bg-alt";
  const vpBgSoft = "--vp-c-bg-soft";
  const vpBgElv = "--vp-c-bg-elv";
  const vpText1 = "--vp-c-text-1";
  const vpText2 = "--vp-c-text-2";
  const vpText3 = "--vp-c-text-3";
  const tkBgColorElm = "--tk-bg-color-elm";
  const tkBgColorMute = "--tk-bg-color-mute";
  const varNameList = {
    vpBrand1,
    vpBrand2,
    vpBrand3,
    vpBrandSoft,
    vpBg,
    vpBgAlt,
    vpBgSoft,
    vpBgElv,
    vpText1,
    vpText2,
    vpText3,
    tkBgColorElm,
    tkBgColorMute
  };
  const useThemeColor = (color, ignoreList) => {
    const isSpread = Vue.ref(false);
    const { isDark } = vitepress.useData();
    const setStyleVar = (key, value) => {
      if (!isClient) return;
      document.documentElement.style.setProperty(key, value);
    };
    const removeStyleVar = (key) => {
      if (!isClient) return;
      document.documentElement.style.removeProperty(key);
    };
    const colorComputed = Vue.computed(() => Vue.toValue(color));
    const clear = () => {
      Object.values(varNameList).forEach((key) => {
        removeStyleVar(key);
      });
    };
    const switchLight = () => {
      if (!isClient) return;
      const primary = colorComputed.value;
      if (!primary) return;
      const lightVarDefaultMap = {
        [vpBrand1]: primary,
        [vpBrand2]: getLightColor(primary, 0.1),
        [vpBrand3]: getLightColor(primary, 0.2),
        [vpBrandSoft]: getLightColor(primary, 0.85)
      };
      const lightVarSpreadMap = {
        [vpBg]: getLightColor(primary, 0.96),
        [vpBgAlt]: getLightColor(primary, 0.93),
        [vpBgElv]: getLightColor(primary, 0.945),
        [vpBgSoft]: getLightColor(primary, 0.93),
        [vpText1]: getDarkColor(primary, 0.6),
        [vpText2]: getDarkColor(primary, 0.7),
        [vpText3]: getLightColor(primary, 0.6),
        [tkBgColorElm]: getLightColor(primary, 0.945),
        [tkBgColorMute]: getLightColor(primary, 0.91)
      };
      const ignoreListConst = isFunction(ignoreList) ? ignoreList() : ignoreList || [];
      Object.keys(lightVarDefaultMap).forEach((key) => {
        if (ignoreListConst?.includes(key)) return;
        setStyleVar(key, lightVarDefaultMap[key]);
      });
      if (isSpread.value) {
        Object.keys(lightVarSpreadMap).forEach((key) => {
          if (ignoreListConst?.includes(key)) return;
          setStyleVar(key, lightVarSpreadMap[key]);
        });
      }
    };
    const switchDark = () => {
      if (!isClient) return;
      const primary = colorComputed.value;
      if (!primary) return;
      const darkVarDefaultMap = {
        [vpBrand1]: primary,
        [vpBrand2]: getDarkColor(primary, 0.1),
        [vpBrand3]: getDarkColor(primary, 0.2),
        [vpBrandSoft]: getDarkColor(primary, 0.85)
      };
      const darkVarSpreadMap = {
        [vpBg]: getDarkColor(primary, 0.92),
        [vpBgAlt]: getDarkColor(primary, 0.94),
        [vpBgElv]: getDarkColor(primary, 0.92),
        [vpBgSoft]: getDarkColor(primary, 0.94),
        [vpText1]: getLightColor(primary, 0.9),
        [tkBgColorElm]: getDarkColor(primary, 0.92),
        [tkBgColorMute]: getDarkColor(primary, 0.91)
      };
      const ignoreListConst = isFunction(ignoreList) ? ignoreList() : ignoreList || [];
      Object.keys(darkVarDefaultMap).forEach((key) => {
        if (ignoreListConst?.includes(key)) return;
        setStyleVar(key, darkVarDefaultMap[key]);
      });
      if (isSpread.value) {
        Object.keys(darkVarSpreadMap).forEach((key) => {
          if (ignoreListConst?.includes(key)) return;
          setStyleVar(key, darkVarSpreadMap[key]);
        });
      }
    };
    const isStop = Vue.shallowRef(false);
    let stopWatch = null;
    const start = () => {
      if (!isStop.value || !!stopWatch) return;
      isStop.value = false;
      update();
      stopWatch = Vue.watch(isDark, update, { flush: "post" });
    };
    const update = () => {
      if (isStop.value) return;
      clear();
      if (isDark.value) switchDark();
      else switchLight();
    };
    const stop = () => {
      stopWatch?.();
      stopWatch = null;
      isStop.value = true;
      clear();
    };
    start();
    Vue.watch(colorComputed, update);
    Vue.watch(isSpread, () => {
      stop();
      start();
    });
    return {
      isSpread: Vue.readonly(isSpread),
      start,
      stop,
      update,
      clear,
      updateSpread: (value) => isSpread.value = value
    };
  };

  const useViewTransition = (options) => {
    if (!isClient) return;
    const {
      enabled = true,
      mode = "out-in",
      duration = options.mode === "out-in" ? 300 : 600,
      easing = "ease-in"
    } = options;
    if (!enabled) return;
    const outIn = mode === "out-in";
    const { isDark } = vitepress.useData();
    document.documentElement.setAttribute("view-transition", mode);
    const enableTransitions = () => "startViewTransition" in document && window.matchMedia("(prefers-reduced-motion: no-preference)").matches;
    Vue.provide("toggle-appearance", async ({ clientX: x, clientY: y }) => {
      if (!enableTransitions()) {
        isDark.value = !isDark.value;
        return;
      }
      const clipPath = [
        `circle(0px at ${x}px ${y}px)`,
        `circle(${Math.hypot(Math.max(x, innerWidth - x), Math.max(y, innerHeight - y))}px at ${x}px ${y}px)`
      ];
      await document.startViewTransition(async () => {
        isDark.value = !isDark.value;
        await Vue.nextTick();
      }).ready;
      const isDarkCondition = outIn ? isDark.value : false;
      document.documentElement.animate(
        { clipPath: isDarkCondition ? clipPath.reverse() : clipPath },
        {
          duration,
          easing,
          fill: "forwards",
          pseudoElement: `::view-transition-${isDarkCondition ? "old" : "new"}(root)`
        }
      );
    });
  };

  const useVpRouter = () => {
    const router = vitepress.useRouter();
    const bindBeforeRouteChange = (stateFlag, bindFn, bindPosition = "after") => {
      const { state = {}, onBeforeRouteChange } = router;
      if (state[stateFlag]) return;
      const beforeFn = bindPosition === "before" ? bindFn : onBeforeRouteChange;
      const afterFn = bindPosition === "after" ? bindFn : onBeforeRouteChange;
      router.onBeforeRouteChange = async (href) => {
        const res = await beforeFn?.(href);
        if (res === false) return false;
        return await afterFn?.(href);
      };
      router.state = { ...state, [stateFlag]: true };
    };
    const bindBeforePageLoad = (stateFlag, bindFn, bindPosition = "after") => {
      const { state = {}, onBeforePageLoad } = router;
      if (state[stateFlag]) return;
      const beforeFn = bindPosition === "before" ? bindFn : onBeforePageLoad;
      const afterFn = bindPosition === "after" ? bindFn : onBeforePageLoad;
      router.onBeforePageLoad = async (href) => {
        const res = await beforeFn?.(href);
        if (res === false) return false;
        return await afterFn?.(href);
      };
      router.state = { ...state, [stateFlag]: true };
    };
    const bindAfterPageLoad = (stateFlag, bindFn, bindPosition = "after") => {
      const { state = {}, onAfterPageLoad } = router;
      if (state[stateFlag]) return;
      const beforeFn = bindPosition === "before" ? bindFn : onAfterPageLoad;
      const afterFn = bindPosition === "after" ? bindFn : onAfterPageLoad;
      router.onAfterPageLoad = async (href) => {
        await beforeFn?.(href);
        await afterFn?.(href);
      };
      router.state = { ...state, [stateFlag]: true };
    };
    const bindAfterRouteChange = (stateFlag, bindFn, bindPosition = "after") => {
      const { state = {}, onAfterRouteChange } = router;
      if (state[stateFlag]) return;
      const beforeFn = bindPosition === "before" ? bindFn : onAfterRouteChange;
      const afterFn = bindPosition === "after" ? bindFn : onAfterRouteChange;
      router.onAfterRouteChange = async (href) => {
        await beforeFn?.(href);
        await afterFn?.(href);
      };
      router.state = { ...state, [stateFlag]: true };
    };
    const bindRouterFn = (stateFlag, bindFn) => {
      const { state = {} } = router;
      if (state[stateFlag]) return;
      bindFn(router);
      router.state = { ...state, [stateFlag]: true };
    };
    return {
      router,
      route: router.route,
      bindBeforeRouteChange,
      bindBeforePageLoad,
      bindAfterPageLoad,
      bindAfterRouteChange,
      bindRouterFn
    };
  };

  const useWindowTransition = (element, immediate = true) => {
    let startInMounted = false;
    const cleanup = [];
    const start = () => {
      const elementConst = Vue.unref(element);
      if (!elementConst) return;
      if (isArray$1(elementConst)) elementConst.forEach((el) => initTransition(el));
      else initTransition(elementConst);
    };
    const initTransition = (el) => {
      el.classList.add("scroll__animate");
      const { create, clean } = useIntersectionObserver(
        el,
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              requestAnimationFrame(() => {
                try {
                  el.classList.add("visible");
                  clean();
                } catch (error) {
                  console.error("\u521D\u59CB\u5316\u52A8\u753B\u5931\u8D25:", error);
                }
              });
            }
          });
        },
        0.1
      );
      create();
      cleanup.push(clean);
    };
    const stop = () => {
      cleanup.forEach((fn) => fn());
    };
    const restart = () => {
      stop();
      start();
    };
    Vue.watch(
      () => Vue.unref(element),
      () => {
        !startInMounted && restart();
      },
      { deep: true }
    );
    useMounted(async () => {
      startInMounted = true;
      immediate && restart();
      await Vue.nextTick();
      startInMounted = false;
    });
    useScopeDispose(stop);
    return { start, stop, restart };
  };
  const useIntersectionObserver = (observerDom, callback, threshold) => {
    let intersectionObserver = null;
    const createIntersectionObserver = () => {
      const observerDomValue = Vue.unref(observerDom);
      if (intersectionObserver || !observerDomValue) return;
      intersectionObserver = new IntersectionObserver(callback, { threshold });
      intersectionObserver.observe(observerDomValue);
    };
    const cleanIntersectionObserver = () => {
      if (intersectionObserver) {
        intersectionObserver.disconnect();
        intersectionObserver = null;
      }
    };
    useScopeDispose(cleanIntersectionObserver);
    return { create: createIntersectionObserver, clean: cleanIntersectionObserver };
  };

  const initial = {
    current: 0
  };
  const zIndex = Vue.ref(0);
  const defaultInitialZIndex = 2e3;
  const Z_INDEX_INJECTION_KEY = Symbol("tkZIndexContextKey");
  const zIndexContextKey = Symbol("zIndexContextKey");
  const useZIndex = (zIndexOverrides) => {
    const increasingInjection = Vue.getCurrentInstance() ? Vue.inject(Z_INDEX_INJECTION_KEY, initial) : initial;
    const zIndexInjection = zIndexOverrides || (Vue.getCurrentInstance() ? Vue.inject(zIndexContextKey, void 0) : void 0);
    const initialZIndex = Vue.computed(() => {
      const zIndexFromInjection = zIndexInjection?.value;
      return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
    });
    const currentZIndex = Vue.computed(() => initialZIndex.value + zIndex.value);
    const nextZIndex = () => {
      increasingInjection.current++;
      zIndex.value = increasingInjection.current;
      return currentZIndex.value;
    };
    if (Vue.inject(Z_INDEX_INJECTION_KEY, void 0)) {
      console.warn(
        "ZIndexInjection",
        `Looks like you are using server rendering, you must provide a z-index provider to ensure the hydration process to be succeed
usage: app.provide(ZINDEX_INJECTION_KEY, { current: 0 })`
      );
    }
    return {
      initialZIndex,
      currentZIndex,
      nextZIndex
    };
  };

  const ignoreRE = /\b(?:VPBadge|header-anchor|footnote-ref|ignore-header)\b/;
  const resolvedHeaders = [];
  function resolveTitle(theme) {
    return typeof theme.outline === "object" && !Array.isArray(theme.outline) && theme.outline.label || "On this page";
  }
  function getHeaders(range) {
    const ns = useNamespace();
    const headers = [...document.querySelectorAll(`.${ns.join("article-page")} :where(h1,h2,h3,h4,h5,h6)`)].filter((el) => el.id && el.hasChildNodes()).map((el) => {
      const level = Number(el.tagName[1]);
      return {
        element: el,
        title: serializeHeader(el),
        link: "#" + el.id,
        level
      };
    });
    return resolveHeaders(headers, range);
  }
  function serializeHeader(h) {
    let ret = "";
    for (const node of h.childNodes) {
      if (node.nodeType === 1) {
        if (ignoreRE.test(node.className)) continue;
        ret += node.textContent;
      } else if (node.nodeType === 3) {
        ret += node.textContent;
      }
    }
    return ret.trim();
  }
  function resolveHeaders(headers, range) {
    if (range === false) {
      return [];
    }
    const levelsRange = (typeof range === "object" && !Array.isArray(range) ? range.level : range) || 2;
    const [high, low] = typeof levelsRange === "number" ? [levelsRange, levelsRange] : levelsRange === "deep" ? [2, 6] : levelsRange;
    return buildTree(headers, high, low);
  }
  const useActiveAnchor = (container, marker) => {
    const is1280 = useMediaQuery("(min-width: 1280px)");
    const onScroll = useDebounce(setActiveLink, 100);
    let prevActiveLink = null;
    Vue.onMounted(() => {
      requestAnimationFrame(setActiveLink);
      window.addEventListener("scroll", onScroll);
    });
    Vue.onUpdated(() => {
      activateLink(location.hash);
    });
    Vue.onUnmounted(() => {
      window.removeEventListener("scroll", onScroll);
    });
    function setActiveLink() {
      if (!is1280.value) return;
      const scrollY = window.scrollY;
      const innerHeight = window.innerHeight;
      const offsetHeight = document.body.offsetHeight;
      const isBottom = Math.abs(scrollY + innerHeight - offsetHeight) < 1;
      const headers = resolvedHeaders.map(({ element, link }) => ({
        link,
        top: getAbsoluteTop(element)
      })).filter(({ top }) => !Number.isNaN(top)).sort((a, b) => a.top - b.top);
      if (!headers.length) {
        activateLink(null);
        return;
      }
      if (scrollY < 1) {
        activateLink(null);
        return;
      }
      if (isBottom) {
        activateLink(headers[headers.length - 1].link);
        return;
      }
      let activeLink = null;
      for (const { link, top } of headers) {
        if (top > scrollY + vitepress.getScrollOffset() + 4) break;
        activeLink = link;
      }
      activateLink(activeLink);
    }
    function activateLink(hash) {
      if (prevActiveLink) prevActiveLink.classList.remove("active");
      if (hash == null) prevActiveLink = null;
      else prevActiveLink = container.value.querySelector(`a[href="${decodeURIComponent(hash)}"]`);
      const activeLink = prevActiveLink;
      if (activeLink) {
        activeLink.classList.add("active");
        marker.value.style.top = activeLink.offsetTop + 39 + "px";
        marker.value.style.opacity = "1";
      } else {
        marker.value.style.top = "33px";
        marker.value.style.opacity = "0";
      }
    }
  };
  function getAbsoluteTop(element) {
    let offsetTop = 0;
    while (element !== document.body) {
      if (element === null) {
        return NaN;
      }
      offsetTop += element.offsetTop;
      element = element.offsetParent;
    }
    return offsetTop;
  }
  function buildTree(data, min, max) {
    resolvedHeaders.length = 0;
    const result = [];
    const stack = [];
    data.forEach((item) => {
      const node = { ...item, children: [] };
      let parent = stack[stack.length - 1];
      while (parent && parent.level >= node.level) {
        stack.pop();
        parent = stack[stack.length - 1];
      }
      if (node.element.classList.contains("ignore-header") || parent && "shouldIgnore" in parent) {
        stack.push({ level: node.level, shouldIgnore: true });
        return;
      }
      if (node.level > max || node.level < min) return;
      resolvedHeaders.push({ element: node.element, link: node.link });
      if (parent) parent.children.push(node);
      else result.push(node);
      stack.push(node);
    });
    return result;
  }

  const _hoisted_1$11 = ["href", "title"];
  var _sfc_main$1A = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "DocAsideOutlineItem" },
    __name: "DocAsideOutlineItem",
    props: {
      headers: {},
      root: { type: Boolean }
    },
    setup(__props) {
      const ns = useNamespace("aside-outline-item");
      function onClick({ target: el }) {
        const id = el.href.split("#")[1];
        const heading = document.getElementById(decodeURIComponent(id));
        heading?.focus({ preventScroll: true });
      }
      return (_ctx, _cache) => {
        const _component_DocAsideOutlineItem = Vue.resolveComponent("DocAsideOutlineItem", true);
        return Vue.openBlock(), Vue.createElementBlock(
          "ul",
          {
            class: Vue.normalizeClass([Vue.unref(ns).b(), __props.root ? Vue.unref(ns).is("root") : Vue.unref(ns).is("nested")])
          },
          [
            (Vue.openBlock(true), Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(__props.headers, ({ children, link, title }) => {
                return Vue.openBlock(), Vue.createElementBlock("li", { key: link }, [
                  Vue.createElementVNode("a", {
                    class: Vue.normalizeClass(Vue.unref(ns).m("link")),
                    href: link,
                    onClick,
                    title
                  }, Vue.toDisplayString(title), 11, _hoisted_1$11),
                  children?.length ? (Vue.openBlock(), Vue.createBlock(_component_DocAsideOutlineItem, {
                    key: 0,
                    headers: children
                  }, null, 8, ["headers"])) : Vue.createCommentVNode("v-if", true)
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  var _sfc_main$1z = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "DocAsideOutline" },
    __name: "DocAsideOutline",
    setup(__props) {
      const ns = useNamespace("aside-outline");
      const { frontmatter, theme } = vitepress.useData();
      const headers = Vue.shallowRef([]);
      vitepress.onContentUpdated(() => {
        headers.value = getHeaders(frontmatter.value.outline ?? theme.value.outline);
      });
      Vue.onMounted(() => {
        if (!headers.value?.length) headers.value = getHeaders(frontmatter.value.outline ?? theme.value.outline);
      });
      const container = Vue.ref();
      const marker = Vue.ref();
      useActiveAnchor(container, marker);
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "nav",
          {
            "aria-labelledby": "doc-outline-aria-label",
            class: Vue.normalizeClass([Vue.unref(ns).b(), { "has-outline": headers.value.length > 0 }]),
            ref_key: "container",
            ref: container
          },
          [
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass(Vue.unref(ns).e("content"))
              },
              [
                Vue.createElementVNode(
                  "div",
                  {
                    class: Vue.normalizeClass(Vue.unref(ns).m("marker")),
                    ref_key: "marker",
                    ref: marker
                  },
                  null,
                  2
                  /* CLASS */
                ),
                Vue.createElementVNode(
                  "div",
                  {
                    id: "doc-outline-aria-label",
                    "aria-level": "2",
                    class: Vue.normalizeClass(Vue.unref(ns).m("title")),
                    role: "heading"
                  },
                  Vue.toDisplayString(Vue.unref(resolveTitle)(Vue.unref(theme))),
                  3
                  /* TEXT, CLASS */
                ),
                Vue.createVNode(_sfc_main$1A, {
                  headers: headers.value,
                  root: true
                }, null, 8, ["headers"])
              ],
              2
              /* CLASS */
            )
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  var _sfc_main$1y = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ArticlePage" },
    __name: "index",
    props: {
      doc: { type: Boolean },
      aside: { type: Boolean }
    },
    setup(__props) {
      const ns = useNamespace("article-page");
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("aside", __props.aside)])
          },
          [
            __props.aside ? (Vue.openBlock(), Vue.createElementBlock(
              "div",
              {
                key: 0,
                class: Vue.normalizeClass(Vue.unref(ns).e("aside"))
              },
              [
                Vue.createElementVNode(
                  "div",
                  {
                    class: Vue.normalizeClass(Vue.unref(ns).e("aside__container"))
                  },
                  [
                    Vue.createVNode(_sfc_main$1z)
                  ],
                  2
                  /* CLASS */
                )
              ],
              2
              /* CLASS */
            )) : Vue.createCommentVNode("v-if", true),
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass([Vue.unref(ns).join("doc"), { "vp-doc": __props.doc }])
              },
              [
                Vue.createElementVNode("div", null, [
                  Vue.renderSlot(_ctx.$slots, "default")
                ])
              ],
              2
              /* CLASS */
            )
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const _hoisted_1$10 = ["innerHTML"];
  var _sfc_main$1x = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "SvgIcon" },
    __name: "SvgIcon",
    props: {
      icon: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("i", { innerHTML: __props.icon }, null, 8, _hoisted_1$10);
      };
    }
  });

  const _hoisted_1$$ = {
    key: 0,
    class: "iconfont"
  };
  const _hoisted_2$M = {
    key: 2,
    class: "icon-svg",
    "aria-hidden": "true"
  };
  const _hoisted_3$x = ["xlink:href"];
  var _sfc_main$1w = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "FontIcon" },
    __name: "FontIcon",
    props: {
      icon: {},
      iconType: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return __props.iconType === "unicode" ? (Vue.openBlock(), Vue.createElementBlock(
          "i",
          _hoisted_1$$,
          Vue.toDisplayString(__props.icon),
          1
          /* TEXT */
        )) : __props.iconType === "iconfont" ? (Vue.openBlock(), Vue.createElementBlock(
          "i",
          {
            key: 1,
            class: Vue.normalizeClass(`iconfont ${__props.icon}`)
          },
          null,
          2
          /* CLASS */
        )) : __props.iconType === "symbol" ? (Vue.openBlock(), Vue.createElementBlock("svg", _hoisted_2$M, [
          Vue.createElementVNode("use", {
            "xlink:href": `#${__props.icon}`
          }, null, 8, _hoisted_3$x)
        ])) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  var _sfc_main$1v = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "IconifyOffline" },
    __name: "IconifyOffline",
    props: {
      icon: {}
    },
    setup(__props) {
      const props = __props;
      Vue.onMounted(() => {
        const id = Vue.useId();
        vue.addIcon(`iconify-${id}`, props.icon);
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.unref(vue.Icon), {
          icon: __props.icon,
          style: { outline: "none" }
        }, null, 8, ["icon"]);
      };
    }
  });

  var _sfc_main$1u = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "IconifyOnline" },
    __name: "IconifyOnline",
    props: {
      icon: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.unref(vue.Icon), {
          icon: __props.icon,
          style: { outline: "none" }
        }, null, 8, ["icon"]);
      };
    }
  });

  const _hoisted_1$_ = ["innerHTML"];
  const _hoisted_2$L = ["src", "alt"];
  var _sfc_main$1t = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "Icon" },
    __name: "index",
    props: {
      icon: { default: "" },
      iconType: {},
      size: {},
      color: {},
      hover: { type: Boolean, default: false },
      hoverColor: {},
      imgAlt: {},
      pointer: { type: Boolean, default: false },
      style: {}
    },
    setup(__props) {
      const ns = useNamespace("icon");
      const props = Vue.createPropsRestProxy(__props, ["icon", "iconType", "color", "hover", "hoverColor", "pointer"]);
      const slot = Vue.useSlots();
      const getStyle = () => {
        return {
          ...props.style,
          ...__props.pointer ? { cursor: "pointer" } : void 0,
          "--icon-color": __props.color,
          "--icon-size": props.size && addUnit(props.size),
          "--icon-color-hover": __props.hoverColor || ns.cssVar("theme-color")
        };
      };
      const finalIcon = Vue.computed(() => {
        if (!isString$1(__props.icon)) return Vue.toRaw(__props.icon);
        return __props.icon.replace(/^(svg-|if-|uni-|sym-|img-)/i, "");
      });
      const fontIconType = Vue.computed(() => {
        if (__props.iconType && ["unicode", "iconfont", "symbol"].includes(__props.iconType)) {
          return __props.iconType;
        }
        if (!isString$1(__props.icon)) return "";
        const caseIconName = __props.icon.toLowerCase();
        if (caseIconName.startsWith("if-") || caseIconName.startsWith("iconfont") || finalIcon.value.startsWith("icon-")) {
          return "iconfont";
        }
        if (caseIconName.startsWith("uni-") || /^&#x[\da-f]+/i.test(__props.icon) || __props.icon.length === 1 && __props.icon.charCodeAt(0) >= 57344 && __props.icon.charCodeAt(0) <= 63743) {
          return "unicode";
        }
        if (caseIconName.startsWith("sym-")) return "symbol";
        return "";
      });
      const isSvgIcon = Vue.computed(() => isString$1(__props.icon) && (__props.iconType === "svg" || __props.icon.startsWith("svg-") || isString$1(__props.icon)));
      const isSvgIconHtml = Vue.computed(() => isString$1(__props.icon) && __props.icon?.includes("<svg"));
      const isFontIcon = Vue.computed(() => isString$1(__props.icon) && fontIconType.value);
      const isComponent = Vue.computed(
        () => !isString$1(__props.icon) && (__props.iconType === "component" || isObject$2(__props.icon) && ("setup" in __props.icon || "render" in __props.icon) || typeof __props.icon === "function")
      );
      const isIconifyOffline = Vue.computed(() => !isString$1(__props.icon) && (__props.iconType === "iconifyOffline" || "body" in __props.icon));
      const isIconifyOnline = Vue.computed(() => isString$1(__props.icon) && (__props.iconType === "iconifyOnline" || __props.icon.includes(":")));
      const isImage = Vue.computed(
        () => isString$1(__props.icon) && (__props.iconType === "img" || __props.icon.toLowerCase().startsWith("img-") || [".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp", ".svg"].some((ext) => __props.icon.endsWith(ext)))
      );
      return (_ctx, _cache) => {
        return !isFontIcon.value && !isImage.value && !isSvgIconHtml.value ? (Vue.openBlock(), Vue.createElementBlock(
          "i",
          {
            key: 0,
            class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("hover", __props.hover)]),
            style: Vue.normalizeStyle(getStyle())
          },
          [
            Vue.unref(slot).default ? Vue.renderSlot(_ctx.$slots, "default", { key: 0 }) : isComponent.value ? (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(finalIcon.value), {
              key: 1,
              size: __props.size
            }, null, 8, ["size"])) : isIconifyOffline.value ? (Vue.openBlock(), Vue.createBlock(_sfc_main$1v, {
              key: 2,
              icon: finalIcon.value
            }, null, 8, ["icon"])) : isIconifyOnline.value ? (Vue.openBlock(), Vue.createBlock(_sfc_main$1u, {
              key: 3,
              icon: finalIcon.value
            }, null, 8, ["icon"])) : isSvgIcon.value ? (Vue.openBlock(), Vue.createBlock(_sfc_main$1x, {
              key: 4,
              icon: finalIcon.value
            }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true)
          ],
          6
          /* CLASS, STYLE */
        )) : isSvgIconHtml.value ? (Vue.openBlock(), Vue.createElementBlock("i", {
          key: 1,
          innerHTML: __props.icon,
          class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("hover", __props.hover)]),
          style: Vue.normalizeStyle(getStyle())
        }, null, 14, _hoisted_1$_)) : isFontIcon.value && fontIconType.value ? (Vue.openBlock(), Vue.createBlock(_sfc_main$1w, {
          key: 2,
          icon: finalIcon.value,
          iconType: fontIconType.value,
          class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("hover", __props.hover)]),
          style: Vue.normalizeStyle(getStyle())
        }, null, 8, ["icon", "iconType", "class", "style"])) : isImage.value ? (Vue.openBlock(), Vue.createElementBlock("img", {
          key: 3,
          src: finalIcon.value,
          alt: __props.imgAlt,
          class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("hover", __props.hover)]),
          style: Vue.normalizeStyle(getStyle())
        }, null, 14, _hoisted_2$L)) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  const gitee = `<svg t="1743875298298" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2388" width="200" height="200"><path d="M512 1024C229.2224 1024 0 794.7776 0 512S229.2224 0 512 0s512 229.2224 512 512-229.2224 512-512 512z m259.1488-568.8832H480.4096a25.2928 25.2928 0 0 0-25.2928 25.2928l-0.0256 63.2064c0 13.952 11.3152 25.2928 25.2672 25.2928h177.024c13.9776 0 25.2928 11.3152 25.2928 25.2672v12.6464a75.8528 75.8528 0 0 1-75.8528 75.8528H366.592a25.2928 25.2928 0 0 1-25.2672-25.2928v-240.1792a75.8528 75.8528 0 0 1 75.8272-75.8528h353.9456a25.2928 25.2928 0 0 0 25.2672-25.2928l0.0768-63.2064a25.2928 25.2928 0 0 0-25.2672-25.2928H417.152a189.6192 189.6192 0 0 0-189.6192 189.6448v353.9456c0 13.9776 11.3152 25.2928 25.2928 25.2928h372.9408a170.6496 170.6496 0 0 0 170.6496-170.6496v-145.408a25.2928 25.2928 0 0 0-25.2928-25.2672z" fill="#C71D23" p-id="2389"></path></svg>`;
  const email = `<svg t="1743875620187" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16697" width="200" height="200"><path d="M512 0A512 512 0 1 1 0 512 512 512 0 0 1 512 0z" fill="#ff485f" p-id="16698" data-spm-anchor-id="a313x.search_index.0.i13.70183a81yTylfI" class="selected"></path><path d="M726.980923 295.384615H280.123077A63.606154 63.606154 0 0 0 216.615385 358.892308v295.187692a63.606154 63.606154 0 0 0 63.507692 63.507692h446.857846a63.606154 63.606154 0 0 0 63.507692-63.507692v-295.187692A63.606154 63.606154 0 0 0 726.980923 295.384615z m25.403077 358.715077a25.481846 25.481846 0 0 1-25.403077 25.403077H280.123077a25.481846 25.481846 0 0 1-25.403077-25.403077v-295.187692a25.481846 25.481846 0 0 1 25.403077-25.403077h446.857846a25.481846 25.481846 0 0 1 25.403077 25.403077z" fill="#FFFFFF" p-id="16699"></path><path d="M693.720615 396.307692l-190.148923 119.965539-190.148923-119.965539a19.062154 19.062154 0 0 0-20.322461 32.236308l200.073846 126.247385a19.062154 19.062154 0 0 0 10.161231 2.934153h0.630153a19.062154 19.062154 0 0 0 10.161231-2.934153l200.073846-126.247385a19.101538 19.101538 0 1 0-20.48-32.236308z" fill="#FFFFFF" p-id="16700"></path></svg>`;
  const WhatsApp = `<svg t="1743875749604" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="20479" width="200" height="200"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#1BD741" p-id="20480"></path><path d="M760.2 269.5c-62.1-61.4-144.6-95.2-232.5-95.2-181.1 0-328.5 145.7-328.5 324.8 0 57.2 15.1 113.2 43.9 162.3l-46.6 168.3 174.2-45.2c48.2 25.9 102.1 39.5 157 39.6h0.1c181.1 0 328.6-145.7 328.6-324.8 0.1-86.8-34.1-168.3-96.2-229.8zM527.8 769.3c-49 0-97-13-139.1-37.6l-10-5.9-103.4 26.7 27.6-99.6-6.5-10.2c-27.4-43-42-92.8-41.8-143.6 0-148.9 122.5-270 273.3-270 72.9 0 141.6 28.2 193.2 79.1 51.4 50.6 80.1 119.3 79.9 191-0.1 149-122.6 270.1-273.2 270.1zM677.6 567c-8.2-4.1-48.6-23.7-56.1-26.4-7.5-2.7-13-4.1-18.5 4.1-5.4 8.1-21.2 26.4-26 31.9-4.8 5.4-9.6 6.1-17.7 2.1-8.2-4.1-34.7-12.7-66.1-40.3-24.4-21.5-40.9-48.1-45.7-56.2-4.8-8.1-0.5-12.6 3.6-16.5 3.8-3.6 8.2-9.5 12.3-14.2 4.1-4.7 5.4-8.1 8.2-13.6 2.7-5.4 1.4-10.1-0.6-14.2-2.1-4.1-18.5-44-25.3-60.3-6.6-15.9-13.5-13.7-18.5-13.9-4.8-0.2-10.2-0.2-15.7-0.2-5.4 0-14.4 2-21.9 10.1-7.5 8.1-28.7 27.8-28.7 67.7 0 39.9 29.4 78.5 33.6 84 4.1 5.4 57.9 87.4 140.3 122.5 19.6 8.3 34.8 13.3 46.8 17.1 19.7 6.1 37.6 5.2 51.7 3.2 15.8-2.3 48.6-19.6 55.4-38.5 6.9-18.9 6.9-35.2 4.8-38.5-2.1-3.7-7.6-5.8-15.9-9.9z m0 0" fill="#FFFFFF" p-id="20481"></path></svg>`;
  const telegram = `<svg xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" viewBox="0 0 24 24">
  <circle cx="12" cy="12" r="12" fill="#039be5"></circle>
  <path fill="#fff" d="m5.491 11.74 11.57-4.461c.537-.194 1.006.131.832.943l.001-.001-1.97 9.281c-.146.658-.537.818-1.084.508l-3-2.211-1.447 1.394c-.16.16-.295.295-.605.295l.213-3.053 5.56-5.023c.242-.213-.054-.333-.373-.121l-6.871 4.326-2.962-.924c-.643-.204-.657-.643.136-.953z"></path>
</svg>`;
  const bilibili = `<svg t="1753496507227" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1499" width="200" height="200"><path d="M0 0m184.32 0l655.36 0q184.32 0 184.32 184.32l0 655.36q0 184.32-184.32 184.32l-655.36 0q-184.32 0-184.32-184.32l0-655.36q0-184.32 184.32-184.32Z" fill="#EC5D85" p-id="1500"></path><path d="M512 241.96096h52.224l65.06496-96.31744c49.63328-50.31936 89.64096 0.43008 63.85664 45.71136l-34.31424 51.5072c257.64864 5.02784 257.64864 43.008 257.64864 325.03808 0 325.94944 0 336.46592-404.48 336.46592S107.52 893.8496 107.52 567.90016c0-277.69856 0-318.80192 253.14304-324.95616l-39.43424-58.368c-31.26272-54.90688 37.33504-90.40896 64.68608-42.37312l60.416 99.80928c18.18624-0.0512 41.18528-0.0512 65.66912-0.0512z" fill="#EF85A7" p-id="1501"></path><path d="M512 338.5856c332.8 0 332.8 0 332.8 240.64s0 248.39168-332.8 248.39168-332.8-7.75168-332.8-248.39168 0-240.64 332.8-240.64z" fill="#EC5D85" p-id="1502"></path><path d="M281.6 558.08a30.72 30.72 0 0 1-27.47392-16.97792 30.72 30.72 0 0 1 13.73184-41.216l122.88-61.44a30.72 30.72 0 0 1 41.216 13.74208 30.72 30.72 0 0 1-13.74208 41.216l-122.88 61.44a30.59712 30.59712 0 0 1-13.73184 3.23584zM752.64 558.08a30.60736 30.60736 0 0 1-12.8512-2.83648l-133.12-61.44a30.72 30.72 0 0 1-15.04256-40.7552 30.72 30.72 0 0 1 40.76544-15.02208l133.12 61.44A30.72 30.72 0 0 1 752.64 558.08zM454.656 666.88a15.36 15.36 0 0 1-12.288-6.1952 15.36 15.36 0 0 1 3.072-21.49376l68.5056-50.91328 50.35008 52.62336a15.36 15.36 0 0 1-22.20032 21.23776l-31.5904-33.024-46.71488 34.72384a15.28832 15.28832 0 0 1-9.13408 3.04128z" fill="#EF85A7" p-id="1503"></path><path d="M65.536 369.31584c15.03232 101.90848 32.84992 147.17952 44.544 355.328 14.63296 2.18112 177.70496 10.04544 204.05248-74.62912a16.14848 16.14848 0 0 0 1.64864-10.87488c-30.60736-80.3328-169.216-60.416-169.216-60.416s-10.36288-146.50368-11.49952-238.83776zM362.25024 383.03744l34.816 303.17568h34.64192L405.23776 381.1328zM309.52448 536.28928h45.48608l16.09728 158.6176-31.82592 1.85344zM446.86336 542.98624h45.80352V705.3312h-33.87392zM296.6016 457.97376h21.39136l5.2736 58.99264-18.91328 2.26304zM326.99392 457.97376h21.39136l2.53952 55.808-17.408 1.61792zM470.62016 459.88864h19.456v62.27968h-19.456zM440.23808 459.88864h22.20032v62.27968h-16.62976z" fill="#FFFFFF" p-id="1504"></path><path d="M243.56864 645.51936a275.456 275.456 0 0 1-28.4672 23.74656 242.688 242.688 0 0 1-29.53216 17.52064 2.70336 2.70336 0 0 1-4.4032-1.95584 258.60096 258.60096 0 0 1-5.12-29.57312c-1.41312-12.1856-1.95584-25.68192-2.16064-36.36224 0-0.3072 0-2.5088 3.01056-1.90464a245.92384 245.92384 0 0 1 34.22208 9.5744 257.024 257.024 0 0 1 32.3584 15.17568c0.52224 0.256 2.51904 1.4848 0.09216 3.77856z" fill="#EB5480" p-id="1505"></path><path d="M513.29024 369.31584c15.03232 101.90848 32.84992 147.17952 44.544 355.328 14.63296 2.18112 177.70496 10.04544 204.05248-74.62912a16.14848 16.14848 0 0 0 1.64864-10.87488c-30.60736-80.3328-169.216-60.416-169.216-60.416s-10.36288-146.50368-11.49952-238.83776zM810.00448 383.03744l34.816 303.17568h34.64192L852.992 381.1328zM757.27872 536.28928h45.48608l16.09728 158.6176-31.82592 1.85344zM894.6176 542.98624h45.80352V705.3312H906.5472zM744.35584 457.97376h21.39136l5.2736 58.99264-18.91328 2.26304zM774.74816 457.97376h21.39136l2.53952 55.808-17.408 1.61792zM918.3744 459.88864h19.456v62.27968h-19.456zM887.99232 459.88864h22.20032v62.27968h-16.62976z" fill="#FFFFFF" p-id="1506"></path><path d="M691.32288 645.51936a275.456 275.456 0 0 1-28.4672 23.74656 242.688 242.688 0 0 1-29.53216 17.52064 2.70336 2.70336 0 0 1-4.4032-1.95584 258.60096 258.60096 0 0 1-5.12-29.57312c-1.41312-12.1856-1.95584-25.68192-2.16064-36.36224 0-0.3072 0-2.5088 3.01056-1.90464a245.92384 245.92384 0 0 1 34.22208 9.5744 257.024 257.024 0 0 1 32.3584 15.17568c0.52224 0.256 2.51904 1.4848 0.09216 3.77856z" fill="#EB5480" p-id="1507"></path></svg>`;
  const github = `<svg t="1753496620677" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6072" width="200" height="200"><path d="M938.666667 512a426.666667 426.666667 0 0 1-291.84 404.48 22.186667 22.186667 0 0 1-19.2-2.986667 21.76 21.76 0 0 1-8.96-17.493333v-113.92a170.666667 170.666667 0 0 0-21.333334-87.893333 10.666667 10.666667 0 0 1 0-11.52 11.52 11.52 0 0 1 8.533334-5.973334c104.106667-10.666667 162.133333-52.053333 162.133333-164.693333a200.96 200.96 0 0 0-50.773333-143.36 183.466667 183.466667 0 0 0 8.106666-51.2 184.746667 184.746667 0 0 0-6.4-46.08 20.906667 20.906667 0 0 0-22.613333-15.36 189.866667 189.866667 0 0 0-104.106667 50.346667 422.826667 422.826667 0 0 0-160.426666 0A189.866667 189.866667 0 0 0 327.68 256a20.906667 20.906667 0 0 0-22.613333 15.36A184.746667 184.746667 0 0 0 298.666667 317.44a183.466667 183.466667 0 0 0 8.106666 51.2A200.96 200.96 0 0 0 256 512c0 118.613333 64.426667 158.293333 182.613333 168.106667a158.293333 158.293333 0 0 0-29.44 65.28v5.12a29.013333 29.013333 0 0 0 0 5.973333 25.173333 25.173333 0 0 1-27.306666 21.76 42.666667 42.666667 0 0 1-18.346667-5.12 227.84 227.84 0 0 1-60.586667-53.76 430.506667 430.506667 0 0 0-34.133333-34.56 116.906667 116.906667 0 0 0-25.173333-16.64 20.906667 20.906667 0 0 0-20.48 0 21.333333 21.333333 0 0 0-9.813334 17.92v2.56a21.333333 21.333333 0 0 0 9.813334 17.92 193.706667 193.706667 0 0 1 39.253333 44.8 282.026667 282.026667 0 0 0 67.84 73.386667 105.813333 105.813333 0 0 0 59.733333 17.92h15.36V896a21.76 21.76 0 0 1-8.96 17.493333 22.186667 22.186667 0 0 1-19.2 2.986667A426.666667 426.666667 0 1 1 938.666667 512z" p-id="6073"></path></svg>`;
  const moblieQQ = `<svg t="1753496663960" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="10780" width="200" height="200"><path d="M666.122449 909.061224c-10.44898 0-21.420408-1.044898-31.869388-2.612244-39.183673-4.702041-74.710204-23.510204-100.832653-53.289796-13.583673 5.22449-28.212245 5.22449-41.795918 0-21.420408 28.212245-61.64898 48.065306-108.669388 53.289796-66.35102 7.314286-138.44898-11.493878-144.718367-55.379592-5.22449-34.481633 37.093878-61.126531 81.502041-75.755102-25.6-28.212245-43.363265-63.738776-51.2-101.355102l-0.522449 0.522449c-25.077551 31.346939-41.795918 50.155102-61.126531 50.155102-2.089796 0-4.179592-0.522449-6.269388-1.044898-7.314286-2.612245-13.061224-8.881633-17.240816-18.808164-16.195918-34.481633-9.404082-100.310204 15.15102-150.465306 0 0 0-0.522449 0.522449-0.522449 12.538776-22.465306 27.689796-43.363265 45.453061-62.171428-6.269388-11.493878-10.44898-24.032653-12.016326-37.093878v-3.134694c0.522449-19.330612 10.44898-37.093878 26.644898-47.542857-10.971429-73.142857 9.926531-147.330612 58.514286-203.232653 49.110204-56.946939 120.163265-88.816327 194.873469-86.204081h4.702041c65.306122 0 129.567347 26.122449 177.110204 72.097959 49.110204 47.542857 76.8 112.326531 77.844898 180.767347v7.314285c0.522449 9.926531 0 19.330612-1.044898 29.257143 14.106122 8.881633 21.420408 20.37551 21.420408 48.065306 0 13.583673-1.044898 27.689796-9.926531 36.04898 13.061224 17.763265 28.734694 42.840816 41.27347 62.693877l2.612245 4.179592c20.37551 32.391837 23.510204 74.187755 22.987755 96.130613 0 17.240816-2.089796 58.514286-18.285714 70.530612-3.657143 2.612245-7.314286 3.657143-12.016327 3.657143h-4.179592c-26.122449 0-41.273469-23.510204-57.991837-48.587755l-1.567347-2.089796c-8.881633 36.571429-26.122449 71.053061-50.677551 99.265306 27.167347 9.404082 83.069388 31.346939 75.755103 73.142857-5.746939 35.526531-55.902041 62.171429-114.416327 62.171428z m-388.702041-63.738775z m250.253061-11.493878z m276.375511-140.016326z m-47.020409-235.102041z" fill="#7BD4EF" p-id="10781"></path></svg>`;
  const music = `<svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"  width="200" height="200"><path d="M0 0m184.32 0l655.36 0q184.32 0 184.32 184.32l0 655.36q0 184.32-184.32 184.32l-655.36 0q-184.32 0-184.32-184.32l0-655.36q0-184.32 184.32-184.32Z" fill="#EA3E3C" ></path><path d="M527.616 849.43872a373.6064 373.6064 0 0 1-162.54976-39.00416c-112.36352-55.16288-180.00896-176.29184-172.55424-308.67456 7.41376-130.34496 85.10464-237.4656 202.752-279.552a35.85024 35.85024 0 0 1 24.15616 67.51232c-107.66336 38.49216-150.81472 136.86784-155.29984 216.13568-5.86752 103.51616 46.08 197.79584 132.34176 240.13824 124.69248 60.30336 216.91392 22.35392 260.82304-5.64224 59.8016-38.16448 97.86368-100.01408 96.95232-157.55264-1.024-63.72352-24.064-120.99584-63.27296-157.14304a145.408 145.408 0 0 0-65.5872-35.28704q2.82624 9.76896 5.64224 19.32288c13.38368 45.63968 24.94464 85.05344 25.6 114.40128a134.26688 134.26688 0 0 1-37.69344 97.76128 139.1104 139.1104 0 0 1-100.6592 40.45824 140.10368 140.10368 0 0 1-100.47488-42.24 169.12384 169.12384 0 0 1-46.2848-122.76736c1.19808-85.12512 80.11776-153.28256 162.816-175.104a324.80256 324.80256 0 0 1-6.71744-67.05152 92.0576 92.0576 0 0 1 69.18144-91.81184c46.21312-12.53376 104.448 5.19168 124.66176 37.888a35.84 35.84 0 0 1-11.70432 49.31584 35.84 35.84 0 0 1-49.26464-11.65312 62.34112 62.34112 0 0 0-48.45568-5.21216c-4.32128 1.71008-12.35968 4.90496-12.76928 23.10144a270.87872 270.87872 0 0 0 6.73792 58.51136 217.4976 217.4976 0 0 1 133.56032 57.6512c53.57568 49.38752 85.0432 125.46048 86.35392 208.71168 1.29024 81.85856-49.7664 167.86432-130.048 219.136a310.14912 310.14912 0 0 1-168.2432 48.65024z m23.6544-457.55392c-56.77056 15.6672-107.4688 63.03744-108.07296 106.42432a98.304 98.304 0 0 0 25.6512 71.43424 68.0448 68.0448 0 0 0 49.36704 20.87936 67.24608 67.24608 0 0 0 49.44896-18.944 63.19104 63.19104 0 0 0 17.23392-46.08c-0.4096-19.79392-11.7248-58.368-22.67136-95.6928-3.61472-12.42112-7.35232-25.14944-10.9568-38.02112z" fill="#FFFFFF" ></path></svg>`;

  const _hoisted_1$Z = ["src", "alt", "srcSet"];
  const _hoisted_2$K = { key: 2 };
  var _sfc_main$1s = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "Avatar" },
    __name: "index",
    props: {
      size: {},
      shape: { default: "circle" },
      icon: {},
      iconSize: {},
      src: {},
      alt: {},
      srcSet: {},
      fit: { default: "cover" },
      bgColor: {},
      textColor: {},
      textSize: {},
      text: {}
    },
    emits: ["error"],
    setup(__props, { emit: __emit }) {
      const emit = __emit;
      const ns = useNamespace("avatar");
      const hasLoadError = Vue.ref(false);
      const avatarClass = Vue.computed(() => {
        const classList = [ns.b()];
        if (isString$1(__props.size)) classList.push(ns.m(__props.size));
        if (__props.icon) classList.push(ns.m("icon"));
        if (__props.shape) classList.push(ns.m(__props.shape));
        return classList;
      });
      const avatarStyle = Vue.computed(() => {
        return {
          [ns.cssVarName("avatar-size")]: addUnit(__props.size),
          [ns.cssVarName("avatar-bg-color")]: __props.bgColor,
          [ns.cssVarName("avatar-text-color")]: __props.textColor,
          [ns.cssVarName("avatar-text-size")]: addUnit(__props.textSize),
          [ns.cssVarName("avatar-icon-size")]: addUnit(__props.iconSize)
        };
      });
      const imgStyle = Vue.computed(() => ({ objectFit: __props.fit }));
      Vue.watch(
        () => __props.src,
        () => hasLoadError.value = false
      );
      const handleError = (e) => {
        hasLoadError.value = true;
        emit("error", e);
      };
      const captureText = (text) => {
        const isChinese = /^[\u4e00-\u9fa5]+$/.test(text);
        if (isChinese) return text.charAt(0);
        const words = text.split(/\s+/).filter((word) => word.length > 0);
        if (words.length >= 2) {
          return words.slice(0, 2).map((word) => word.charAt(0).toUpperCase()).join("");
        }
        if (words.length === 1) return text.slice(0, 2).toUpperCase();
        return "";
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "span",
          {
            class: Vue.normalizeClass(avatarClass.value),
            style: Vue.normalizeStyle(avatarStyle.value)
          },
          [
            (__props.src || __props.srcSet) && !hasLoadError.value ? (Vue.openBlock(), Vue.createElementBlock("img", {
              key: 0,
              src: __props.src,
              alt: __props.alt,
              srcSet: __props.srcSet,
              style: Vue.normalizeStyle(imgStyle.value),
              onError: handleError
            }, null, 44, _hoisted_1$Z)) : __props.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
              key: 1,
              icon: __props.icon
            }, null, 8, ["icon"])) : __props.text ? (Vue.openBlock(), Vue.createElementBlock(
              "span",
              _hoisted_2$K,
              Vue.toDisplayString(captureText(__props.text)),
              1
              /* TEXT */
            )) : Vue.renderSlot(_ctx.$slots, "default", { key: 3 })
          ],
          6
          /* CLASS, STYLE */
        );
      };
    }
  });

  const breadcrumbKey = Symbol("breadcrumbKey");

  const ns$2 = useNamespace("breadcrumb");

  const _hoisted_1$Y = ["aria-label"];
  var _sfc_main$1r = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "Breadcrumb" },
    __name: "Breadcrumb",
    props: {
      separator: { default: "/" }
    },
    setup(__props) {
      const { t } = useLocale();
      const breadcrumb = Vue.ref();
      Vue.provide(breadcrumbKey, { separator: __props.separator });
      Vue.onMounted(() => {
        const items = breadcrumb.value?.querySelectorAll(`.${ns$2.e("item")}`);
        if (items?.length) {
          items[items.length - 1].setAttribute("aria-current", "page");
        }
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          ref_key: "breadcrumb",
          ref: breadcrumb,
          class: Vue.normalizeClass(Vue.unref(ns$2).b()),
          role: "navigation",
          "aria-label": Vue.unref(t)("tk.breadcrumb.label")
        }, [
          Vue.renderSlot(_ctx.$slots, "default")
        ], 10, _hoisted_1$Y);
      };
    }
  });

  var _sfc_main$1q = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "BreadcrumbItem" },
    __name: "BreadcrumbItem",
    setup(__props) {
      const breadcrumbContext = Vue.inject(breadcrumbKey, void 0);
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "span",
          {
            class: Vue.normalizeClass(Vue.unref(ns$2).e("item"))
          },
          [
            Vue.createElementVNode(
              "span",
              {
                ref: "link",
                class: Vue.normalizeClass(Vue.unref(ns$2).e("inner")),
                role: "link"
              },
              [
                Vue.renderSlot(_ctx.$slots, "default")
              ],
              2
              /* CLASS */
            ),
            Vue.createElementVNode(
              "span",
              {
                class: Vue.normalizeClass(Vue.unref(ns$2).e("separator")),
                role: "presentation"
              },
              Vue.toDisplayString(Vue.unref(breadcrumbContext)?.separator),
              3
              /* TEXT, CLASS */
            )
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  let registeredEscapeHandlers = [];
  const cachedHandler = (event) => {
    if (event.code === "Escape") {
      registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
    }
  };
  const useEscapeKeydown = (handler) => {
    Vue.onMounted(() => {
      if (registeredEscapeHandlers.length === 0) document.addEventListener("keydown", cachedHandler);
      if (isClient) registeredEscapeHandlers.push(handler);
    });
    Vue.onBeforeUnmount(() => {
      registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
      if (registeredEscapeHandlers.length === 0) {
        if (isClient) document.removeEventListener("keydown", cachedHandler);
      }
    });
  };

  const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
  const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
  const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
  const FOCUS_AFTER_TRAPPED_OPTS = {
    cancelable: true,
    bubbles: false
  };
  const FOCUSOUT_PREVENTED_OPTS = {
    cancelable: true,
    bubbles: false
  };
  const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
  const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
  const FOCUS_TRAP_INJECTION_KEY = Symbol("focusTrap");

  const focusReason = Vue.ref();
  const lastUserFocusTimestamp = Vue.ref(0);
  const lastAutomatedFocusTimestamp = Vue.ref(0);
  let focusReasonUserCount = 0;
  const obtainAllFocusableElements = (element) => {
    const nodes = [];
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode()) nodes.push(walker.currentNode);
    return nodes;
  };
  const getVisibleElement = (elements, container) => {
    for (const element of elements) {
      if (!isHidden(element, container)) return element;
    }
  };
  const isHidden = (element, container) => {
    if (process.env.NODE_ENV === "test") return false;
    if (getComputedStyle(element).visibility === "hidden") return true;
    while (element) {
      if (container && element === container) return false;
      if (getComputedStyle(element).display === "none") return true;
      element = element.parentElement;
    }
    return false;
  };
  const getEdges = (container) => {
    const focusable = obtainAllFocusableElements(container);
    const first = getVisibleElement(focusable, container);
    const last = getVisibleElement(focusable.reverse(), container);
    return [first, last];
  };
  const isSelectable = (element) => {
    return element instanceof HTMLInputElement && "select" in element;
  };
  const tryFocus = (element, shouldSelect) => {
    if (element && element.focus) {
      const prevFocusedElement = document.activeElement;
      let cleanup = false;
      if (isElement(element) && !isFocusable(element) && !element.getAttribute("tabindex")) {
        element.setAttribute("tabindex", "-1");
        cleanup = true;
      }
      element.focus({ preventScroll: true });
      lastAutomatedFocusTimestamp.value = window.performance.now();
      if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
        element.select();
      }
      if (isElement(element) && cleanup) {
        element.removeAttribute("tabindex");
      }
    }
  };
  function removeFromStack(list, item) {
    const copy = [...list];
    const idx = list.indexOf(item);
    if (idx !== -1) {
      copy.splice(idx, 1);
    }
    return copy;
  }
  const createFocusableStack = () => {
    let stack = [];
    const push = (layer) => {
      const currentLayer = stack[0];
      if (currentLayer && layer !== currentLayer) {
        currentLayer.pause();
      }
      stack = removeFromStack(stack, layer);
      stack.unshift(layer);
    };
    const remove = (layer) => {
      stack = removeFromStack(stack, layer);
      stack[0]?.resume?.();
    };
    return {
      push,
      remove
    };
  };
  const focusFirstDescendant = (elements, shouldSelect = false) => {
    const prevFocusedElement = document.activeElement;
    for (const element of elements) {
      tryFocus(element, shouldSelect);
      if (document.activeElement !== prevFocusedElement) return;
    }
  };
  const focusableStack = createFocusableStack();
  const isFocusCausedByUserEvent = () => {
    return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
  };
  const notifyFocusReasonPointer = () => {
    focusReason.value = "pointer";
    lastUserFocusTimestamp.value = window.performance.now();
  };
  const notifyFocusReasonKeydown = () => {
    focusReason.value = "keyboard";
    lastUserFocusTimestamp.value = window.performance.now();
  };
  const useFocusReason = () => {
    Vue.onMounted(() => {
      if (focusReasonUserCount === 0) {
        document.addEventListener("mousedown", notifyFocusReasonPointer);
        document.addEventListener("touchstart", notifyFocusReasonPointer);
        document.addEventListener("keydown", notifyFocusReasonKeydown);
      }
      focusReasonUserCount++;
    });
    Vue.onBeforeUnmount(() => {
      focusReasonUserCount--;
      if (focusReasonUserCount <= 0) {
        document.removeEventListener("mousedown", notifyFocusReasonPointer);
        document.removeEventListener("touchstart", notifyFocusReasonPointer);
        document.removeEventListener("keydown", notifyFocusReasonKeydown);
      }
    });
    return {
      focusReason,
      lastUserFocusTimestamp,
      lastAutomatedFocusTimestamp
    };
  };
  const createFocusOutPreventedEvent = (detail) => {
    return new CustomEvent(FOCUSOUT_PREVENTED, {
      ...FOCUSOUT_PREVENTED_OPTS,
      detail
    });
  };

  var _sfc_main$1p = Vue.defineComponent({
    name: "FocusTrap",
    inheritAttrs: false,
    props: {
      loop: Boolean,
      trapped: Boolean,
      focusTrapEl: Object,
      focusStartEl: {
        type: [Object, String],
        default: "first"
      }
    },
    emits: [ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, "focusin", "focusout", "focusout-prevented", "release-requested"],
    setup(props, { emit }) {
      const forwardRef = Vue.ref();
      let lastFocusBeforeTrapped;
      let lastFocusAfterTrapped;
      const { focusReason } = useFocusReason();
      useEscapeKeydown((event) => {
        if (props.trapped && !focusLayer.paused) emit("release-requested", event);
      });
      const focusLayer = {
        paused: false,
        pause() {
          this.paused = true;
        },
        resume() {
          this.paused = false;
        }
      };
      const onKeydown = (e) => {
        if (!props.loop && !props.trapped) return;
        if (focusLayer.paused) return;
        const { code, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
        const { loop } = props;
        const isTabbing = code === "Tab" && !altKey && !ctrlKey && !metaKey;
        const currentFocusingEl = document.activeElement;
        if (isTabbing && currentFocusingEl) {
          const container = currentTarget;
          const [first, last] = getEdges(container);
          const isTabbable = first && last;
          if (!isTabbable) {
            if (currentFocusingEl === container) {
              const focusoutPreventedEvent = createFocusOutPreventedEvent({
                focusReason: focusReason.value
              });
              emit("focusout-prevented", focusoutPreventedEvent);
              if (!focusoutPreventedEvent.defaultPrevented) e.preventDefault();
            }
          } else {
            if (!shiftKey && currentFocusingEl === last) {
              const focusoutPreventedEvent = createFocusOutPreventedEvent({
                focusReason: focusReason.value
              });
              emit("focusout-prevented", focusoutPreventedEvent);
              if (!focusoutPreventedEvent.defaultPrevented) {
                e.preventDefault();
                if (loop) tryFocus(first, true);
              }
            } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
              const focusoutPreventedEvent = createFocusOutPreventedEvent({
                focusReason: focusReason.value
              });
              emit("focusout-prevented", focusoutPreventedEvent);
              if (!focusoutPreventedEvent.defaultPrevented) {
                e.preventDefault();
                if (loop) tryFocus(last, true);
              }
            }
          }
        }
      };
      Vue.provide(FOCUS_TRAP_INJECTION_KEY, {
        focusTrapRef: forwardRef,
        onKeydown
      });
      Vue.watch(
        () => props.focusTrapEl,
        (focusTrapEl) => {
          if (focusTrapEl) forwardRef.value = focusTrapEl;
        },
        { immediate: true }
      );
      Vue.watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
        if (forwardRef2) {
          forwardRef2.addEventListener("keydown", onKeydown);
          forwardRef2.addEventListener("focusin", onFocusIn);
          forwardRef2.addEventListener("focusout", onFocusOut);
        }
        if (oldForwardRef) {
          oldForwardRef.removeEventListener("keydown", onKeydown);
          oldForwardRef.removeEventListener("focusin", onFocusIn);
          oldForwardRef.removeEventListener("focusout", onFocusOut);
        }
      });
      const trapOnFocus = (e) => {
        emit(ON_TRAP_FOCUS_EVT, e);
      };
      const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);
      const onFocusIn = (e) => {
        const trapContainer = forwardRef.value;
        if (!trapContainer) return;
        const target = e.target;
        const relatedTarget = e.relatedTarget;
        const isFocusedInTrap = target && trapContainer.contains(target);
        if (!props.trapped) {
          const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
          if (!isPrevFocusedInTrap) lastFocusBeforeTrapped = relatedTarget;
        }
        if (isFocusedInTrap) emit("focusin", e);
        if (focusLayer.paused) return;
        if (props.trapped) {
          if (isFocusedInTrap) lastFocusAfterTrapped = target;
          else tryFocus(lastFocusAfterTrapped, true);
        }
      };
      const onFocusOut = (e) => {
        const trapContainer = forwardRef.value;
        if (focusLayer.paused || !trapContainer) return;
        if (props.trapped) {
          const relatedTarget = e.relatedTarget;
          if (!relatedTarget && !trapContainer.contains(relatedTarget)) {
            setTimeout(() => {
              if (!focusLayer.paused && props.trapped) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason.value
                });
                emit("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  tryFocus(lastFocusAfterTrapped, true);
                }
              }
            }, 0);
          }
        } else {
          const target = e.target;
          const isFocusedInTrap = target && trapContainer.contains(target);
          if (!isFocusedInTrap) emit("focusout", e);
        }
      };
      async function startTrap() {
        await Vue.nextTick();
        const trapContainer = forwardRef.value;
        if (trapContainer) {
          focusableStack.push(focusLayer);
          const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
          lastFocusBeforeTrapped = prevFocusedElement;
          const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
          if (!isPrevFocusContained) {
            const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
            trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
            trapContainer.dispatchEvent(focusEvent);
            if (!focusEvent.defaultPrevented) {
              Vue.nextTick(() => {
                let focusStartEl = props.focusStartEl;
                if (!isString$1(focusStartEl)) {
                  tryFocus(focusStartEl);
                  if (document.activeElement !== focusStartEl) focusStartEl = "first";
                }
                if (focusStartEl === "first") focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                  tryFocus(trapContainer);
                }
              });
            }
          }
        }
      }
      function stopTrap() {
        const trapContainer = forwardRef.value;
        if (trapContainer) {
          trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
          const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
            ...FOCUS_AFTER_TRAPPED_OPTS,
            detail: {
              focusReason: focusReason.value
            }
          });
          trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
          trapContainer.dispatchEvent(releasedEvent);
          if (!releasedEvent.defaultPrevented && (focusReason.value === "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
            tryFocus(lastFocusBeforeTrapped ?? document.body);
          }
          trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
          focusableStack.remove(focusLayer);
        }
      }
      Vue.onMounted(() => {
        if (props.trapped) startTrap();
        Vue.watch(
          () => props.trapped,
          (trapped) => {
            if (trapped) startTrap();
            else stopTrap();
          }
        );
      });
      Vue.onBeforeUnmount(() => {
        if (props.trapped) stopTrap();
        if (forwardRef.value) {
          forwardRef.value.removeEventListener("keydown", onKeydown);
          forwardRef.value.removeEventListener("focusin", onFocusIn);
          forwardRef.value.removeEventListener("focusout", onFocusOut);
          forwardRef.value = void 0;
        }
      });
      return {
        onKeydown
      };
    }
  });

  var _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };

  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
  }
  var TkFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main$1p, [["render", _sfc_render]]);

  var aliPayIcon = `<svg
      id="mx_n_1711731519286"
      t="1711731519285"
      class="icon"
      viewBox="0 0 1024 1024"
      version="1.1"
      xmlns="http://www.w3.org/2000/svg"
      p-id="9945"
      width="16"
      height="16"
    >
      <path
        fill="currentColor"
        d="M230.404 576.536c-12.087 9.728-25.043 23.93-28.805 41.984-5.12 24.666-1.069 55.541 22.728 79.761 28.828 29.362 72.637 37.398 91.56 38.779 51.4 3.717 106.184-21.772 147.477-50.844 16.184-11.42 43.899-34.349 70.39-69.721-59.37-30.653-133.477-64.557-212.703-61.24-40.47 1.692-69.454 10.084-90.647 21.281z m752.859 135.545C1009.463 650.574 1024 582.968 1024 512 1024 229.688 794.335 0 512 0 229.665 0 0 229.688 0 512c0 282.335 229.665 512 512 512 170.385 0 321.491-83.723 414.631-212.124-87.997-43.742-233.027-115.734-322.36-159.299-42.63 48.596-105.65 97.303-176.84 118.495-44.722 13.29-85.037 18.365-127.199 9.75-41.739-8.548-72.481-28.093-90.401-47.683-9.127-9.995-19.612-22.706-27.203-37.82a71.25 71.25 0 0 0 1.202 3.049s-4.363-7.524-7.702-19.5a85.994 85.994 0 0 1-3.34-18.143 93.517 93.517 0 0 1-0.2-13.045c-0.378-7.702-0.066-15.783 1.67-24.064 4.185-20.235 12.822-43.81 35.172-65.692 49.063-48.039 114.777-50.621 148.814-50.42 50.421 0.289 138.04 22.35 211.812 48.439 20.436-43.52 33.547-90.068 42.007-121.1H305.308v-33.168h157.518v-66.337H272.139v-33.169h190.687v-66.315c0-9.105 1.803-16.584 16.584-16.584h74.619v82.899h207.293v33.169H554.029v66.337h165.82s-16.65 92.828-68.719 184.32c115.557 41.272 278.128 104.849 332.133 126.086z"
        p-id="9946"
      />
    </svg>`;

  var arrowDownIcon = `<svg
    t="1739882271546"
    class="icon"
    viewBox="0 0 1024 1024"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
    p-id="4346"
    width="200"
    height="200"
  >
    <path
      fill="currentColor"
      d="M959.429379 343.214852 890.590548 274.378068 511.268336 653.699256 131.944078 274.378068 63.105247 343.214852 501.1857 781.294282 521.348925 781.294282Z"
      p-id="4347"
    ></path>
  </svg>`;

  var categoryIcon = `<svg
    t="1738937526967"
    class="icon"
    viewBox="0 0 1024 1024"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
    p-id="6716"
    width="200"
    height="200"
  >
    <path
      d="M918.673 883H104.327C82.578 883 65 867.368 65 848.027V276.973C65 257.632 82.578 242 104.327 242h814.346C940.422 242 958 257.632 958 276.973v571.054C958 867.28 940.323 883 918.673 883z"
      fill="#FFE9B4"
      p-id="6717"
    ></path>
    <path
      d="M512 411H65V210.37C65 188.597 82.598 171 104.371 171h305.92c17.4 0 32.71 11.334 37.681 28.036L512 411z"
      fill="#FFB02C"
      p-id="6718"
    ></path>
    <path
      d="M918.673 883H104.327C82.578 883 65 865.42 65 843.668V335.332C65 313.58 82.578 296 104.327 296h814.346C940.422 296 958 313.58 958 335.332v508.336C958 865.32 940.323 883 918.673 883z"
      fill="#FFCA28"
      p-id="6719"
    ></path>
  </svg>`;

  var closeIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
    ></path>
  </svg>`;

  var copyrightIcon = `<svg
    t="1695543755857"
    class="icon"
    viewBox="0 0 1024 1024"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
    p-id="89399"
    width="200"
    height="200"
  >
    <path
      fill="currentColor"
      d="M512 16C238.066 16 16 238.066 16 512s222.066 496 496 496 496-222.066 496-496S785.934 16 512 16z m234.268 693.506c-3.184 3.734-79.552 91.462-219.702 91.462-169.384 0-288.968-126.52-288.968-291.134 0-162.606 124.008-286.802 287.524-286.802 133.914 0 203.93 74.63 206.844 77.808a24 24 0 0 1 2.476 29.246l-44.76 69.31c-8.098 12.534-25.548 14.702-36.468 4.59-0.466-0.428-53.058-47.76-123.76-47.76-92.232 0-147.832 67.15-147.832 152.164 0 79.204 51.028 159.384 148.554 159.384 77.394 0 130.56-56.676 131.088-57.25 10.264-11.13 28.118-10.066 37.016 2.106l49.094 67.144a24.002 24.002 0 0 1-1.106 29.732z"
      p-id="89400"
    />
  </svg>`;

  var docAnalysisIcon = `<svg
    t="1738938044985"
    class="icon"
    viewBox="0 0 1024 1024"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
    p-id="20199"
    width="200"
    height="200"
  >
    <path d="M896 42.666667h-128l-170.666667 213.333333h128z" fill="#FF4C4C" p-id="20200"></path>
    <path d="M768 42.666667h-128l-170.666667 213.333333h128z" fill="#3B8CFF" p-id="20201"></path>
    <path d="M640 42.666667h-128L341.333333 256h128z" fill="#F1F1F1" p-id="20202"></path>
    <path d="M128 42.666667h128l170.666667 213.333333H298.666667z" fill="#FF4C4C" p-id="20203"></path>
    <path d="M256 42.666667h128l170.666667 213.333333h-128z" fill="#3B8CFF" p-id="20204"></path>
    <path d="M384 42.666667h128l170.666667 213.333333h-128z" fill="#FBFBFB" p-id="20205"></path>
    <path d="M298.666667 256h426.666666v213.333333H298.666667z" fill="#E3A815" p-id="20206"></path>
    <path d="M512 661.333333m-320 0a320 320 0 1 0 640 0 320 320 0 1 0-640 0Z" fill="#FDDC3A" p-id="20207"></path>
    <path d="M512 661.333333m-256 0a256 256 0 1 0 512 0 256 256 0 1 0-512 0Z" fill="#E3A815" p-id="20208"></path>
    <path
      d="M512 661.333333m-213.333333 0a213.333333 213.333333 0 1 0 426.666666 0 213.333333 213.333333 0 1 0-426.666666 0Z"
      fill="#F5CF41"
      p-id="20209"
    ></path>
    <path
      d="M277.333333 256h469.333334a21.333333 21.333333 0 0 1 0 42.666667h-469.333334a21.333333 21.333333 0 0 1 0-42.666667z"
      fill="#D19A0E"
      p-id="20210"
    ></path>
    <path
      d="M277.333333 264.533333a12.8 12.8 0 1 0 0 25.6h469.333334a12.8 12.8 0 1 0 0-25.6h-469.333334z m0-17.066666h469.333334a29.866667 29.866667 0 1 1 0 59.733333h-469.333334a29.866667 29.866667 0 1 1 0-59.733333z"
      fill="#F9D525"
      p-id="20211"
    ></path>
    <path
      d="M512 746.666667l-100.309333 52.736 19.157333-111.701334-81.152-79.104 112.128-16.298666L512 490.666667l50.176 101.632 112.128 16.298666-81.152 79.104 19.157333 111.701334z"
      fill="#FFF2A0"
      p-id="20212"
    ></path>
  </svg>`;

  var emptyIcon = `<svg
      t="1742486057552"
      class="icon"
      viewBox="0 0 1024 1024"
      version="1.1"
      xmlns="http://www.w3.org/2000/svg"
      p-id="1713"
      width="200"
      height="200"
    >
      <path
        d="M956 634.8L803.3 458.4c-5-7.2-12.9-11.1-22.3-11.1H243c-9.4 0-17.3 3.9-21.4 10L71 629.3l-4.1 5.8v1.9c-1.1 2.4-1.9 5.5-1.9 9.2v285c0 17.1 10.9 27.8 28.5 27.8h837c17.6 0 28.5-10.7 28.5-27.8v-285c0-4.9-1.3-8.6-3-11.4z m-324.4-16.5c-17.3 0-28.5 10.9-28.5 27.8 0 23.7-8.7 43.5-26.6 60.6-18.1 17.3-39.2 25.7-64.5 25.7s-46.4-8.4-64.4-25.6c-17.9-17.1-26.6-36.9-26.6-60.6 0-16.9-11.2-27.8-28.5-27.8H155.2L256.6 503h510.9l101.4 115.4H631.6z m-20.2 133.4c24.8-21.4 40.5-47.5 46.6-77.8h244v229.4H122V674h244c6.1 30.3 21.8 56.4 46.6 77.8C440.5 775.9 474 788 512 788s71.6-12.2 99.4-36.3zM96.3 317.1l100.3 56.3c5.1 2.9 10.9 4.4 16.8 4.4 11.7 0 22.8-6.1 28.8-15.8 4.7-7.5 6-16.3 3.8-24.8-2.2-8.6-7.8-15.8-15.8-20.3l-100.3-56.3c-15.8-8.9-36.3-3.7-45.6 11.5-4.6 7.5-6 16.3-3.8 24.8 2.3 8.5 7.9 15.7 15.8 20.2zM508.6 377.7h0.5c18.1 0 33.2-14.3 33.6-31.9l5.9-247.4c0.2-8.5-2.9-16.7-8.9-23-6.2-6.6-14.7-10.3-25.8-10.4-18.5 2.1-32.1 15.5-32.5 31.8l-5.9 247.4c-0.2 8.6 3 16.7 8.9 23 6.2 6.6 14.7 10.3 24.2 10.5zM330.3 312.9c5.3 12.1 17.4 19.8 30.9 19.8 4.3 0 8.8-0.9 12.8-2.5 8.5-3.4 15-9.8 18.4-18.1 3.3-8.1 3.2-17-0.3-25L345 180.3c-7.2-16.5-26.9-24.2-43.7-17.3-8.5 3.4-15 9.9-18.4 18.2-3.3 8.1-3.1 16.9 0.4 24.9l47 106.8zM810.6 377.7c5.9 0 11.7-1.5 16.8-4.4L927.7 317c7.9-4.5 13.5-11.7 15.7-20.3 2.2-8.5 0.8-17.3-3.8-24.7-9.5-15.4-29.5-20.5-45.6-11.5l-100.3 56.3c-7.9 4.5-13.5 11.7-15.7 20.3-2.2 8.5-0.8 17.3 3.8 24.7 6 9.9 17 15.9 28.8 15.9zM649.9 330.2c4.1 1.7 8.5 2.5 12.9 2.5 13.5 0 25.6-7.8 30.9-19.8L740.8 206c3.5-8 3.6-16.8 0.3-24.9-3.4-8.3-9.9-14.7-18.4-18.1-16.8-6.8-36.5 0.9-43.7 17.3l-47.2 106.9c-3.5 8-3.6 16.9-0.3 25 3.5 8.2 10 14.7 18.4 18z"
        p-id="1714"
      ></path>
    </svg>`;

  var friendLinkIcon = `<svg width="512" height="512" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg">
  <path
    fill="#EF9645"
    d="M16.428 30.331a2.31 2.31 0 0 0 3.217-.568a.798.798 0 0 0-.197-1.114l-1.85-1.949l4.222 2.955a1.497 1.497 0 0 0 2.089-.369a1.5 1.5 0 0 0-.369-2.089l-3.596-3.305l5.375 3.763a1.497 1.497 0 0 0 2.089-.369a1.5 1.5 0 0 0-.369-2.089l-4.766-4.073l5.864 4.105a1.497 1.497 0 0 0 2.089-.369a1.5 1.5 0 0 0-.369-2.089L4.733 11.194l-3.467 5.521c-.389.6-.283 1.413.276 1.891l7.786 6.671c.355.304.724.591 1.107.859l5.993 4.195z"
  />
  <path
    fill="#FFDC5D"
    d="M29.802 21.752L18.5 13.601l-.059-.08l.053-.08l.053-.053l.854.469c.958.62 3.147 1.536 4.806 1.536c1.135 0 1.815-.425 2.018-1.257a1.409 1.409 0 0 0-1.152-1.622a6.788 6.788 0 0 1-2.801-1.091l-.555-.373c-.624-.421-1.331-.898-1.853-1.206c-.65-.394-1.357-.585-2.163-.585c-1.196 0-2.411.422-3.585.83l-1.266.436a5.18 5.18 0 0 1-1.696.271c-1.544 0-3.055-.586-4.516-1.152l-.147-.058a1.389 1.389 0 0 0-1.674.56L1.35 15.669a1.357 1.357 0 0 0 .257 1.761l7.785 6.672c.352.301.722.588 1.1.852l6.165 4.316a2 2 0 0 0 2.786-.491a.803.803 0 0 0-.196-1.115l-1.833-1.283a.424.424 0 0 1-.082-.618a.422.422 0 0 1 .567-.075l3.979 2.785a1.4 1.4 0 0 0 1.606-2.294l-3.724-2.606a.424.424 0 0 1-.082-.618a.423.423 0 0 1 .567-.075l5.132 3.593a1.4 1.4 0 0 0 1.606-2.294l-4.868-3.407a.42.42 0 0 1-.081-.618a.377.377 0 0 1 .506-.066l5.656 3.959a1.4 1.4 0 0 0 1.606-2.295z"
  />
  <path
    fill="#EF9645"
    d="M16.536 27.929c-.07.267-.207.498-.389.681l-1.004.996a1.494 1.494 0 0 1-1.437.396a1.5 1.5 0 0 1-.683-2.512l1.004-.996a1.494 1.494 0 0 1 1.437-.396a1.502 1.502 0 0 1 1.072 1.831zM5.992 23.008l1.503-1.497a1.5 1.5 0 0 0-.444-2.429a1.495 1.495 0 0 0-1.674.31l-1.503 1.497a1.5 1.5 0 0 0 .445 2.429a1.496 1.496 0 0 0 1.673-.31zm5.204.052a1.5 1.5 0 1 0-2.122-2.118L6.072 23.94a1.5 1.5 0 1 0 2.122 2.118l3.002-2.998zm2.25 3a1.5 1.5 0 0 0-.945-2.555a1.489 1.489 0 0 0-1.173.44L9.323 25.94a1.5 1.5 0 0 0 .945 2.556c.455.036.874-.141 1.173-.44l2.005-1.996zm16.555-4.137l.627-.542l-6.913-10.85l-12.27 1.985a1.507 1.507 0 0 0-1.235 1.737c.658 2.695 6.003.693 8.355-.601l11.436 8.271z"
  />
  <path
    fill="#FFCC4D"
    d="M16.536 26.929c-.07.267-.207.498-.389.681l-1.004.996a1.494 1.494 0 0 1-1.437.396a1.5 1.5 0 0 1-.683-2.512l1.004-.996a1.494 1.494 0 0 1 1.437-.396a1.502 1.502 0 0 1 1.072 1.831zM5.992 22.008l1.503-1.497a1.5 1.5 0 0 0-.444-2.429a1.497 1.497 0 0 0-1.674.31l-1.503 1.497a1.5 1.5 0 0 0 .445 2.429a1.496 1.496 0 0 0 1.673-.31zm5.204.052a1.5 1.5 0 1 0-2.122-2.118L6.072 22.94a1.5 1.5 0 1 0 2.122 2.118l3.002-2.998zm2.25 3a1.5 1.5 0 0 0-.945-2.555a1.489 1.489 0 0 0-1.173.44L9.323 24.94a1.5 1.5 0 0 0 .945 2.556c.455.036.874-.141 1.173-.44l2.005-1.996zm21.557-7.456a1.45 1.45 0 0 0 .269-1.885l-.003-.005l-3.467-6.521a1.488 1.488 0 0 0-1.794-.6c-1.992.771-4.174 1.657-6.292.937l-1.098-.377c-1.948-.675-4.066-1.466-6-.294c-.695.409-1.738 1.133-2.411 1.58a6.873 6.873 0 0 1-2.762 1.076a1.502 1.502 0 0 0-1.235 1.737c.613 2.512 5.3.908 7.838-.369a.968.968 0 0 1 1.002.081l11.584 8.416l4.369-3.776z"
  />
  </svg>`;

  var icpRecordIcon = `<svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>ICP\u5907\u6848\u53F7</title>
    <path
      d="M778.24 163.84c-76.8-40.96-165.888-61.44-269.312-61.44s-192.512 20.48-269.312 61.44h-133.12l23.552 337.92c8.192 113.664 67.584 217.088 162.816 280.576l215.04 144.384 215.04-144.384c96.256-63.488 155.648-166.912 163.84-280.576l23.552-337.92H778.24z m47.104 333.824c-7.168 94.208-56.32 181.248-135.168 233.472l-181.248 120.832L327.68 731.136c-78.848-53.248-129.024-139.264-135.168-233.472L173.056 225.28h136.192v-26.624c58.368-23.552 124.928-34.816 199.68-34.816s141.312 12.288 199.68 34.816V225.28H844.8l-19.456 272.384z"
    ></path>
    <path
      d="M685.056 328.704v-46.08H455.68c2.048-4.096 6.144-9.216 11.264-15.36 5.12-7.168 9.216-12.288 11.264-15.36L419.84 240.64c-31.744 46.08-75.776 87.04-133.12 123.904 4.096 4.096 10.24 11.264 18.432 21.504l17.408 17.408c23.552-15.36 45.056-31.744 63.488-50.176 26.624 25.6 49.152 43.008 67.584 51.2-46.08 15.36-104.448 27.648-175.104 35.84 2.048 5.12 6.144 13.312 9.216 24.576 4.096 11.264 6.144 19.456 7.168 24.576l39.936-7.168v218.112H389.12V680.96h238.592v19.456h54.272V481.28H348.16c60.416-12.288 114.688-27.648 163.84-46.08 49.152 19.456 118.784 34.816 210.944 46.08 5.12-17.408 10.24-34.816 17.408-51.2-62.464-4.096-116.736-12.288-161.792-24.576 38.912-20.48 74.752-46.08 106.496-76.8z m-150.528 194.56h94.208v41.984h-94.208v-41.984z m0 78.848h94.208v41.984h-94.208v-41.984z m-144.384-78.848h94.208v41.984H390.144v-41.984z m0 78.848h94.208v41.984H390.144v-41.984zM424.96 326.656h182.272c-26.624 22.528-57.344 41.984-94.208 57.344-31.744-15.36-61.44-34.816-88.064-57.344z"
    ></path>
  </svg>`;

  var noticeIcon = `<svg
    t="1716085184855"
    viewBox="0 0 1024 1024"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
    p-id="4274"
    width="200"
    height="200"
  >
    <path
      fill="currentColor"
      d="M660.48 872.448q6.144 0-3.584 15.36t-29.696 33.792-47.104 33.792-57.856 15.36q-27.648 0-53.248-15.36t-45.056-33.792-29.696-33.792-6.144-15.36l272.384 0zM914.432 785.408q7.168 9.216 6.656 17.92t-4.608 14.848-10.24 9.728-12.288 3.584l-747.52 0q-14.336 0-20.992-11.776t4.608-29.184q17.408-30.72 40.96-68.608t44.544-81.408 36.352-92.16 15.36-101.888q0-51.2 14.336-92.16t37.376-71.68 53.248-52.224 62.976-32.768q-16.384-26.624-16.384-55.296 0-41.984 28.672-70.656t70.656-28.672 70.656 28.672 28.672 70.656q0 14.336-4.096 28.16t-11.264 25.088q34.816 11.264 66.048 32.768t54.272 53.248 36.864 72.704 13.824 91.136q0 51.2 15.36 100.864t36.864 94.208 45.568 81.408 43.52 63.488zM478.208 142.336q0 16.384 11.264 28.16t27.648 11.776l2.048 0q16.384-1.024 27.648-12.288t11.264-27.648q0-17.408-11.264-28.672t-28.672-11.264-28.672 11.264-11.264 28.672z"
      p-id="4275"
    />
  </svg>`;

  var playgroundIcon = `<svg viewBox="0 0 24 24" width="1.2em" height="1.2em">
    <path
      fill="currentColor"
      d="M16 2v2h-1v3.243c0 1.158.251 2.301.736 3.352l4.282 9.276A1.5 1.5 0 0 1 18.656 22H5.344a1.5 1.5 0 0 1-1.362-2.129l4.282-9.276A7.994 7.994 0 0 0 9 7.243V4H8V2h8zm-2.612 8.001h-2.776c-.104.363-.23.721-.374 1.071l-.158.361L6.125 20h11.749l-3.954-8.567a9.978 9.978 0 0 1-.532-1.432zM11 7.243c0 .253-.01.506-.029.758h2.058a8.777 8.777 0 0 1-.021-.364L13 7.243V4h-2v3.243z"
    ></path>
  </svg>`;

  var rocketIcon = `<svg
    t="1741888593841"
    class="icon"
    viewBox="0 0 1024 1024"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
    p-id="9313"
    width="200"
    height="200"
  >
    <path
      fill="currentColor"
      d="M760.789 439.887C764.394 155.042 530.029 25.24 512 14.423c-14.423 7.21-252.394 137.014-248.789 425.464-46.873 32.451-97.352 86.536-90.14 180.282 7.21 93.746 100.957 158.648 137.014 155.042 36.056-3.605 25.239-28.845 25.239-28.845l10.817-50.479s54.084 79.324 68.507 79.324h194.704c18.028 0 68.507-79.324 68.507-79.324l10.817 50.48s-10.817 25.239 25.24 28.844c36.056 3.606 129.802-61.296 137.014-155.042 7.21-93.746-43.268-147.831-90.141-180.282zM512 436.282c-7.211 0-93.746-3.606-104.563-104.564C411.042 234.366 504.789 227.155 512 223.55c7.211 0 100.958 10.817 104.563 108.17C605.746 432.675 519.211 436.281 512 436.281z m-54.085 493.972c0 10.816-10.816 21.633-21.633 21.633-10.817 0-21.634-10.817-21.634-21.633V825.69c0-10.817 10.817-21.634 21.634-21.634s21.633 10.817 21.633 21.634v104.564z m79.325 54.084c0 10.817-10.817 21.634-21.634 21.634s-21.634-10.817-21.634-21.634V829.296c0-10.817 10.817-21.634 21.634-21.634s21.633 10.817 21.633 21.634v155.042z m72.112-79.324c0 10.817-10.817 21.634-21.634 21.634s-21.633-10.817-21.633-21.634v-75.718c0-10.817 10.816-21.634 21.633-21.634 10.817 0 21.634 10.817 21.634 21.634v75.718z m0 0"
      p-id="9314"
    ></path>
  </svg>`;

  var size = `<svg
    t="1739366297687"
    class="icon"
    viewBox="0 0 1024 1024"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
    p-id="8454"
    width="200"
    height="200"
  >
    <path
      fill="currentColor"
      d="M920 416H616c-4.4 0-8 3.6-8 8v112c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-56h60v320h-46c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h164c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8h-46V480h60v56c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V424c0-4.4-3.6-8-8-8z"
      p-id="8455"
    ></path>
    <path
      fill="currentColor"
      d="M656 296V168c0-4.4-3.6-8-8-8H104c-4.4 0-8 3.6-8 8v128c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-64h168v560h-92c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h264c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8h-92V232h168v64c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8z"
      p-id="8456"
    ></path>
  </svg>`;

  var tagIcon = `<svg
  t="1695048840129" class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" p-id="4290" width="200" height="200"
  >
  <path
    d="M810.88 245.888a118.432 118.432 0 1 0 0 236.864 118.432 118.432 0 0 0 0-236.864z m-151.008 118.432a151.008 151.008 0 1 1 302.016 0 151.008 151.008 0 0 1-302.016 0z"
    fill="#D3D3D3" p-id="4291"
  />
  <path
    d="M774.08 565.6l61.76-160.64c6.4-16.64 2.56-35.84-10.24-48.64l-151.04-151.04c-12.8-12.8-31.68-16.64-48.64-10.24l-160.64 61.76c-12.16 4.8-23.36 11.84-32.64 21.12l-355.2 355.2c-17.92 17.92-17.92 46.72 0 64.32l256 256c17.92 17.92 46.72 17.92 64.32 0l355.2-355.2c9.28-9.28 16.32-20.16 21.12-32.64z m-159.36-149.12c-22.08-22.08-22.08-57.6 0-79.68 22.08-22.08 57.6-22.08 79.68 0 22.08 22.08 22.08 57.6 0 79.68-22.08 21.76-57.92 21.76-79.68 0z"
    fill="#FCD53F" p-id="4292"
  />
  <path
    d="M654.4 320.48c14.4 0 28.8 5.44 39.68 16.64 22.08 22.08 22.08 57.6 0 79.68-10.88 10.88-25.28 16.64-39.68 16.64-14.4 0-28.8-5.44-39.68-16.64-22.08-22.08-22.08-57.6 0-79.68 10.88-11.2 25.28-16.64 39.68-16.64z m0-30.08c-23.04 0-44.8 8.96-61.12 25.28a86.72 86.72 0 0 0 0 122.24c16.32 16.32 38.08 25.28 61.12 25.28s44.8-8.96 61.12-25.28a86.72 86.72 0 0 0 0-122.24c-16.32-16.32-38.08-25.28-61.12-25.28z"
    fill="#F8312F" p-id="4293"
  />
  <path
    d="M676.16 348.032c8.992 0 16.288 7.296 16.288 16.288a118.144 118.144 0 0 0 64.288 105.44h0.064c22.24 11.296 47.36 15.264 71.68 11.84a16.288 16.288 0 0 1 4.48 32.32 154.24 154.24 0 0 1-90.848-15.04 150.72 150.72 0 0 1-82.24-134.56c0-8.992 7.296-16.288 16.288-16.288z"
    fill="#D3D3D3" p-id="4294"
  />
  </svg>`;

  var themeIcon = `<svg width="128" height="128" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
  <title>\u4E3B\u9898</title>
  <path d="M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10a2.5 2.5 0 0 0 2.5-2.5c0-.61-.23-1.2-.64-1.67a.528.528 0 0 1-.13-.33c0-.28.22-.5.5-.5H16c3.31 0 6-2.69 6-6c0-4.96-4.49-9-10-9zm5.5 11c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5zm-3-4c-.83 0-1.5-.67-1.5-1.5S13.67 6 14.5 6s1.5.67 1.5 1.5S15.33 9 14.5 9zM5 11.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5S7.33 13 6.5 13S5 12.33 5 11.5zm6-4c0 .83-.67 1.5-1.5 1.5S8 8.33 8 7.5S8.67 6 9.5 6s1.5.67 1.5 1.5z"/>
  </svg>`;

  var topArticleIcon = `<svg viewBox="0 0 128 128" xmlns="http://www.w3.org/2000/svg">
    <radialGradient id="notoFire0" cx="68.884" cy="124.296" r="70.587" gradientTransform="matrix(-1 -.00434 -.00713 1.6408 131.986 -79.345)" gradientUnits="userSpaceOnUse">
        <stop offset=".314" stop-color="#FF9800"/>
        <stop offset=".662" stop-color="#FF6D00"/>
        <stop offset=".972" stop-color="#F44336"/>
    </radialGradient>
    <path fill="url(#notoFire0)" d="M35.56 40.73c-.57 6.08-.97 16.84 2.62 21.42c0 0-1.69-11.82 13.46-26.65c6.1-5.97 7.51-14.09 5.38-20.18c-1.21-3.45-3.42-6.3-5.34-8.29c-1.12-1.17-.26-3.1 1.37-3.03c9.86.44 25.84 3.18 32.63 20.22c2.98 7.48 3.2 15.21 1.78 23.07c-.9 5.02-4.1 16.18 3.2 17.55c5.21.98 7.73-3.16 8.86-6.14c.47-1.24 2.1-1.55 2.98-.56c8.8 10.01 9.55 21.8 7.73 31.95c-3.52 19.62-23.39 33.9-43.13 33.9c-24.66 0-44.29-14.11-49.38-39.65c-2.05-10.31-1.01-30.71 14.89-45.11c1.18-1.08 3.11-.12 2.95 1.5z"/>
    <radialGradient id="notoFire1" cx="64.921" cy="54.062" r="73.86" gradientTransform="matrix(-.0101 .9999 .7525 .0076 26.154 -11.267)" gradientUnits="userSpaceOnUse">
        <stop offset=".214" stop-color="#FFF176"/>
        <stop offset=".328" stop-color="#FFF27D"/>
        <stop offset=".487" stop-color="#FFF48F"/>
        <stop offset=".672" stop-color="#FFF7AD"/>
        <stop offset=".793" stop-color="#FFF9C4"/>
        <stop offset=".822" stop-color="#FFF8BD" stop-opacity=".804"/>
        <stop offset=".863" stop-color="#FFF6AB" stop-opacity=".529"/>
        <stop offset=".91" stop-color="#FFF38D" stop-opacity=".209"/>
        <stop offset=".941" stop-color="#FFF176" stop-opacity="0"/>
    </radialGradient>
    <path fill="url(#notoFire1)" d="M76.11 77.42c-9.09-11.7-5.02-25.05-2.79-30.37c.3-.7-.5-1.36-1.13-.93c-3.91 2.66-11.92 8.92-15.65 17.73c-5.05 11.91-4.69 17.74-1.7 24.86c1.8 4.29-.29 5.2-1.34 5.36c-1.02.16-1.96-.52-2.71-1.23a16.09 16.09 0 0 1-4.44-7.6c-.16-.62-.97-.79-1.34-.28c-2.8 3.87-4.25 10.08-4.32 14.47C40.47 113 51.68 124 65.24 124c17.09 0 29.54-18.9 19.72-34.7c-2.85-4.6-5.53-7.61-8.85-11.88z"/>
    </svg>`;

  var readingIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="m512 863.36 384-54.848v-638.72L525.568 222.72a96 96 0 0 1-27.136 0L128 169.792v638.72zM137.024 106.432l370.432 52.928a32 32 0 0 0 9.088 0l370.432-52.928A64 64 0 0 1 960 169.792v638.72a64 64 0 0 1-54.976 63.36l-388.48 55.488a32 32 0 0 1-9.088 0l-388.48-55.488A64 64 0 0 1 64 808.512v-638.72a64 64 0 0 1 73.024-63.36z"
    ></path>
    <path fill="currentColor" d="M480 192h64v704h-64z"></path>
  </svg>`;

  var clockIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
    ></path>
    <path fill="currentColor" d="M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"></path>
    <path fill="currentColor" d="M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32"></path>
  </svg>`;

  var viewIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
    ></path>
  </svg>`;

  var houseIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M192 413.952V896h640V413.952L512 147.328zM139.52 374.4l352-293.312a32 32 0 0 1 40.96 0l352 293.312A32 32 0 0 1 896 398.976V928a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V398.976a32 32 0 0 1 11.52-24.576"
    ></path>
  </svg>`;

  var arrowLeftIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
    ></path>
  </svg>`;

  var arrowRightIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
    ></path>
  </svg>`;

  var magicIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M512 64h64v192h-64zm0 576h64v192h-64zM160 480v-64h192v64zm576 0v-64h192v64zM249.856 199.04l45.248-45.184L430.848 289.6 385.6 334.848 249.856 199.104zM657.152 606.4l45.248-45.248 135.744 135.744-45.248 45.248zM114.048 923.2 68.8 877.952l316.8-316.8 45.248 45.248zM702.4 334.848 657.152 289.6l135.744-135.744 45.248 45.248z"
    ></path>
  </svg>`;

  var commentIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M273.536 736H800a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64H224a64 64 0 0 0-64 64v570.88zM296 800 147.968 918.4A32 32 0 0 1 96 893.44V256a128 128 0 0 1 128-128h576a128 128 0 0 1 128 128v416a128 128 0 0 1-128 128z"
    ></path>
    <path
      fill="currentColor"
      d="M512 499.2a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4zm192 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4zm-384 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4z"
    ></path>
  </svg>`;

  var userIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
  <path
    fill="currentColor"
    d="M512 512a192 192 0 1 0 0-384 192 192 0 0 0 0 384m0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512m320 320v-96a96 96 0 0 0-96-96H288a96 96 0 0 0-96 96v96a32 32 0 1 1-64 0v-96a160 160 0 0 1 160-160h448a160 160 0 0 1 160 160v96a32 32 0 1 1-64 0"
  ></path>
</svg>`;

  var calendarIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
  <path
    fill="currentColor"
    d="M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64"
  ></path>
</svg>`;

  var folderOpenedIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M878.08 448H241.92l-96 384h636.16l96-384zM832 384v-64H485.76L357.504 192H128v448l57.92-231.744A32 32 0 0 1 216.96 384zm-24.96 512H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h287.872l128.384 128H864a32 32 0 0 1 32 32v96h23.04a32 32 0 0 1 31.04 39.744l-112 448A32 32 0 0 1 807.04 896"
    ></path>
  </svg>`;

  var collectionTagIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M256 128v698.88l196.032-156.864a96 96 0 0 1 119.936 0L768 826.816V128zm-32-64h576a32 32 0 0 1 32 32v797.44a32 32 0 0 1-51.968 24.96L531.968 720a32 32 0 0 0-39.936 0L243.968 918.4A32 32 0 0 1 192 893.44V96a32 32 0 0 1 32-32"
    ></path>
  </svg>`;

  var editPenIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="m199.04 672.64 193.984 112 224-387.968-193.92-112-224 388.032zm-23.872 60.16 32.896 148.288 144.896-45.696zM455.04 229.248l193.92 112 56.704-98.112-193.984-112-56.64 98.112zM104.32 708.8l384-665.024 304.768 175.936L409.152 884.8h.064l-248.448 78.336zm384 254.272v-64h448v64h-448z"
    ></path>
  </svg>`;

  var githubIcon = `<svg viewBox="0 0 24 24" width="1.2em" height="1.2em">
    <path
      fill="currentColor"
      d="M5.883 18.653c-.3-.2-.558-.455-.86-.816a50.32 50.32 0 0 1-.466-.579c-.463-.575-.755-.84-1.057-.949a1 1 0 0 1 .676-1.883c.752.27 1.261.735 1.947 1.588c-.094-.117.34.427.433.539c.19.227.33.365.44.438c.204.137.587.196 1.15.14c.023-.382.094-.753.202-1.095C5.38 15.31 3.7 13.396 3.7 9.64c0-1.24.37-2.356 1.058-3.292c-.218-.894-.185-1.975.302-3.192a1 1 0 0 1 .63-.582c.081-.024.127-.035.208-.047c.803-.123 1.937.17 3.415 1.096A11.731 11.731 0 0 1 12 3.315c.912 0 1.818.104 2.684.308c1.477-.933 2.613-1.226 3.422-1.096c.085.013.157.03.218.05a1 1 0 0 1 .616.58c.487 1.216.52 2.297.302 3.19c.691.936 1.058 2.045 1.058 3.293c0 3.757-1.674 5.665-4.642 6.392c.125.415.19.879.19 1.38a300.492 300.492 0 0 1-.012 2.716a1 1 0 0 1-.019 1.958c-1.139.228-1.983-.532-1.983-1.525l.002-.446l.005-.705c.005-.708.007-1.338.007-1.998c0-.697-.183-1.152-.425-1.36c-.661-.57-.326-1.655.54-1.752c2.967-.333 4.337-1.482 4.337-4.66c0-.955-.312-1.744-.913-2.404a1 1 0 0 1-.19-1.045c.166-.414.237-.957.096-1.614l-.01.003c-.491.139-1.11.44-1.858.949a1 1 0 0 1-.833.135A9.626 9.626 0 0 0 12 5.315c-.89 0-1.772.119-2.592.35a1 1 0 0 1-.83-.134c-.752-.507-1.374-.807-1.868-.947c-.144.653-.073 1.194.092 1.607a1 1 0 0 1-.189 1.045C6.016 7.89 5.7 8.694 5.7 9.64c0 3.172 1.371 4.328 4.322 4.66c.865.097 1.201 1.177.544 1.748c-.192.168-.429.732-.429 1.364v3.15c0 .986-.835 1.725-1.96 1.528a1 1 0 0 1-.04-1.962v-.99c-.91.061-1.662-.088-2.254-.485z"
    ></path>
  </svg>`;

  var copyIcon = `<svg viewBox="0 0 24 24" width="1.2em" height="1.2em">
    <path
      fill="currentColor"
      d="M7 6V3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1h-3v3c0 .552-.45 1-1.007 1H4.007A1.001 1.001 0 0 1 3 21l.003-14c0-.552.45-1 1.007-1H7zM5.003 8L5 20h10V8H5.003zM9 6h8v10h2V4H9v2z"
    ></path>
  </svg>`;

  var codeIcon = `<svg viewBox="0 0 24 24" width="1.2em" height="1.2em">
    <path
      fill="currentColor"
      d="m23 12l-7.071 7.071l-1.414-1.414L20.172 12l-5.657-5.657l1.414-1.414L23 12zM3.828 12l5.657 5.657l-1.414 1.414L1 12l7.071-7.071l1.414 1.414L3.828 12z"
    ></path>
  </svg>`;

  var caretTopIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path fill="currentColor" d="M512 320 192 704h639.936z"></path>
  </svg>`;

  var weChatPayIcon = `<svg
      t="1711730357270"
      class="icon"
      viewBox="0 0 1024 1024"
      version="1.1"
      xmlns="http://www.w3.org/2000/svg"
      p-id="4392"
      width="16"
      height="16"
    >
      <path
        fill="currentColor"
        d="M512 1024a512 512 0 1 1 512-512 512 512 0 0 1-512 512z m-112.523636-836.538182c-144.989091 0-262.516364 100.538182-262.516364 224.465455 0 74.007273 42.123636 139.636364 106.705455 180.363636l-19.549091 78.312727 86.807272-47.592727a301.265455 301.265455 0 0 0 88.669091 13.381818h2.210909a178.967273 178.967273 0 0 1-3.607272-34.909091c0-115.083636 109.498182-208.407273 244.363636-208.407272 6.167273 0 11.636364 0 18.152727 0.814545-10.589091-115.665455-123.461818-206.778182-261.469091-206.778182z m246.690909 226.443637c-124.741818 0-225.861818 86.109091-225.861818 192.465454s101.003636 192.349091 225.861818 192.349091a257.047273 257.047273 0 0 0 99.723636-20.014545l77.265455 40.610909L802.909091 744.727273a179.316364 179.316364 0 0 0 69.003636-138.24c0-106.24-101.12-192.465455-225.861818-192.465455z m81.454545 152.087272a31.767273 31.767273 0 1 1 32.349091-31.767272 32 32 0 0 1-32.349091 31.767272z m-164.072727 0a31.767273 31.767273 0 1 1 32.349091-31.767272 32 32 0 0 1-32.349091 31.767272zM502.341818 373.527273a34.909091 34.909091 0 1 1 34.909091-34.909091 34.909091 34.909091 0 0 1-34.909091 34.909091z m-206.196363 0a34.909091 34.909091 0 1 1 34.90909-34.909091 34.909091 34.909091 0 0 1-34.90909 34.909091z m0 0"
        p-id="4393"
      />
    </svg>`;

  var shareIcon = `<svg
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    aria-hidden="true"
    role="img"
    class="iconify iconify iconify--solar"
    alt="Icon"
    width="1em"
    height="1em"
    viewBox="0 0 24 24"
    style="vertical-align: -0.125em"
  >
    <path
      fill="currentColor"
      fill-rule="evenodd"
      d="M13.803 5.333c0-1.84 1.5-3.333 3.348-3.333A3.34 3.34 0 0 1 20.5 5.333c0 1.841-1.5 3.334-3.349 3.334a3.35 3.35 0 0 1-2.384-.994l-4.635 3.156a3.34 3.34 0 0 1-.182 1.917l5.082 3.34a3.35 3.35 0 0 1 2.12-.753a3.34 3.34 0 0 1 3.348 3.334C20.5 20.507 19 22 17.151 22a3.34 3.34 0 0 1-3.348-3.333a3.3 3.3 0 0 1 .289-1.356L9.05 14a3.35 3.35 0 0 1-2.202.821A3.34 3.34 0 0 1 3.5 11.487a3.34 3.34 0 0 1 3.348-3.333c1.064 0 2.01.493 2.623 1.261l4.493-3.059a3.3 3.3 0 0 1-.161-1.023"
      clip-rule="evenodd"
    ></path>
  </svg>`;

  var thumbsIcon = `<svg
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    aria-hidden="true"
    role="img"
    class="iconify iconify iconify--mdi"
    alt="Icon"
    width="1em"
    height="1em"
    viewBox="0 0 24 24"
    style="vertical-align: -0.125em"
  >
    <path
      fill="currentColor"
      d="M23 10a2 2 0 0 0-2-2h-6.32l.96-4.57c.02-.1.03-.21.03-.32c0-.41-.17-.79-.44-1.06L14.17 1L7.59 7.58C7.22 7.95 7 8.45 7 9v10a2 2 0 0 0 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73zM1 21h4V9H1z"
    ></path>
  </svg>`;

  var externalLinkIcon = `<svg
    t="1743866145262"
    class="icon"
    viewBox="0 0 1024 1024"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
    p-id="2634"
    width="200"
    height="200"
  >
    <path
      fill="currentColor"
      d="M426.666667 256v85.333333H213.333333v469.333334h469.333334v-213.333334h85.333333v256a42.666667 42.666667 0 0 1-42.666667 42.666667H170.666667a42.666667 42.666667 0 0 1-42.666667-42.666667V298.666667a42.666667 42.666667 0 0 1 42.666667-42.666667h256z m469.333333-128v341.333333h-85.333333V273.621333l-332.501334 332.544-60.330666-60.330666L750.293333 213.333333H554.666667V128h341.333333z"
      p-id="2635"
    ></path>
  </svg>`;

  var dArrowRightIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
    ></path>
  </svg>`;

  var dArrowLeftIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
    ></path>
  </svg>`;

  var moreFilledIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
    ></path>
  </svg>`;

  var fullscreenIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
    ></path>
  </svg>`;

  var refreshLeftIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
    ></path>
  </svg>`;

  var refreshRightIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
    ></path>
  </svg>`;

  var scaleToOriginalIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118M512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412M512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512"
    ></path>
  </svg>`;

  var zoomInIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
    ></path>
  </svg>`;

  var zoomOutIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
    ></path>
  </svg>`;

  var circleCloseFilledIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
    ></path>
  </svg>`;

  var infoFilledIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
    ></path>
  </svg>`;

  var successFilledIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
    ></path>
  </svg>`;

  var warningFilledIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
    ></path>
  </svg>`;

  var questionFilledIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
    ></path>
  </svg>`;

  var topIcon = `<svg
    t="1746805227914"
    class="icon"
    viewBox="0 0 1024 1024"
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
    p-id="8528"
    width="200"
    height="200"
  >
    <path d="M103.5 103.5h407.8L928 521v407z" fill="currentColor" p-id="8529"></path>
    <path
      d="M507.7 219.1l-40-40.2 23.8-23.6 108.7 109.3-23.8 23.6-40.3-40.6-119.2 118.6-28.4-28.6 119.2-118.5zM539.3 345.2c46.5-46.3 99.5-47.1 137.2-9.3 37.7 37.9 36.4 91-10 137.1-46.3 46.1-100.7 48.3-138.3 10.4-37.7-37.8-35.2-92.1 11.1-138.2z m98.2 98.7c30.7-30.5 35.6-62.3 14.5-83.6s-52.9-16.5-83.6 14c-30.5 30.4-36.6 63.3-15.4 84.5 21 21.3 54 15.4 84.5-14.9zM765.2 430.5l46.7 46.9c31.5 31.7 44.7 67 10.9 100.6-32.6 32.5-71.7 22.5-102.3-8.2l-19-19.1-50.8 50.5-28.4-28.6 142.9-142.1z m-24 115c19.6 19.7 37.3 20.9 53.7 4.6 16.6-16.5 11.8-32.5-7.8-52.2L771 481.7l-46.9 46.7 17.1 17.1z"
      fill="#FFFFFF"
      p-id="8530"
    ></path>
  </svg>`;

  var lockIcon = `<svg data-v-d2e47025="" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024">
    <path
      fill="currentColor"
      d="M224 448a32 32 0 0 0-32 32v384a32 32 0 0 0 32 32h576a32 32 0 0 0 32-32V480a32 32 0 0 0-32-32zm0-64h576a96 96 0 0 1 96 96v384a96 96 0 0 1-96 96H224a96 96 0 0 1-96-96V480a96 96 0 0 1 96-96"
    ></path>
    <path
      fill="currentColor"
      d="M512 544a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V576a32 32 0 0 1 32-32m192-160v-64a192 192 0 1 0-384 0v64zM512 64a256 256 0 0 1 256 256v128H256V320A256 256 0 0 1 512 64"
    ></path>
  </svg>`;

  var autoWidthIcon = `<svg
    viewBox="0 0 48 48"
    display="inline-block"
    vertical-align="middle"
    min-width="1.2rem"
    width="1.2em"
    height="1.2em"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="4">
      <path d="M6 7h36M8 24h32" />
      <path stroke-linejoin="round" d="M13.99 30L8 24.005L14 18m20.01 0L40 23.995L34 30" />
      <path d="M6 41h36" />
    </g>
  </svg>`;

  var clickIcon = `<svg
    viewBox="0 0 48 48"
    display="inline-block"
    vertical-align="middle"
    min-width="1.2rem"
    width="1.2em"
    height="1.2em"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="4">
      <path d="M24 4v8" />
      <path d="m22 22l20 4l-6 4l6 6l-6 6l-6-6l-4 6z" clip-rule="evenodd" />
      <path d="m38.142 9.858l-5.657 5.657M9.858 38.142l5.657-5.657M4 24h8M9.858 9.858l5.657 5.657" />
    </g>
  </svg>`;

  var fullScreenOneIcon = `<svg
    viewBox="0 0 48 48"
    display="inline-block"
    vertical-align="middle"
    min-width="1.2rem"
    width="1.2em"
    height="1.2em"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fill="none"
      stroke="currentColor"
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="4"
      d="m6 6l10 9.9m-10 26L16 32m26 9.9L32.1 32m9.8-26L32 15.9M33 6h9v9m0 18v9h-9m-18 0H6v-9m0-18V6h9"
    />
  </svg>`;

  var fullscreenTwoIcon = `<svg
    viewBox="0 0 48 48"
    display="inline-block"
    vertical-align="middle"
    min-width="1.2rem"
    width="1.2em"
    height="1.2em"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fill="none"
      stroke="currentColor"
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="4"
      d="M30 6h12v12M18 6H6v12m24 24h12V30M18 42H6V30M42 6L29 19M19 29L6 42"
    />
  </svg>`;

  var layoutIcon = `<svg
    viewBox="0 0 48 48"
    display="inline-block"
    vertical-align="middle"
    min-width="1.2rem"
    width="1.2em"
    height="1.2em"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="4">
      <rect width="36" height="36" x="6" y="6" rx="3" />
      <path stroke-linecap="round" d="M6 16h36M6 13v6m36-5v6m-10-4v26m-3 0h6" />
    </g>
  </svg>`;

  var overallReductionIcon = `<svg
    viewBox="0 0 48 48"
    display="inline-block"
    vertical-align="middle"
    min-width="1.2rem"
    width="1.2em"
    height="1.2em"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fill="none"
      stroke="currentColor"
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="4"
      d="M15 15h18v18H15zm-4 28v-6H5m32 6v-6h6M11 5v6H5m32-6v6h6"
    />
  </svg>`;

  var alignLeftIcon = `<svg
    viewBox="0 0 48 48"
    display="inline-block"
    vertical-align="middle"
    min-width="1.2rem"
    width="1.2em"
    height="1.2em"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="4">
      <path stroke-linejoin="round" d="M16 6h16v6H16z" />
      <path d="M6 42V6" />
      <path stroke-linejoin="round" d="M16 21h20v6H16zm0 15h26v6H16z" />
    </g>
  </svg>`;

  var alignTextLeftIcon = `<svg
    viewBox="0 0 48 48"
    display="inline-block"
    vertical-align="middle"
    min-width="1.2rem"
    width="1.2em"
    height="1.2em"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="4">
      <path d="M39 6H9a3 3 0 0 0-3 3v30a3 3 0 0 0 3 3h30a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3Z" />
      <path stroke-linecap="round" d="M26 24H14m20-9H14m18 18H14" />
    </g>
  </svg>`;

  var scaleIcon = `<svg
      viewBox="0 0 48 48"
      display="inline-block"
      vertical-align="middle"
      min-width="1.2rem"
      width="1.2em"
      height="1.2em"
      xmlns="http://www.w3.org/2000/svg"
    >
      <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="4">
        <path d="M30 6h12v12M31 29H19V17M42 6L19 29" />
        <path d="M22 6H8a2 2 0 0 0-2 2v32a2 2 0 0 0 2 2h32a2 2 0 0 0 2-2V26" />
      </g>
    </svg>`;

  var waterIcon = `<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    class="lucide lucide-droplet h-4 w-4"
  >
    <path
      d="M12 22a7 7 0 0 0 7-7c0-2-1-3.9-3-5.5s-3.5-4-4-6.5c-.5 2.5-2 4.9-4 6.5C6 11.1 5 13 5 15a7 7 0 0 0 7 7z"
    ></path>
  </svg>`;

  const _hoisted_1$X = ["src", "crossorigin"];
  var _sfc_main$1o = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ImageViewer" },
    __name: "ImageViewer",
    props: {
      urlList: { default: () => [] },
      zIndex: {},
      initialIndex: { default: 0 },
      infinite: { type: Boolean, default: true },
      hideOnClickModal: { type: Boolean, default: false },
      teleported: { type: Boolean },
      closeOnPressEscape: { type: Boolean, default: true },
      zoomRate: { default: 1.2 },
      minScale: { default: 0.2 },
      maxScale: { default: 7 },
      showProgress: { type: Boolean, default: false },
      crossorigin: {}
    },
    emits: ["close", "switch", "rotate"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const modes = {
        CONTAIN: {
          name: "contain",
          icon: fullscreenIcon
        },
        ORIGINAL: {
          name: "original",
          icon: scaleToOriginalIcon
        }
      };
      const props = __props;
      const emit = __emit;
      let prevOverflow = "";
      const ns = useNamespace("image-viewer");
      const { t } = useLocale();
      const { nextZIndex } = useZIndex();
      const wrapper = Vue.ref();
      const imgRefs = Vue.ref([]);
      const scopeEventListener = Vue.effectScope();
      const loading = Vue.ref(true);
      const activeIndex = Vue.ref(props.initialIndex);
      const mode = Vue.shallowRef(modes.CONTAIN);
      const transform = Vue.ref({
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: false
      });
      const zIndex = Vue.ref(props.zIndex ?? nextZIndex());
      const isSingle = Vue.computed(() => {
        const { urlList } = props;
        return urlList.length <= 1;
      });
      const isFirst = Vue.computed(() => activeIndex.value === 0);
      const isLast = Vue.computed(() => activeIndex.value === props.urlList.length - 1);
      const currentImg = Vue.computed(() => props.urlList[activeIndex.value]);
      const arrowPrevKls = Vue.computed(() => [ns.e("btn"), ns.e("prev"), ns.is("disabled", !props.infinite && isFirst.value)]);
      const arrowNextKls = Vue.computed(() => [ns.e("btn"), ns.e("next"), ns.is("disabled", !props.infinite && isLast.value)]);
      const imgStyle = Vue.computed(() => {
        const { scale, deg, offsetX, offsetY, enableTransition } = transform.value;
        let translateX = offsetX / scale;
        let translateY = offsetY / scale;
        const radian = deg * Math.PI / 180;
        const cosRadian = Math.cos(radian);
        const sinRadian = Math.sin(radian);
        translateX = translateX * cosRadian + translateY * sinRadian;
        translateY = translateY * cosRadian - offsetX / scale * sinRadian;
        const style = {
          transform: `scale(${scale}) rotate(${deg}deg) translate(${translateX}px, ${translateY}px)`,
          transition: enableTransition ? "transform .3s" : ""
        };
        if (mode.value.name === modes.CONTAIN.name) {
          style.maxWidth = style.maxHeight = "100%";
        }
        return style;
      });
      const progress = Vue.computed(() => `${activeIndex.value + 1} / ${props.urlList.length}`);
      const hide = () => {
        unregisterEventListener();
        stopWheelListener?.();
        document.body.style.overflow = prevOverflow;
        emit("close");
      };
      const registerEventListener = () => {
        const keydownHandler = useDebounce((e) => {
          switch (e.code) {
            // ESC
            case "Escape":
              props.closeOnPressEscape && hide();
              break;
            // SPACE
            case "Space":
              toggleMode();
              break;
            // LEFT_ARROW
            case "ArrowLeft":
              prev();
              break;
            // UP_ARROW
            case "ArrowUp":
              handleActions("zoomIn");
              break;
            // RIGHT_ARROW
            case "ArrowRight":
              next();
              break;
            // DOWN_ARROW
            case "ArrowDown":
              handleActions("zoomOut");
              break;
          }
        });
        const mousewheelHandler = useDebounce((e) => {
          const delta = e.deltaY || e.deltaX;
          handleActions(delta < 0 ? "zoomIn" : "zoomOut", {
            zoomRate: props.zoomRate,
            enableTransition: false
          });
        });
        scopeEventListener.run(() => {
          useEventListener(document, "keydown", keydownHandler);
          useEventListener(document, "wheel", mousewheelHandler);
        });
      };
      const unregisterEventListener = () => {
        scopeEventListener.stop();
      };
      const handleImgLoad = () => {
        loading.value = false;
      };
      const handleImgError = (e) => {
        loading.value = false;
        e.target.alt = t("tk.image.error");
      };
      const handleMouseDown = (e) => {
        if (loading.value || e.button !== 0 || !wrapper.value) return;
        transform.value.enableTransition = false;
        const { offsetX, offsetY } = transform.value;
        const startX = e.pageX;
        const startY = e.pageY;
        const dragHandler = useDebounce((ev) => {
          transform.value = {
            ...transform.value,
            offsetX: offsetX + ev.pageX - startX,
            offsetY: offsetY + ev.pageY - startY
          };
        });
        const removeDragHandler = () => {
          document.removeEventListener("mousemove", dragHandler);
          document.removeEventListener("mouseup", removeDragHandler);
        };
        document.addEventListener("mousemove", dragHandler);
        document.addEventListener("mouseup", removeDragHandler);
        e.preventDefault();
      };
      const reset = () => {
        transform.value = {
          scale: 1,
          deg: 0,
          offsetX: 0,
          offsetY: 0,
          enableTransition: false
        };
      };
      const toggleMode = () => {
        if (loading.value) return;
        const modeNames = Object.keys(modes);
        const modeValues = Object.values(modes);
        const currentMode = mode.value.name;
        const index = modeValues.findIndex((i) => i.name === currentMode);
        const nextIndex = (index + 1) % modeNames.length;
        mode.value = modes[modeNames[nextIndex]];
        reset();
      };
      const setActiveItem = (index) => {
        const len = props.urlList.length;
        activeIndex.value = (index + len) % len;
      };
      const prev = () => {
        if (isFirst.value && !props.infinite) return;
        setActiveItem(activeIndex.value - 1);
      };
      const next = () => {
        if (isLast.value && !props.infinite) return;
        setActiveItem(activeIndex.value + 1);
      };
      const handleActions = (action, options = {}) => {
        if (loading.value) return;
        const { minScale, maxScale } = props;
        const { zoomRate, rotateDeg, enableTransition } = {
          zoomRate: props.zoomRate,
          rotateDeg: 90,
          enableTransition: true,
          ...options
        };
        switch (action) {
          case "zoomOut":
            if (transform.value.scale > minScale) {
              transform.value.scale = Number.parseFloat((transform.value.scale / zoomRate).toFixed(3));
            }
            break;
          case "zoomIn":
            if (transform.value.scale < maxScale) {
              transform.value.scale = Number.parseFloat((transform.value.scale * zoomRate).toFixed(3));
            }
            break;
          case "clockwise":
            transform.value.deg += rotateDeg;
            emit("rotate", transform.value.deg);
            break;
          case "anticlockwise":
            transform.value.deg -= rotateDeg;
            emit("rotate", transform.value.deg);
            break;
        }
        transform.value.enableTransition = enableTransition;
      };
      const onFocusoutPrevented = (event) => {
        if (event.detail?.focusReason === "pointer") {
          event.preventDefault();
        }
      };
      const onCloseRequested = () => {
        if (props.closeOnPressEscape) {
          hide();
        }
      };
      const wheelHandler = (e) => {
        if (!e.ctrlKey) return;
        if (e.deltaY < 0) {
          e.preventDefault();
          return false;
        } else if (e.deltaY > 0) {
          e.preventDefault();
          return false;
        }
      };
      Vue.watch(currentImg, () => {
        Vue.nextTick(() => {
          const $img = imgRefs.value[0];
          if (!$img?.complete) {
            loading.value = true;
          }
        });
      });
      Vue.watch(activeIndex, (val) => {
        reset();
        emit("switch", val);
      });
      registerEventListener();
      const stopWheelListener = useEventListener(document, "wheel", wheelHandler, { passive: false });
      Vue.onMounted(() => {
        prevOverflow = document.body.style.overflow;
        document.body.style.overflow = "hidden";
      });
      __expose({
        /**
         * 手动切换图片
         */
        setActiveItem
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.Teleport, {
          disabled: !__props.teleported,
          to: "body"
        }, [
          Vue.createVNode(Vue.Transition, {
            name: "viewer-fade",
            appear: ""
          }, {
            default: Vue.withCtx(() => [
              Vue.createElementVNode(
                "div",
                {
                  ref_key: "wrapper",
                  ref: wrapper,
                  tabindex: -1,
                  class: Vue.normalizeClass(Vue.unref(ns).e("wrapper")),
                  style: Vue.normalizeStyle({ zIndex: zIndex.value })
                },
                [
                  Vue.createVNode(Vue.unref(TkFocusTrap), {
                    loop: "",
                    trapped: "",
                    "focus-trap-el": wrapper.value,
                    "focus-start-el": "container",
                    onFocusoutPrevented,
                    onReleaseRequested: onCloseRequested
                  }, {
                    default: Vue.withCtx(() => [
                      Vue.createElementVNode(
                        "div",
                        {
                          class: Vue.normalizeClass(Vue.unref(ns).e("mask")),
                          onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => __props.hideOnClickModal && hide(), ["self"]))
                        },
                        null,
                        2
                        /* CLASS */
                      ),
                      Vue.createCommentVNode(" CLOSE "),
                      Vue.createElementVNode(
                        "span",
                        {
                          class: Vue.normalizeClass([Vue.unref(ns).e("btn"), Vue.unref(ns).e("close")]),
                          onClick: hide
                        },
                        [
                          Vue.createVNode(Vue.unref(_sfc_main$1t), { icon: Vue.unref(closeIcon) }, null, 8, ["icon"])
                        ],
                        2
                        /* CLASS */
                      ),
                      Vue.createCommentVNode(" ARROW "),
                      !isSingle.value ? (Vue.openBlock(), Vue.createElementBlock(
                        Vue.Fragment,
                        { key: 0 },
                        [
                          Vue.createElementVNode(
                            "span",
                            {
                              class: Vue.normalizeClass(arrowPrevKls.value),
                              onClick: prev
                            },
                            [
                              Vue.createVNode(Vue.unref(_sfc_main$1t), { icon: Vue.unref(arrowLeftIcon) }, null, 8, ["icon"])
                            ],
                            2
                            /* CLASS */
                          ),
                          Vue.createElementVNode(
                            "span",
                            {
                              class: Vue.normalizeClass(arrowNextKls.value),
                              onClick: next
                            },
                            [
                              Vue.createVNode(Vue.unref(_sfc_main$1t), { icon: Vue.unref(arrowRightIcon) }, null, 8, ["icon"])
                            ],
                            2
                            /* CLASS */
                          )
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      )) : Vue.createCommentVNode("v-if", true),
                      _ctx.$slots.progress || __props.showProgress ? (Vue.openBlock(), Vue.createElementBlock(
                        "div",
                        {
                          key: 1,
                          class: Vue.normalizeClass([Vue.unref(ns).e("btn"), Vue.unref(ns).e("progress")])
                        },
                        [
                          Vue.renderSlot(_ctx.$slots, "progress", {
                            activeIndex: activeIndex.value,
                            total: __props.urlList.length
                          }, () => [
                            Vue.createTextVNode(
                              Vue.toDisplayString(progress.value),
                              1
                              /* TEXT */
                            )
                          ])
                        ],
                        2
                        /* CLASS */
                      )) : Vue.createCommentVNode("v-if", true),
                      Vue.createCommentVNode(" ACTIONS "),
                      Vue.createElementVNode(
                        "div",
                        {
                          class: Vue.normalizeClass([Vue.unref(ns).e("btn"), Vue.unref(ns).e("actions")])
                        },
                        [
                          Vue.createElementVNode(
                            "div",
                            {
                              class: Vue.normalizeClass(Vue.unref(ns).e("actions__inner"))
                            },
                            [
                              Vue.renderSlot(_ctx.$slots, "toolbar", {
                                actions: handleActions,
                                prev,
                                next,
                                reset: toggleMode,
                                activeIndex: activeIndex.value,
                                setActiveItem
                              }, () => [
                                Vue.createVNode(Vue.unref(_sfc_main$1t), {
                                  icon: Vue.unref(zoomOutIcon),
                                  onClick: _cache[1] || (_cache[1] = ($event) => handleActions("zoomOut"))
                                }, null, 8, ["icon"]),
                                Vue.createVNode(Vue.unref(_sfc_main$1t), {
                                  icon: Vue.unref(zoomInIcon),
                                  onClick: _cache[2] || (_cache[2] = ($event) => handleActions("zoomIn"))
                                }, null, 8, ["icon"]),
                                Vue.createElementVNode(
                                  "i",
                                  {
                                    class: Vue.normalizeClass(Vue.unref(ns).e("actions__divider"))
                                  },
                                  null,
                                  2
                                  /* CLASS */
                                ),
                                Vue.createVNode(Vue.unref(_sfc_main$1t), {
                                  icon: mode.value.icon,
                                  onClick: toggleMode
                                }, null, 8, ["icon"]),
                                Vue.createElementVNode(
                                  "i",
                                  {
                                    class: Vue.normalizeClass(Vue.unref(ns).e("actions__divider"))
                                  },
                                  null,
                                  2
                                  /* CLASS */
                                ),
                                Vue.createVNode(Vue.unref(_sfc_main$1t), {
                                  icon: Vue.unref(refreshLeftIcon),
                                  onClick: _cache[3] || (_cache[3] = ($event) => handleActions("anticlockwise"))
                                }, null, 8, ["icon"]),
                                Vue.createVNode(Vue.unref(_sfc_main$1t), {
                                  icon: Vue.unref(refreshRightIcon),
                                  onClick: _cache[4] || (_cache[4] = ($event) => handleActions("clockwise"))
                                }, null, 8, ["icon"])
                              ])
                            ],
                            2
                            /* CLASS */
                          )
                        ],
                        2
                        /* CLASS */
                      ),
                      Vue.createCommentVNode(" CANVAS "),
                      Vue.createElementVNode(
                        "div",
                        {
                          class: Vue.normalizeClass(Vue.unref(ns).e("canvas"))
                        },
                        [
                          (Vue.openBlock(true), Vue.createElementBlock(
                            Vue.Fragment,
                            null,
                            Vue.renderList(__props.urlList, (url, i) => {
                              return Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("img", {
                                ref_for: true,
                                ref: (el) => imgRefs.value[i] = el,
                                key: url,
                                src: url,
                                style: Vue.normalizeStyle(imgStyle.value),
                                class: Vue.normalizeClass([Vue.unref(ns).e("img"), "image-viewer__img"]),
                                crossorigin: __props.crossorigin,
                                onLoad: handleImgLoad,
                                onError: handleImgError,
                                onMousedown: handleMouseDown
                              }, null, 46, _hoisted_1$X)), [
                                [Vue.vShow, i === activeIndex.value]
                              ]);
                            }),
                            128
                            /* KEYED_FRAGMENT */
                          ))
                        ],
                        2
                        /* CLASS */
                      ),
                      Vue.renderSlot(_ctx.$slots, "default")
                    ]),
                    _: 3
                    /* FORWARDED */
                  }, 8, ["focus-trap-el"])
                ],
                6
                /* CLASS, STYLE */
              )
            ]),
            _: 3
            /* FORWARDED */
          })
        ], 8, ["disabled"]);
      };
    }
  });

  var _sfc_main$1n = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ImageViewerControl" },
    __name: "index",
    props: {
      "modelValue": { default: false },
      "modelModifiers": {}
    },
    emits: ["update:modelValue"],
    setup(__props) {
      const visible = Vue.useModel(__props, "modelValue");
      const close = () => {
        document.body.style.overflow = "";
        visible.value = false;
      };
      return (_ctx, _cache) => {
        return visible.value ? (Vue.openBlock(), Vue.createBlock(
          _sfc_main$1o,
          Vue.mergeProps({ key: 0 }, _ctx.$attrs, { onClose: close }),
          null,
          16
          /* FULL_PROPS */
        )) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  let instance = null;
  const createImageViewer = (options) => {
    if (typeof window === "undefined") return;
    const { modelValue = true } = options;
    options.modelValue = modelValue;
    document.body.style.overflow = "hidden";
    const container = document.createElement("div");
    document.body.appendChild(container);
    instance = Vue.createVNode(_sfc_main$1n, options);
    Vue.render(instance, container);
  };

  const _hoisted_1$W = ["name", "min", "max", "disabled", "step"];
  var _sfc_main$1m = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "InputSlide" },
    __name: "index",
    props: /* @__PURE__ */ Vue.mergeModels({
      name: { default: "Slider" },
      disabled: { type: Boolean },
      min: { default: 0 },
      max: { default: 100 },
      step: { default: 1 },
      format: { type: Function }
    }, {
      "modelValue": { default: 0 },
      "modelModifiers": {}
    }),
    emits: ["update:modelValue"],
    setup(__props) {
      const ns = useNamespace("input-slide");
      const inputValue = Vue.useModel(__props, "modelValue");
      const inputSliderRef = Vue.ref();
      const inputSliderTooltipRef = Vue.ref();
      const hovering = useElementHover(inputSliderRef);
      const positioning = Vue.ref(false);
      const sliderValueVar = ns.cssVarName("slider-value");
      const sliderMinVar = ns.cssVarName("slider-min");
      const sliderMaxVar = ns.cssVarName("slider-max");
      useEventListener(inputSliderRef, "input", () => {
        if (!inputSliderRef.value) return;
        inputSliderRef.value.style.setProperty(sliderValueVar, inputSliderRef.value.value.toString());
      });
      Vue.onMounted(() => {
        if (!inputSliderRef.value) return;
        const inputSliderStyle = inputSliderRef.value.style;
        inputSliderStyle.setProperty(sliderValueVar, inputValue.value.toString());
        inputSliderStyle.setProperty(sliderMinVar, __props.min?.toString() ?? "0");
        inputSliderStyle.setProperty(sliderMaxVar, __props.max?.toString() ?? "100");
      });
      const calTipPosition = (inputElement, inputTooltipElement) => {
        const finalMax = __props.max || 100;
        const finalMin = __props.min || 0;
        const ratio = (inputValue.value - finalMin) / (finalMax - finalMin);
        const rect = inputElement.getBoundingClientRect();
        const tooltipRect = inputTooltipElement.getBoundingClientRect();
        const centeringShift = (tooltipRect.width - 32) / 2;
        inputTooltipElement.style.setProperty("left", `${ratio * (rect.width - 32) - centeringShift}px`);
      };
      Vue.watch(hovering, () => {
        positioning.value = true;
        setTimeout(() => {
          if (!hovering.value) {
            positioning.value = false;
            return;
          }
          if (!inputSliderRef.value) {
            positioning.value = false;
            return;
          }
          if (!inputSliderTooltipRef.value) {
            positioning.value = false;
            return;
          }
          calTipPosition(inputSliderRef.value, inputSliderTooltipRef.value);
          positioning.value = false;
        }, 50);
      });
      Vue.watch(inputValue, (val) => {
        if (val < __props.min) val = __props.min;
        if (val > __props.max) val = __props.max;
        if (!inputSliderRef.value || !inputSliderTooltipRef.value) return;
        calTipPosition(inputSliderRef.value, inputSliderTooltipRef.value);
      });
      Vue.watch(
        () => __props.min,
        (val) => {
          if (inputValue.value >= val) return;
          inputValue.value = val;
        }
      );
      Vue.watch(
        () => __props.max,
        (val) => {
          if (inputValue.value <= val) return;
          inputValue.value = val;
        }
      );
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass(Vue.unref(ns).b())
          },
          [
            Vue.createElementVNode(
              "label",
              {
                class: Vue.normalizeClass(Vue.unref(ns).e("label"))
              },
              [
                Vue.withDirectives(Vue.createElementVNode("input", {
                  ref_key: "inputSliderRef",
                  ref: inputSliderRef,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inputValue.value = $event),
                  type: "range",
                  name: __props.name,
                  min: __props.min,
                  max: __props.max,
                  disabled: __props.disabled,
                  step: __props.step,
                  class: Vue.normalizeClass([Vue.unref(ns).e("label__input"), Vue.unref(ns).e("label__input-progress"), Vue.unref(ns).is("disabled", __props.disabled)])
                }, null, 10, _hoisted_1$W), [
                  [
                    Vue.vModelText,
                    inputValue.value,
                    void 0,
                    { number: true }
                  ]
                ]),
                Vue.createVNode(Vue.Transition, {
                  name: "fade",
                  persisted: ""
                }, {
                  default: Vue.withCtx(() => [
                    Vue.withDirectives(Vue.createElementVNode(
                      "span",
                      {
                        ref_key: "inputSliderTooltipRef",
                        ref: inputSliderTooltipRef,
                        class: Vue.normalizeClass([Vue.unref(ns).e("label__tooltip"), Vue.unref(ns).is("opacity-0", Vue.unref(hovering) && positioning.value)])
                      },
                      Vue.toDisplayString(!!__props.format ? __props.format(inputValue.value) : inputValue.value),
                      3
                      /* TEXT, CLASS */
                    ), [
                      [Vue.vShow, Vue.unref(hovering)]
                    ])
                  ]),
                  _: 1
                  /* STABLE */
                })
              ],
              2
              /* CLASS */
            )
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const messageTypes = ["primary", "success", "info", "warning", "error"];
  const messagePropsDefaults = {
    customClass: "",
    center: false,
    dangerouslyUseHTMLString: false,
    duration: 3e3,
    icon: void 0,
    id: "",
    message: "",
    onClose: void 0,
    showClose: false,
    type: "info",
    plain: false,
    offset: 16,
    zIndex: 0,
    grouping: false,
    repeatNum: 1
  };
  const messageDefaults = {
    ...messagePropsDefaults,
    appendTo: isClient ? document.body : void 0
  };

  const instances = Vue.shallowReactive([]);
  const getInstance = (id) => {
    const idx = instances.findIndex((instance) => instance.id === id);
    const current = instances[idx];
    let prev;
    if (idx > 0) {
      prev = instances[idx - 1];
    }
    return { current, prev };
  };
  const getLastOffset = (id) => {
    const { prev } = getInstance(id);
    if (!prev) return 0;
    return prev.vm.exposed.bottom.value;
  };
  const getOffsetOrSpace = (id, offset) => {
    const idx = instances.findIndex((instance) => instance.id === id);
    return idx > 0 ? 16 : offset;
  };

  const _hoisted_1$V = ["id"];
  const _hoisted_2$J = ["innerHTML"];
  var _sfc_main$1l = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "Message" },
    __name: "index",
    props: /* @__PURE__ */ Vue.mergeDefaults({
      customClass: {},
      center: { type: Boolean },
      dangerouslyUseHTMLString: { type: Boolean },
      duration: {},
      icon: {},
      id: {},
      message: { type: [String, Object, Function] },
      onClose: { type: Function },
      showClose: { type: Boolean },
      type: {},
      plain: { type: Boolean },
      offset: {},
      zIndex: {},
      grouping: { type: Boolean },
      repeatNum: {}
    }, messagePropsDefaults),
    emits: ["destroy"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const iconsMap = {
        success: successFilledIcon,
        warning: warningFilledIcon,
        error: circleCloseFilledIcon,
        info: infoFilledIcon
      };
      const isStartTransition = Vue.ref(false);
      const ns = useNamespace("message");
      const { currentZIndex, nextZIndex } = useZIndex();
      const messageRef = Vue.ref();
      const visible = Vue.ref(false);
      const height = Vue.ref(0);
      const badeTypeMap = {
        info: "info",
        primary: "primary",
        success: "success",
        warning: "warning",
        error: "danger"
      };
      const badgeType = Vue.computed(() => props.type ? badeTypeMap[props.type] : "info");
      const typeClass = Vue.computed(() => {
        const type = props.type;
        return { [ns.bm("icon", type)]: type && iconsMap[type] };
      });
      const iconComponent = Vue.computed(() => props.icon || iconsMap[props.type] || "");
      const lastOffset = Vue.computed(() => getLastOffset(props.id));
      const offset = Vue.computed(() => getOffsetOrSpace(props.id, props.offset) + lastOffset.value);
      const bottom = Vue.computed(() => height.value + offset.value);
      const customStyle = Vue.computed(() => ({
        top: `${offset.value}px`,
        zIndex: currentZIndex.value
      }));
      let timer;
      const clearTimer = () => {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      };
      const startTimer = () => {
        if (props.duration === 0) return;
        clearTimer();
        timer = setTimeout(() => {
          close();
        }, props.duration);
      };
      const close = () => {
        visible.value = false;
        Vue.nextTick(() => {
          if (!isStartTransition.value) {
            props.onClose?.();
            emit("destroy");
          }
        });
      };
      const keydown = ({ code }) => {
        if (code === "Space") {
          close();
        }
      };
      let resizeObserver;
      Vue.onMounted(() => {
        startTimer();
        nextZIndex();
        visible.value = true;
        resizeObserver = new ResizeObserver(() => {
          if (messageRef.value) height.value = messageRef.value.getBoundingClientRect().height;
        });
        if (messageRef.value) resizeObserver.observe(messageRef.value);
      });
      Vue.onUnmounted(() => {
        if (resizeObserver && messageRef.value) resizeObserver.unobserve(messageRef.value);
      });
      Vue.watch(
        () => props.repeatNum,
        () => {
          clearTimer();
          startTimer();
        }
      );
      useEventListener(document, "keydown", keydown);
      __expose({
        visible,
        bottom,
        close
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.Transition, {
          name: Vue.unref(ns).b("fade"),
          onBeforeEnter: _cache[0] || (_cache[0] = ($event) => isStartTransition.value = true),
          onBeforeLeave: __props.onClose,
          onAfterLeave: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("destroy")),
          persisted: ""
        }, {
          default: Vue.withCtx(() => [
            Vue.withDirectives(Vue.createElementVNode("div", {
              id: __props.id,
              ref_key: "messageRef",
              ref: messageRef,
              class: Vue.normalizeClass([
                Vue.unref(ns).b(),
                { [Vue.unref(ns).m(__props.type)]: __props.type },
                Vue.unref(ns).is("center", __props.center),
                Vue.unref(ns).is("closable", __props.showClose),
                Vue.unref(ns).is("plain", __props.plain),
                __props.customClass
              ]),
              style: Vue.normalizeStyle(customStyle.value),
              role: "alert",
              onMouseenter: clearTimer,
              onMouseleave: startTimer
            }, [
              __props.repeatNum > 1 ? (Vue.openBlock(), Vue.createBlock(Vue.unref(DefaultTheme.VPBadge), {
                key: 0,
                text: __props.repeatNum,
                type: badgeType.value,
                class: Vue.normalizeClass(Vue.unref(ns).e("badge"))
              }, null, 8, ["text", "type", "class"])) : Vue.createCommentVNode("v-if", true),
              iconComponent.value ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                key: 1,
                icon: iconComponent.value,
                class: Vue.normalizeClass([Vue.unref(ns).e("icon"), typeClass.value])
              }, null, 8, ["icon", "class"])) : Vue.createCommentVNode("v-if", true),
              Vue.renderSlot(_ctx.$slots, "default", {}, () => [
                !__props.dangerouslyUseHTMLString ? (Vue.openBlock(), Vue.createElementBlock(
                  "p",
                  {
                    key: 0,
                    class: Vue.normalizeClass(Vue.unref(ns).e("content"))
                  },
                  Vue.toDisplayString(__props.message),
                  3
                  /* TEXT, CLASS */
                )) : (Vue.openBlock(), Vue.createElementBlock("p", {
                  key: 1,
                  class: Vue.normalizeClass(Vue.unref(ns).e("content")),
                  innerHTML: __props.message
                }, null, 10, _hoisted_2$J))
              ]),
              __props.showClose ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                key: 2,
                icon: Vue.unref(closeIcon),
                class: Vue.normalizeClass(Vue.unref(ns).e("closeBtn")),
                onClick: Vue.withModifiers(close, ["stop"])
              }, null, 8, ["icon", "class"])) : Vue.createCommentVNode("v-if", true)
            ], 46, _hoisted_1$V), [
              [Vue.vShow, visible.value]
            ])
          ]),
          _: 3
          /* FORWARDED */
        }, 8, ["name", "onBeforeLeave"]);
      };
    }
  });

  let seed = 1;
  const normalizeOptions = (params) => {
    const options = !params || isString$1(params) || Vue.isVNode(params) || isFunction(params) ? { message: params } : params;
    const normalized = {
      ...messageDefaults,
      ...options
    };
    if (!normalized.appendTo) normalized.appendTo = document.body;
    else if (isString$1(normalized.appendTo)) {
      let appendTo = document.querySelector(normalized.appendTo);
      if (!isElement(appendTo)) {
        console.warn("Message", "the appendTo option is not an HTMLElement. Falling back to document.body.");
        appendTo = document.body;
      }
      normalized.appendTo = appendTo;
    }
    return normalized;
  };
  const closeMessage = (instance) => {
    const idx = instances.indexOf(instance);
    if (idx === -1) return;
    instances.splice(idx, 1);
    const { handler } = instance;
    handler.close();
  };
  const createMessage = ({ appendTo, ...options }, context) => {
    const id = `message_${seed++}`;
    const userOnClose = options.onClose;
    const container = document.createElement("div");
    const props = {
      ...options,
      // now the zIndex will be used inside the message.vue component instead of here.
      // zIndex: nextIndex() + options.zIndex
      id,
      onClose: () => {
        userOnClose?.();
        closeMessage(instance);
      },
      // clean message element preventing mem leak
      onDestroy: () => {
        Vue.render(null, container);
      }
    };
    const vnode = Vue.createVNode(
      _sfc_main$1l,
      props,
      isFunction(props.message) || Vue.isVNode(props.message) ? {
        default: isFunction(props.message) ? props.message : () => props.message
      } : null
    );
    vnode.appContext = context || message._context;
    Vue.render(vnode, container);
    appendTo.appendChild(container.firstElementChild);
    const vm = vnode.component;
    const handler = {
      // instead of calling the onClose function directly, setting this value so that we can have the full lifecycle
      // for out component, so that all closing steps will not be skipped.
      close: () => {
        vm.exposed.close();
      }
    };
    const instance = {
      id,
      vnode,
      vm,
      handler,
      props: vnode.component.props
    };
    return instance;
  };
  const message = (options = {}, context) => {
    if (!isClient) return { close: () => void 0 };
    const normalized = normalizeOptions(options);
    if (normalized.grouping && instances.length) {
      const instance2 = instances.find(({ vnode: vm }) => vm.props?.message === normalized.message);
      if (instance2) {
        instance2.props.repeatNum += 1;
        instance2.props.type = normalized.type;
        return instance2.handler;
      }
    }
    const instance = createMessage(normalized, context);
    instances.push(instance);
    return instance.handler;
  };
  messageTypes.forEach((type) => {
    message[type] = (options = {}, appContext) => {
      const normalized = normalizeOptions(options);
      return message({ ...normalized, type }, appContext);
    };
  });
  function closeAll(type) {
    const instancesToClose = [...instances];
    for (const instance of instancesToClose) {
      if (!type || type === instance.props.type) {
        instance.handler.close();
      }
    }
  }
  message.closeAll = closeAll;
  message._context = null;

  const paginationKey = Symbol("paginationKey");

  const _hoisted_1$U = ["disabled", "aria-label", "aria-disabled"];
  const _hoisted_2$I = { key: 0 };
  var _sfc_main$1k = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "PaginationPrev" },
    __name: "prev",
    props: {
      disabled: { type: Boolean },
      currentPage: {},
      prevText: {},
      prevIcon: {}
    },
    emits: ["click"],
    setup(__props) {
      const props = __props;
      const { t } = useLocale();
      const internalDisabled = Vue.computed(() => props.disabled || props.currentPage <= 1);
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("button", {
          type: "button",
          class: "btn-prev",
          disabled: internalDisabled.value,
          "aria-label": __props.prevText || Vue.unref(t)("tk.pagination.prev"),
          "aria-disabled": internalDisabled.value,
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
        }, [
          __props.prevText ? (Vue.openBlock(), Vue.createElementBlock(
            "span",
            _hoisted_2$I,
            Vue.toDisplayString(__props.prevText),
            1
            /* TEXT */
          )) : __props.prevIcon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
            key: 1,
            icon: __props.prevIcon
          }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true)
        ], 8, _hoisted_1$U);
      };
    }
  });

  const _hoisted_1$T = ["disabled", "aria-label", "aria-disabled"];
  const _hoisted_2$H = { key: 0 };
  var _sfc_main$1j = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "PaginationNext" },
    __name: "next",
    props: {
      disabled: { type: Boolean },
      currentPage: {},
      pageCount: {},
      nextText: {},
      nextIcon: {}
    },
    emits: ["click"],
    setup(__props) {
      const props = __props;
      const { t } = useLocale();
      const internalDisabled = Vue.computed(
        () => props.disabled || props.currentPage === props.pageCount || props.pageCount === 0
      );
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("button", {
          type: "button",
          class: "btn-next",
          disabled: internalDisabled.value,
          "aria-label": __props.nextText || Vue.unref(t)("tk.pagination.next"),
          "aria-disabled": internalDisabled.value,
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
        }, [
          __props.nextText ? (Vue.openBlock(), Vue.createElementBlock(
            "span",
            _hoisted_2$H,
            Vue.toDisplayString(__props.nextText),
            1
            /* TEXT */
          )) : __props.nextIcon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
            key: 1,
            icon: __props.nextIcon
          }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true)
        ], 8, _hoisted_1$T);
      };
    }
  });

  const usePagination = () => Vue.inject(paginationKey, {});

  const _hoisted_1$S = ["disabled"];
  const _hoisted_2$G = ["disabled", "aria-label"];
  var _sfc_main$1i = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "PaginationJumper" },
    __name: "jumper",
    props: {
      size: { default: "default" }
    },
    setup(__props) {
      const ns = useNamespace("pagination");
      const { t } = useLocale();
      const { pageCount, disabled, currentPage, changeEvent } = usePagination();
      const userInput = Vue.ref(currentPage?.value || 1);
      const handleChange = (event) => {
        let value = event.target?.value || userInput.value;
        if (value < 1) value = 1;
        if (pageCount?.value && value > pageCount.value) value = pageCount.value;
        const val = Math.trunc(+value);
        changeEvent?.(val);
        userInput.value = val;
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("span", {
          class: Vue.normalizeClass(Vue.unref(ns).e("jump")),
          disabled: Vue.unref(disabled)
        }, [
          Vue.createElementVNode(
            "span",
            {
              class: Vue.normalizeClass([Vue.unref(ns).e("goto")])
            },
            Vue.toDisplayString(Vue.unref(t)("tk.pagination.goto")),
            3
            /* TEXT, CLASS */
          ),
          Vue.withDirectives(Vue.createElementVNode("input", {
            type: "number",
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => userInput.value = $event),
            disabled: Vue.unref(disabled),
            onChange: handleChange,
            "aria-label": Vue.unref(t)("tk.pagination.page"),
            class: Vue.normalizeClass([Vue.unref(ns).e("input"), Vue.unref(ns).em("input", __props.size)])
          }, null, 42, _hoisted_2$G), [
            [Vue.vModelText, userInput.value]
          ]),
          Vue.createElementVNode(
            "span",
            {
              class: Vue.normalizeClass([Vue.unref(ns).e("classifier")])
            },
            Vue.toDisplayString(Vue.unref(t)("tk.pagination.pageClassifier")),
            3
            /* TEXT, CLASS */
          )
        ], 10, _hoisted_1$S);
      };
    }
  });

  const _hoisted_1$R = ["disabled"];
  var _sfc_main$1h = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "PaginationTotal" },
    __name: "total",
    props: {
      total: {}
    },
    setup(__props) {
      const ns = useNamespace("pagination");
      const { t } = useLocale();
      const { disabled } = usePagination();
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("span", {
          class: Vue.normalizeClass(Vue.unref(ns).e("total")),
          disabled: Vue.unref(disabled)
        }, Vue.toDisplayString(Vue.unref(t)("tk.pagination.total", {
          total: __props.total
        })), 11, _hoisted_1$R);
      };
    }
  });

  const _hoisted_1$Q = ["aria-current", "aria-label", "tabindex"];
  const _hoisted_2$F = ["tabindex", "aria-label"];
  const _hoisted_3$w = ["innerHTML"];
  const _hoisted_4$s = ["innerHTML"];
  const _hoisted_5$i = ["aria-current", "aria-label", "tabindex"];
  const _hoisted_6$e = ["tabindex", "aria-label"];
  const _hoisted_7$9 = ["innerHTML"];
  const _hoisted_8$6 = ["innerHTML"];
  const _hoisted_9$5 = ["aria-current", "aria-label", "tabindex"];
  var _sfc_main$1g = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "PaginationPager" },
    __name: "pager",
    props: {
      currentPage: {},
      pageCount: {},
      pagerCount: {},
      disabled: { type: Boolean }
    },
    emits: ["change"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const nsPager = useNamespace("pager");
      const nsIcon = useNamespace("icon");
      const { t } = useLocale();
      const showPrevMore = Vue.ref(false);
      const showNextMore = Vue.ref(false);
      const quickPrevHover = Vue.ref(false);
      const quickNextHover = Vue.ref(false);
      const quickPrevFocus = Vue.ref(false);
      const quickNextFocus = Vue.ref(false);
      const pagers = Vue.computed(() => {
        const pagerCount = props.pagerCount || 7;
        const halfPagerCount = (pagerCount - 1) / 2;
        const currentPage = Number(props.currentPage);
        const pageCount = Number(props.pageCount);
        let showPrevMore2 = false;
        let showNextMore2 = false;
        if (pageCount > pagerCount) {
          if (currentPage > pagerCount - halfPagerCount) showPrevMore2 = true;
          if (currentPage < pageCount - halfPagerCount) showNextMore2 = true;
        }
        const array = [];
        if (showPrevMore2 && !showNextMore2) {
          const startPage = pageCount - (pagerCount - 2);
          for (let i = startPage; i < pageCount; i++) {
            array.push(i);
          }
        } else if (!showPrevMore2 && showNextMore2) {
          for (let i = 2; i < pagerCount; i++) {
            array.push(i);
          }
        } else if (showPrevMore2 && showNextMore2) {
          const offset = Math.floor(pagerCount / 2) - 1;
          for (let i = currentPage - offset; i <= currentPage + offset; i++) {
            array.push(i);
          }
        } else {
          for (let i = 2; i < pageCount; i++) {
            array.push(i);
          }
        }
        return array;
      });
      const prevMoreKls = Vue.computed(() => ["more", "btn-quick-prev", nsIcon.b(), nsPager.is("disabled", props.disabled)]);
      const nextMoreKls = Vue.computed(() => ["more", "btn-quick-next", nsIcon.b(), nsPager.is("disabled", props.disabled)]);
      const tabindex = Vue.computed(() => props.disabled ? -1 : 0);
      Vue.watchEffect(() => {
        const halfPagerCount = (props.pagerCount - 1) / 2;
        showPrevMore.value = false;
        showNextMore.value = false;
        if (props.pageCount > props.pagerCount) {
          if (props.currentPage > props.pagerCount - halfPagerCount) showPrevMore.value = true;
          if (props.currentPage < props.pageCount - halfPagerCount) showNextMore.value = true;
        }
      });
      const onMouseEnter = (forward = false) => {
        if (props.disabled) return;
        if (forward) quickPrevHover.value = true;
        else quickNextHover.value = true;
      };
      const onFocus = (forward = false) => {
        if (forward) quickPrevFocus.value = true;
        else quickNextFocus.value = true;
      };
      const onEnter = (e) => {
        const target = e.target;
        if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("number")) {
          const newPage = Number(target.textContent);
          if (newPage !== props.currentPage) emit("change", newPage);
        } else if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("more")) {
          onPagerClick(e);
        }
      };
      const onPagerClick = (event) => {
        const target = event.target;
        if (target.tagName.toLowerCase() === "ul" || props.disabled) return;
        let newPage = Number(target.textContent);
        const pageCount = props.pageCount;
        const currentPage = props.currentPage;
        const pagerCountOffset = props.pagerCount - 2;
        if (target.className.includes("more")) {
          if (target.className.includes("quick-prev")) newPage = currentPage - pagerCountOffset;
          else if (target.className.includes("quick-next")) newPage = currentPage + pagerCountOffset;
        }
        if (!Number.isNaN(+newPage)) {
          if (newPage < 1) newPage = 1;
          if (newPage > pageCount) newPage = pageCount;
        }
        if (newPage !== currentPage) emit("change", newPage);
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "ul",
          {
            class: Vue.normalizeClass(Vue.unref(nsPager).b()),
            onClick: onPagerClick,
            onKeyup: Vue.withKeys(onEnter, ["enter"])
          },
          [
            __props.pageCount > 0 ? (Vue.openBlock(), Vue.createElementBlock("li", {
              key: 0,
              class: Vue.normalizeClass([[Vue.unref(nsPager).is("active", __props.currentPage === 1), Vue.unref(nsPager).is("disabled", __props.disabled)], "number"]),
              "aria-current": __props.currentPage === 1,
              "aria-label": Vue.unref(t)("tk.pagination.currentPage", { pager: 1 }),
              tabindex: tabindex.value
            }, " 1 ", 10, _hoisted_1$Q)) : Vue.createCommentVNode("v-if", true),
            showPrevMore.value ? (Vue.openBlock(), Vue.createElementBlock("li", {
              key: 1,
              class: Vue.normalizeClass(prevMoreKls.value),
              tabindex: tabindex.value,
              "aria-label": Vue.unref(t)("tk.pagination.prevPages", { pager: __props.pagerCount - 2 }),
              onMouseenter: _cache[0] || (_cache[0] = ($event) => onMouseEnter(true)),
              onMouseleave: _cache[1] || (_cache[1] = ($event) => quickPrevHover.value = false),
              onFocus: _cache[2] || (_cache[2] = ($event) => onFocus(true)),
              onBlur: _cache[3] || (_cache[3] = ($event) => quickPrevFocus.value = false)
            }, [
              (quickPrevHover.value || quickPrevFocus.value) && !__props.disabled ? (Vue.openBlock(), Vue.createElementBlock("span", {
                key: 0,
                innerHTML: Vue.unref(dArrowLeftIcon)
              }, null, 8, _hoisted_3$w)) : (Vue.openBlock(), Vue.createElementBlock("span", {
                key: 1,
                innerHTML: Vue.unref(moreFilledIcon)
              }, null, 8, _hoisted_4$s))
            ], 42, _hoisted_2$F)) : Vue.createCommentVNode("v-if", true),
            (Vue.openBlock(true), Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(pagers.value, (pager) => {
                return Vue.openBlock(), Vue.createElementBlock("li", {
                  key: pager,
                  class: Vue.normalizeClass([[Vue.unref(nsPager).is("active", __props.currentPage === pager), Vue.unref(nsPager).is("disabled", __props.disabled)], "number"]),
                  "aria-current": __props.currentPage === pager,
                  "aria-label": Vue.unref(t)("el.pagination.currentPage", { pager }),
                  tabindex: tabindex.value
                }, Vue.toDisplayString(pager), 11, _hoisted_5$i);
              }),
              128
              /* KEYED_FRAGMENT */
            )),
            showNextMore.value ? (Vue.openBlock(), Vue.createElementBlock("li", {
              key: 2,
              class: Vue.normalizeClass(nextMoreKls.value),
              tabindex: tabindex.value,
              "aria-label": Vue.unref(t)("tk.pagination.nextPages", { pager: __props.pagerCount - 2 }),
              onMouseenter: _cache[4] || (_cache[4] = ($event) => onMouseEnter()),
              onMouseleave: _cache[5] || (_cache[5] = ($event) => quickNextHover.value = false),
              onFocus: _cache[6] || (_cache[6] = ($event) => onFocus()),
              onBlur: _cache[7] || (_cache[7] = ($event) => quickNextFocus.value = false)
            }, [
              (quickNextHover.value || quickNextFocus.value) && !__props.disabled ? (Vue.openBlock(), Vue.createElementBlock("span", {
                key: 0,
                innerHTML: Vue.unref(dArrowRightIcon)
              }, null, 8, _hoisted_7$9)) : (Vue.openBlock(), Vue.createElementBlock("span", {
                key: 1,
                innerHTML: Vue.unref(moreFilledIcon)
              }, null, 8, _hoisted_8$6))
            ], 42, _hoisted_6$e)) : Vue.createCommentVNode("v-if", true),
            __props.pageCount > 1 ? (Vue.openBlock(), Vue.createElementBlock("li", {
              key: 3,
              class: Vue.normalizeClass([[Vue.unref(nsPager).is("active", __props.currentPage === __props.pageCount), Vue.unref(nsPager).is("disabled", __props.disabled)], "number"]),
              "aria-current": __props.currentPage === __props.pageCount,
              "aria-label": Vue.unref(t)("tk.pagination.currentPage", { pager: __props.pageCount }),
              tabindex: tabindex.value
            }, Vue.toDisplayString(__props.pageCount), 11, _hoisted_9$5)) : Vue.createCommentVNode("v-if", true)
          ],
          34
          /* CLASS, NEED_HYDRATION */
        );
      };
    }
  });

  var _sfc_main$1f = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "Pagination" },
    __name: "index",
    props: /* @__PURE__ */ Vue.mergeModels({
      total: {},
      pageCount: {},
      pagerCount: { default: 7 },
      layout: { default: ["prev, pager, next, jumper, ->, total"].join(", ") },
      prevText: {},
      prevIcon: { default: () => arrowLeftIcon },
      nextText: {},
      nextIcon: { default: () => arrowRightIcon },
      size: { default: "default" },
      background: { type: Boolean, default: false },
      disabled: { type: Boolean, default: false },
      hideOnSinglePage: { type: Boolean, default: false }
    }, {
      "currentPage": { type: Number, default: 1 },
      "currentPageModifiers": {},
      "pageSize": { type: Number, default: 10 },
      "pageSizeModifiers": {}
    }),
    emits: /* @__PURE__ */ Vue.mergeModels(["size-change", "change", "current-change", "prev-click", "next-click"], ["update:currentPage", "update:pageSize"]),
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const ns = useNamespace("pagination");
      const slots = Vue.useSlots();
      const currentPageModel = Vue.useModel(__props, "currentPage");
      const pageSizeModel = Vue.useModel(__props, "pageSize");
      const isAbsent = (v) => typeof v !== "number";
      const pageCountBridge = Vue.computed(() => {
        let pageCount = 0;
        if (!isAbsent(props.pageCount)) pageCount = props.pageCount;
        else if (!isAbsent(props.total)) pageCount = Math.max(1, Math.ceil(props.total / pageSizeModel.value));
        return pageCount;
      });
      Vue.watch(pageCountBridge, (val) => {
        if (currentPageModel.value > val) currentPageModel.value = val;
      });
      Vue.watch(
        [currentPageModel, pageSizeModel],
        (value) => {
          emit("change", ...value);
        },
        { flush: "post" }
      );
      const handleSizeChange = (val) => {
        pageSizeModel.value = val;
        emit("size-change", pageSizeModel.value);
        const newPageCount = pageCountBridge.value;
        if (currentPageModel.value > newPageCount) currentPageModel.value = newPageCount;
      };
      const prev = () => {
        if (props.disabled) return;
        handleCurrentChange(currentPageModel.value - 1);
        emit("prev-click", currentPageModel.value);
      };
      const next = () => {
        if (props.disabled) return;
        handleCurrentChange(currentPageModel.value + 1);
        emit("next-click", currentPageModel.value);
      };
      const handleCurrentChange = (val) => {
        currentPageModel.value = val;
        const newPageCount = pageCountBridge.value;
        if (currentPageModel.value < 1) currentPageModel.value = 1;
        else if (currentPageModel.value > newPageCount) currentPageModel.value = newPageCount;
        emit("current-change", currentPageModel.value);
      };
      const addClass = (element, cls) => {
        if (element) {
          if (!element.props) element.props = {};
          element.props.class = [element.props.class, cls].join(" ");
        }
      };
      Vue.provide(paginationKey, {
        pageCount: pageCountBridge,
        disabled: Vue.computed(() => props.disabled),
        currentPage: currentPageModel,
        changeEvent: handleCurrentChange,
        handleSizeChange
      });
      const components = Vue.computed(() => {
        if (!props.layout) return [];
        if (props.hideOnSinglePage && pageCountBridge.value <= 1) return [];
        const components2 = props.layout.split(",").map((item) => item.trim());
        const rootChildren = [];
        const rightWrapperChildren = [];
        const rightWrapperRoot = Vue.h("div", { class: ns.e("right-wrapper") }, rightWrapperChildren);
        let haveRightWrapper = false;
        components2.forEach((c) => {
          if (c === "->") {
            haveRightWrapper = true;
            return;
          }
          if (!haveRightWrapper) rootChildren.push(componentMap.value[c]);
          else rightWrapperChildren.push(componentMap.value[c]);
        });
        addClass(rootChildren[0], ns.is("first"));
        addClass(rootChildren[rootChildren.length - 1], ns.is("last"));
        if (rightWrapperChildren.length > 0) {
          addClass(rightWrapperChildren[0], ns.is("first"));
          addClass(rightWrapperChildren[rightWrapperChildren.length - 1], ns.is("last"));
          rootChildren.push(rightWrapperRoot);
        }
        return rootChildren;
      });
      const componentMap = Vue.computed(() => ({
        prev: Vue.h(_sfc_main$1k, {
          disabled: props.disabled,
          currentPage: currentPageModel.value,
          prevText: props.prevText,
          prevIcon: props.prevIcon,
          onClick: prev
        }),
        jumper: Vue.h(_sfc_main$1i, {
          size: props.size
        }),
        pager: Vue.h(_sfc_main$1g, {
          currentPage: currentPageModel.value,
          pageCount: pageCountBridge.value,
          pagerCount: props.pagerCount,
          onChange: handleCurrentChange,
          disabled: props.disabled
        }),
        next: Vue.h(_sfc_main$1j, {
          disabled: props.disabled,
          currentPage: currentPageModel.value,
          pageCount: pageCountBridge.value,
          nextText: props.nextText,
          nextIcon: props.nextIcon,
          onClick: next
        }),
        slot: slots?.default?.() ?? null,
        total: Vue.h(_sfc_main$1h, { total: isAbsent(props.total) ? 0 : props.total })
      }));
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("background", __props.background), Vue.unref(ns).m(__props.size)])
          },
          [
            (Vue.openBlock(true), Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(components.value, (component) => {
                return Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(component), { key: component });
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const useFocusTrap = (visible, emit) => {
    const focusStartRef = Vue.ref();
    const onFocusAfterTrapped = () => {
      emit("focus");
    };
    const onFocusAfterReleased = (event) => {
      if (event.detail?.focusReason !== "pointer") {
        focusStartRef.value = "first";
        emit("blur");
      }
    };
    const onFocusInTrap = (event) => {
      if (visible.value && event.target) {
        focusStartRef.value = event.target;
      }
    };
    const onFocusoutPrevented = (event) => {
      if (event.detail.focusReason === "pointer") {
        event.preventDefault();
      }
    };
    const onReleaseRequested = () => {
      emit("close");
    };
    return {
      focusStartRef,
      onFocusAfterTrapped,
      onFocusAfterReleased,
      onFocusInTrap,
      onFocusoutPrevented,
      onReleaseRequested
    };
  };

  var _sfc_main$1e = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "Popover" },
    __name: "index",
    props: /* @__PURE__ */ Vue.mergeModels({
      trigger: { default: "hover" },
      placement: { default: "bottom" },
      content: { default: "" },
      width: {},
      height: {},
      offset: { default: 0 },
      xOffset: { default: 0 },
      yOffset: { default: 0 },
      disabled: { type: Boolean, default: false },
      transition: { type: Boolean, default: true },
      transitionName: {},
      triggerEl: {},
      zIndex: {},
      popperClass: {},
      popperStyle: {},
      beforePopup: { type: Function }
    }, {
      "modelValue": { default: false },
      "modelModifiers": {}
    }),
    emits: /* @__PURE__ */ Vue.mergeModels(["focus", "blur", "close"], ["update:modelValue"]),
    setup(__props, { emit: __emit }) {
      const ns = useNamespace("popover");
      const { nextZIndex } = useZIndex();
      const zIndexRef = Vue.ref(__props.zIndex ?? nextZIndex());
      const visible = Vue.useModel(__props, "modelValue");
      const triggerRef = Vue.ref();
      const popoverRef = Vue.ref();
      const isHovered = useElementHover(triggerRef);
      const popupVisible = useElementHover(popoverRef);
      const triggerElComputed = Vue.computed(() => __props.triggerEl || triggerRef.value);
      const { top, right, left, bottom, update } = usePopoverSize(triggerElComputed, popoverRef, {
        placement: __props.placement,
        offset: __props.offset,
        xOffset: __props.xOffset,
        yOffset: __props.yOffset
      });
      const popupStyle = Vue.computed(() => {
        return {
          zIndex: zIndexRef.value,
          top: addUnit(top.value),
          right: addUnit(right.value),
          bottom: addUnit(bottom.value),
          left: addUnit(left.value),
          width: addUnit(__props.width),
          height: addUnit(__props.height),
          ...__props.popperStyle
        };
      });
      const calculatePopoverPosition = () => {
        if (!triggerRef.value || !popoverRef.value) {
          visible.value = false;
          return;
        }
        update();
        const result = __props.beforePopup?.({
          top: top.value,
          right: right.value,
          bottom: left.value,
          left: bottom.value,
          triggerElement: __props.triggerEl || triggerRef.value,
          popoverElement: popoverRef.value
        }) ?? {};
        if (result.top) top.value = result.top;
        if (result.right) right.value = result.right;
        if (result.bottom) bottom.value = result.bottom;
        if (result.left) left.value = result.left;
      };
      if (__props.trigger === "hover") {
        Vue.watch(isHovered, (newVal) => {
          if (__props.trigger === "hover") visible.value = newVal;
        });
      }
      const toggleVisible = (event) => {
        if (event === __props.trigger) visible.value = !visible.value;
      };
      Vue.watch(visible, (newVal) => {
        if (newVal) calculatePopoverPosition();
      });
      Vue.watch(popupVisible, (newVal) => {
        if (__props.trigger === "hover") visible.value = newVal;
      });
      onClickOutside(popoverRef, (e) => {
        if (e.composedPath().includes(triggerRef.value)) return;
        if (__props.trigger === "hover") return;
        if (visible.value !== false) visible.value = false;
      });
      const popoverContainerId = ns.join("popover-container");
      Vue.onBeforeMount(() => {
        const popoverContainer = document.querySelector(`#${popoverContainerId}`);
        if (!popoverContainer) {
          const container = document.createElement("div");
          container.id = popoverContainerId;
          document.body.appendChild(container);
        }
      });
      const emit = __emit;
      const {
        focusStartRef,
        onFocusAfterTrapped,
        onFocusAfterReleased,
        onFocusInTrap,
        onFocusoutPrevented,
        onReleaseRequested
      } = useFocusTrap(visible, emit);
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          Vue.Fragment,
          null,
          [
            Vue.createElementVNode(
              "div",
              Vue.mergeProps({
                ref_key: "triggerRef",
                ref: triggerRef,
                onClick: _cache[0] || (_cache[0] = ($event) => toggleVisible("click")),
                onContextmenu: _cache[1] || (_cache[1] = ($event) => toggleVisible("contextmenu")),
                onFocus: _cache[2] || (_cache[2] = ($event) => toggleVisible("focus")),
                onTouchstart: _cache[3] || (_cache[3] = ($event) => visible.value = !visible.value)
              }, _ctx.$attrs),
              [
                Vue.renderSlot(_ctx.$slots, "reference")
              ],
              16
              /* FULL_PROPS */
            ),
            (Vue.openBlock(), Vue.createBlock(Vue.Teleport, {
              to: `#${Vue.unref(popoverContainerId)}`
            }, [
              Vue.createVNode(Vue.Transition, {
                name: __props.transition ? __props.transitionName || Vue.unref(ns).join("fade-linear") : ""
              }, {
                default: Vue.withCtx(() => [
                  !__props.disabled ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock(
                    "div",
                    {
                      key: 0,
                      ref_key: "popoverRef",
                      ref: popoverRef,
                      style: Vue.normalizeStyle(popupStyle.value),
                      class: Vue.normalizeClass([Vue.unref(ns).b(), __props.popperClass]),
                      onClick: _cache[4] || (_cache[4] = Vue.withModifiers(() => {
                      }, ["stop"])),
                      onTouchstart: _cache[5] || (_cache[5] = Vue.withModifiers(() => {
                      }, ["stop"]))
                    },
                    [
                      Vue.createVNode(Vue.unref(TkFocusTrap), {
                        loop: "",
                        trapped: visible.value,
                        "focus-trap-el": popoverRef.value,
                        "focus-start-el": Vue.unref(focusStartRef),
                        onFocusAfterTrapped: Vue.unref(onFocusAfterTrapped),
                        onFocusAfterReleased: Vue.unref(onFocusAfterReleased),
                        onFocusin: Vue.unref(onFocusInTrap),
                        onFocusoutPrevented: Vue.unref(onFocusoutPrevented),
                        onReleaseRequested: Vue.unref(onReleaseRequested)
                      }, {
                        default: Vue.withCtx(() => [
                          Vue.renderSlot(_ctx.$slots, "default", {}, () => [
                            Vue.createTextVNode(
                              Vue.toDisplayString(__props.content),
                              1
                              /* TEXT */
                            )
                          ])
                        ]),
                        _: 3
                        /* FORWARDED */
                      }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
                    ],
                    38
                    /* CLASS, STYLE, NEED_HYDRATION */
                  )), [
                    [Vue.vShow, visible.value]
                  ]) : Vue.createCommentVNode("v-if", true)
                ]),
                _: 3
                /* FORWARDED */
              }, 8, ["name"])
            ], 8, ["to"]))
          ],
          64
          /* STABLE_FRAGMENT */
        );
      };
    }
  });

  const _hoisted_1$P = ["title", "disabled"];
  const _hoisted_2$E = ["value", "name", "disabled", "checked", "aria-checked"];
  const _hoisted_3$v = { key: 1 };
  var _sfc_main$1d = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "SegmentedItem" },
    __name: "SegmentedItem",
    props: /* @__PURE__ */ Vue.mergeModels({
      disabled: { type: Boolean },
      value: { type: [String, Number, Object, Boolean] },
      label: {},
      icon: {},
      title: {},
      name: {}
    }, {
      "modelValue": { type: [String, Number, Object, Boolean] },
      "modelModifiers": {}
    }),
    emits: ["update:modelValue"],
    setup(__props) {
      const ns = useNamespace("segmented-item");
      const model = Vue.useModel(__props, "modelValue");
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("label", {
          class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("active", model.value === __props.value && !__props.disabled), Vue.unref(ns).is("disabled", __props.disabled)]),
          title: __props.title,
          disabled: __props.disabled
        }, [
          Vue.withDirectives(Vue.createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => model.value = $event),
            type: "radio",
            value: __props.value,
            name: __props.name,
            disabled: __props.disabled,
            checked: model.value === __props.value,
            "aria-checked": model.value === __props.value,
            role: "radio",
            style: { "display": "none" }
          }, null, 8, _hoisted_2$E), [
            [Vue.vModelRadio, model.value]
          ]),
          Vue.createElementVNode(
            "span",
            {
              class: Vue.normalizeClass(Vue.unref(ns).e("content"))
            },
            [
              __props.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                key: 0,
                icon: __props.icon,
                "aria-hidden": "true"
              }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true),
              __props.label ? (Vue.openBlock(), Vue.createElementBlock(
                "span",
                _hoisted_3$v,
                Vue.toDisplayString(__props.label),
                1
                /* TEXT */
              )) : Vue.createCommentVNode("v-if", true)
            ],
            2
            /* CLASS */
          )
        ], 10, _hoisted_1$P);
      };
    }
  });

  var _sfc_main$1c = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "Segmented" },
    __name: "Segmented",
    props: /* @__PURE__ */ Vue.mergeModels({
      options: {},
      disabled: { type: Boolean }
    }, {
      "modelValue": { type: [String, Number, Object, Boolean] },
      "modelModifiers": {}
    }),
    emits: ["update:modelValue"],
    setup(__props) {
      const ns = useNamespace("segmented");
      const model = Vue.useModel(__props, "modelValue");
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "fieldset",
          {
            class: Vue.normalizeClass(Vue.unref(ns).b())
          },
          [
            (Vue.openBlock(true), Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(__props.options, (option) => {
                return Vue.openBlock(), Vue.createBlock(_sfc_main$1d, Vue.mergeProps({
                  key: option.name,
                  modelValue: model.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => model.value = $event)
                }, { ref_for: true }, option, { disabled: __props.disabled }), null, 16, ["modelValue", "disabled"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  var _sfc_main$1b = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "TitleTag" },
    __name: "index",
    props: {
      text: {},
      type: {},
      position: {},
      size: {}
    },
    setup(__props) {
      const ns = useNamespace("title-tag");
      return (_ctx, _cache) => {
        return __props.text || _ctx.$slots.default ? (Vue.openBlock(), Vue.createElementBlock(
          "span",
          {
            key: 0,
            class: Vue.normalizeClass([Vue.unref(ns).b(), __props.type && Vue.unref(ns).m(__props.type), __props.position && Vue.unref(ns).m(__props.position), __props.size && Vue.unref(ns).m(__props.size)])
          },
          [
            Vue.renderSlot(_ctx.$slots, "default", {}, () => [
              Vue.createTextVNode(
                Vue.toDisplayString(__props.text),
                1
                /* TEXT */
              )
            ])
          ],
          2
          /* CLASS */
        )) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  var _sfc_main$1a = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "TransitionCollapse" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("collapse-transition");
      const reset = (el) => {
        el.style.maxHeight = "";
        el.style.overflow = el.dataset.oldOverflow;
        el.style.paddingTop = el.dataset.oldPaddingTop;
        el.style.paddingBottom = el.dataset.oldPaddingBottom;
      };
      const on = {
        beforeEnter(el) {
          if (!el.dataset) el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          if (el.style.height) el.dataset.elExistsHeight = el.style.height;
          el.style.maxHeight = 0;
          el.style.paddingTop = 0;
          el.style.paddingBottom = 0;
        },
        enter(el) {
          requestAnimationFrame(() => {
            el.dataset.oldOverflow = el.style.overflow;
            if (el.dataset.elExistsHeight) {
              el.style.maxHeight = el.dataset.elExistsHeight;
            } else if (el.scrollHeight !== 0) {
              el.style.maxHeight = `${el.scrollHeight}px`;
            } else {
              el.style.maxHeight = 0;
            }
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
            el.style.overflow = "hidden";
          });
        },
        afterEnter(el) {
          el.style.maxHeight = "";
          el.style.overflow = el.dataset.oldOverflow;
        },
        enterCancelled(el) {
          reset(el);
        },
        beforeLeave(el) {
          if (!el.dataset) el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.dataset.oldOverflow = el.style.overflow;
          el.style.maxHeight = `${el.scrollHeight}px`;
          el.style.overflow = "hidden";
        },
        leave(el) {
          if (el.scrollHeight !== 0) {
            el.style.maxHeight = 0;
            el.style.paddingTop = 0;
            el.style.paddingBottom = 0;
          }
        },
        afterLeave(el) {
          reset(el);
        },
        leaveCancelled(el) {
          reset(el);
        }
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.Transition, Vue.mergeProps({
          name: Vue.unref(ns).b()
        }, Vue.toHandlers(on)), {
          default: Vue.withCtx(() => [
            Vue.renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["name"]);
      };
    }
  });

  const useImageVerify = (width = 120, height = 40) => {
    const domRef = Vue.ref();
    const imgCode = Vue.ref("");
    function setImgCode(code) {
      imgCode.value = code;
    }
    function getImgCode() {
      if (!domRef.value) return;
      imgCode.value = draw(domRef.value, width, height);
    }
    Vue.onMounted(() => {
      getImgCode();
    });
    return {
      domRef,
      imgCode,
      setImgCode,
      getImgCode
    };
  };
  function randomNum(min, max) {
    const num = Math.floor(Math.random() * (max - min) + min);
    return num;
  }
  function randomColor(min, max) {
    const r = randomNum(min, max);
    const g = randomNum(min, max);
    const b = randomNum(min, max);
    return `rgb(${r},${g},${b})`;
  }
  function draw(dom, width, height) {
    let imgCode = "";
    const NUMBER_STRING = "0123456789";
    const ctx = dom.getContext("2d");
    if (!ctx) return imgCode;
    ctx.fillStyle = randomColor(180, 230);
    ctx.fillRect(0, 0, width, height);
    for (let i = 0; i < 4; i += 1) {
      const text = NUMBER_STRING[randomNum(0, NUMBER_STRING.length)];
      imgCode += text;
      const fontSize = randomNum(18, 41);
      const deg = randomNum(-30, 30);
      ctx.font = `${fontSize}px Simhei`;
      ctx.textBaseline = "top";
      ctx.fillStyle = randomColor(80, 150);
      ctx.save();
      ctx.translate(30 * i + 15, 15);
      ctx.rotate(deg * Math.PI / 180);
      ctx.fillText(text, -15 + 5, -15);
      ctx.restore();
    }
    for (let i = 0; i < 5; i += 1) {
      ctx.beginPath();
      ctx.moveTo(randomNum(0, width), randomNum(0, height));
      ctx.lineTo(randomNum(0, width), randomNum(0, height));
      ctx.strokeStyle = randomColor(180, 230);
      ctx.closePath();
      ctx.stroke();
    }
    for (let i = 0; i < 41; i += 1) {
      ctx.beginPath();
      ctx.arc(randomNum(0, width), randomNum(0, height), 1, 0, 2 * Math.PI);
      ctx.closePath();
      ctx.fillStyle = randomColor(150, 200);
      ctx.fill();
    }
    return imgCode;
  }

  var _sfc_main$19 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ImageVerifyCode" },
    __name: "index",
    props: {
      "modelValue": { required: true },
      "modelModifiers": {}
    },
    emits: ["update:modelValue"],
    setup(__props, { expose: __expose }) {
      const { domRef, imgCode, setImgCode, getImgCode } = useImageVerify();
      const code = Vue.useModel(__props, "modelValue");
      Vue.watch(code, (newValue) => {
        setImgCode(newValue);
      });
      Vue.watch(imgCode, (newValue) => {
        code.value = newValue;
      });
      __expose({ getImgCode });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "canvas",
          {
            ref_key: "domRef",
            ref: domRef,
            width: "120",
            height: "40",
            class: "cursor-pointer",
            onClick: _cache[0] || (_cache[0] = //@ts-ignore
            (...args) => Vue.unref(getImgCode) && Vue.unref(getImgCode)(...args))
          },
          null,
          512
          /* NEED_PATCH */
        );
      };
    }
  });

  const _hoisted_1$O = {
    key: 0,
    class: "custom-block-title"
  };
  const _hoisted_2$D = ["innerHTML"];
  const _hoisted_3$u = { key: 1 };
  const _hoisted_4$r = ["innerHTML"];
  var _sfc_main$18 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "VpContainer" },
    __name: "index",
    props: {
      type: { default: "tip" },
      title: {},
      text: { default: "" }
    },
    setup(__props) {
      const ns = useNamespace("vp-container");
      const slots = Vue.useSlots();
      const hasTitle = Vue.computed(() => __props.title || slots.title);
      const hasText = Vue.computed(() => __props.text || slots.default);
      return (_ctx, _cache) => {
        return hasTitle.value || hasText.value ? (Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            key: 0,
            class: Vue.normalizeClass([Vue.unref(ns).b(), "vp-doc"])
          },
          [
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass([__props.type, "custom-block", { "no-title": !__props.title }])
              },
              [
                hasTitle.value ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$O, [
                  Vue.renderSlot(_ctx.$slots, "title", {}, () => [
                    Vue.createElementVNode("span", { innerHTML: __props.title }, null, 8, _hoisted_2$D)
                  ])
                ])) : Vue.createCommentVNode("v-if", true),
                hasText.value ? (Vue.openBlock(), Vue.createElementBlock("p", _hoisted_3$u, [
                  Vue.renderSlot(_ctx.$slots, "default", {}, () => [
                    Vue.createElementVNode("span", { innerHTML: __props.text }, null, 8, _hoisted_4$r)
                  ])
                ])) : Vue.createCommentVNode("v-if", true)
              ],
              2
              /* CLASS */
            )
          ],
          2
          /* CLASS */
        )) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  const emptyPost = {
    allPosts: [],
    originPosts: [],
    sortPostsByDateAndSticky: [],
    sortPostsByDate: [],
    groupPostsByYear: {},
    groupPostsByYearMonth: {},
    groupPosts: { categories: {}, tags: {} },
    groupCards: { categories: [], tags: [] },
    locales: {}
  };

  const postsContext = Symbol("posts");
  const teekConfigContext = Symbol("teekConfig");
  const TeekConfigProvider = (layout) => {
    return Vue.defineComponent({
      name: "TeekConfigProvider",
      setup(_, { slots }) {
        Vue.provide(postsContext, useAllPosts());
        useAnchorScroll().startWatch();
        const { getTeekConfig } = useTeekConfig();
        const viewTransitionConfig = getTeekConfig("viewTransition", {
          enabled: true,
          mode: "out-in",
          easing: "ease-in"
        });
        viewTransitionConfig.enabled && useViewTransition(viewTransitionConfig);
        return () => Vue.h(layout, null, slots);
      }
    });
  };
  const useTeekConfig = () => {
    const { theme, frontmatter } = vitepress.useData();
    const teekConfigProvide = Vue.inject(teekConfigContext, {});
    const getTeekConfig = (key, defaultValue) => {
      let dv = defaultValue;
      if (isFunction(defaultValue)) dv = defaultValue();
      if (!key) {
        return { ...dv, ...theme.value, ...frontmatter.value, ...frontmatter.value.tk, ...Vue.unref(teekConfigProvide) };
      }
      const valueFromTheme = theme.value[key];
      const valueFromFrontmatter = frontmatter.value.tk?.[key] ?? frontmatter.value[key];
      const valueFromInject = Vue.unref(teekConfigProvide)?.[key];
      if (isObject$2(valueFromTheme) || isObject$2(valueFromFrontmatter) || isObject$2(valueFromInject)) {
        return { ...dv, ...valueFromTheme, ...valueFromFrontmatter, ...valueFromInject };
      }
      return valueFromInject ?? valueFromFrontmatter ?? valueFromTheme ?? dv;
    };
    const getTeekConfigRef = (key, defaultValue) => {
      return Vue.computed(() => getTeekConfig(key, defaultValue));
    };
    return { getTeekConfig, getTeekConfigRef };
  };
  const usePageState = () => {
    const { frontmatter } = vitepress.useData();
    const isHomePage = Vue.computed(
      () => !isCategoriesPage.value && !isTagsPage.value && frontmatter.value.layout === "home"
    );
    const isCategoriesPage = Vue.computed(() => !!frontmatter.value.categoriesPage);
    const isTagsPage = Vue.computed(() => !!frontmatter.value.tagsPage);
    const isArchivesPage = Vue.computed(() => !!frontmatter.value.archivesPage);
    const isCataloguePage = Vue.computed(() => !!frontmatter.value.catalogue);
    const isArticleOverviewPage = Vue.computed(() => !!frontmatter.value.articleOverviewPage);
    const isLoginUrl = Vue.computed(() => !!frontmatter.value.loginPage);
    const isRiskLinkPage = Vue.computed(() => !!frontmatter.value.riskLinkPage);
    return {
      isHomePage,
      isCategoriesPage,
      isTagsPage,
      isArchivesPage,
      isCataloguePage,
      isArticleOverviewPage,
      isLoginUrl,
      isRiskLinkPage
    };
  };
  const usePagePath = () => {
    const { getTeekConfigRef } = useTeekConfig();
    const { localeIndex, site } = vitepress.useData();
    const posts = usePosts();
    const categoryConfig = getTeekConfigRef("category", { path: "/categories" });
    const tagConfig = getTeekConfigRef("tag", { path: "/tags" });
    const categoryPath = Vue.computed(() => {
      const localeIndexConst = localeIndex.value;
      const localeName = localeIndexConst !== "root" ? `/${localeIndexConst}` : "";
      return `${localeName}${categoryConfig.value.path}${site.value.cleanUrls ? "" : ".html"}`;
    });
    const tagPath = Vue.computed(() => {
      const localeIndexConst = localeIndex.value;
      const localeName = localeIndexConst !== "root" ? `/${localeIndexConst}` : "";
      return `${localeName}${tagConfig.value.path}${site.value.cleanUrls ? "" : ".html"}`;
    });
    const postPagePath = Vue.computed(() => {
      let archivesUrl = "";
      let articleOverviewUrl = "";
      let loginUrl = "";
      let riskLinkUrl = "";
      posts.value.allPosts.forEach((item) => {
        const {
          frontmatter: { layout, archivesPage, articleOverviewPage, loginPage, riskLinkPage },
          url
        } = item;
        const isPageLayout = layout === "page";
        if (layout === "TkCataloguePage" || isPageLayout && archivesPage === true) archivesUrl = url;
        if (layout === "TkArticleOverviewPage" || isPageLayout && articleOverviewPage === true) {
          articleOverviewUrl = url;
        }
        if (layout === false && loginPage === true) loginUrl = url;
        if (layout === false && riskLinkPage === true) riskLinkUrl = url;
      });
      return { archivesUrl, articleOverviewUrl, loginUrl, riskLinkUrl };
    });
    return {
      categoryPath,
      tagPath,
      archivesPath: Vue.computed(() => postPagePath.value.archivesUrl),
      articleOverviewPath: Vue.computed(() => postPagePath.value.articleOverviewUrl),
      loginPath: Vue.computed(() => postPagePath.value.loginUrl),
      riskLinkPath: Vue.computed(() => postPagePath.value.riskLinkUrl)
    };
  };
  const useAllPosts = () => {
    const { theme } = vitepress.useData();
    const posts = theme.value.posts;
    return posts || emptyPost;
  };
  const usePosts = () => {
    const { localeIndex } = vitepress.useData();
    const posts = useAllPosts();
    return Vue.computed(() => posts.locales?.[localeIndex.value] || posts);
  };
  const useTagColor = () => {
    const { getTeekConfigRef } = useTeekConfig();
    return getTeekConfigRef("tagColor", [
      { border: "#bfdbfe", bg: "#eff6ff", text: "#2563eb" },
      { border: "#e9d5ff", bg: "#faf5ff", text: "#9333ea" },
      { border: "#fbcfe8", bg: "#fdf2f8", text: "#db2777" },
      { border: "#a7f3d0", bg: "#ecfdf5", text: "#059669" },
      { border: "#fde68a", bg: "#fffbeb", text: "#d97706" },
      { border: "#a5f3fc", bg: "#ecfeff", text: "#0891b2" },
      { border: "#c7d2fe", bg: "#eef2ff", text: "#4f46e5" }
    ]);
  };
  const useWindowTransitionConfig = (condition) => {
    const { getTeekConfigRef } = useTeekConfig();
    const windowTransitionConfig = getTeekConfigRef("windowTransition", true);
    return Vue.computed(() => {
      const windowTransition = windowTransitionConfig.value;
      if (windowTransition === void 0) return true;
      return isObject$2(windowTransition) ? condition?.(windowTransition) ?? true : windowTransition !== false;
    });
  };
  const useCommon = () => {
    const isMobile = useMediaQuery("(max-width: 768px)");
    return { isMobile };
  };
  const useSidebar = () => {
    const hasSidebar = Vue.ref(true);
    const route = vitepress.useRoute();
    Vue.watch(
      () => route.path,
      async () => {
        if (!isClient) return;
        await Vue.nextTick();
        const sidebarDom = document.querySelector(".VPSidebar");
        if (sidebarDom) hasSidebar.value = true;
        else hasSidebar.value = false;
      },
      { immediate: true, flush: "post" }
    );
    return { hasSidebar };
  };

  /**
  * @vue/shared v3.5.22
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  // @__NO_SIDE_EFFECTS__
  function makeMap(str) {
    const map = /* @__PURE__ */ Object.create(null);
    for (const key of str.split(",")) map[key] = 1;
    return (val) => val in map;
  }

  const EMPTY_OBJ = !!(process.env.NODE_ENV !== "production") ? Object.freeze({}) : {};
  !!(process.env.NODE_ENV !== "production") ? Object.freeze([]) : [];
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const extend$1 = Object.assign;
  const isArray = Array.isArray;
  const isString = (val) => typeof val === "string";
  const isSymbol = (val) => typeof val === "symbol";
  const isObject$1 = (val) => val !== null && typeof val === "object";
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const isBuiltInDirective = /* @__PURE__ */ makeMap(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  );
  const cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return ((str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    });
  };
  const camelizeRE = /-\w/g;
  const camelize = cacheStringFunction(
    (str) => {
      return str.replace(camelizeRE, (c) => c.slice(1).toUpperCase());
    }
  );
  const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction(
    (str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    }
  );
  const PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `NEED_HYDRATION`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `CACHED`,
    [-2]: `BAIL`
  };
  const slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
  };
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }

  const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
  const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
  const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
  const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);

  /**
  * @vue/compiler-core v3.5.22
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/

  const FRAGMENT = Symbol(!!(process.env.NODE_ENV !== "production") ? `Fragment` : ``);
  const TELEPORT = Symbol(!!(process.env.NODE_ENV !== "production") ? `Teleport` : ``);
  const SUSPENSE = Symbol(!!(process.env.NODE_ENV !== "production") ? `Suspense` : ``);
  const KEEP_ALIVE = Symbol(!!(process.env.NODE_ENV !== "production") ? `KeepAlive` : ``);
  const BASE_TRANSITION = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `BaseTransition` : ``
  );
  const OPEN_BLOCK = Symbol(!!(process.env.NODE_ENV !== "production") ? `openBlock` : ``);
  const CREATE_BLOCK = Symbol(!!(process.env.NODE_ENV !== "production") ? `createBlock` : ``);
  const CREATE_ELEMENT_BLOCK = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `createElementBlock` : ``
  );
  const CREATE_VNODE = Symbol(!!(process.env.NODE_ENV !== "production") ? `createVNode` : ``);
  const CREATE_ELEMENT_VNODE = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `createElementVNode` : ``
  );
  const CREATE_COMMENT = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `createCommentVNode` : ``
  );
  const CREATE_TEXT = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `createTextVNode` : ``
  );
  const CREATE_STATIC = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `createStaticVNode` : ``
  );
  const RESOLVE_COMPONENT = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `resolveComponent` : ``
  );
  const RESOLVE_DYNAMIC_COMPONENT = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `resolveDynamicComponent` : ``
  );
  const RESOLVE_DIRECTIVE = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `resolveDirective` : ``
  );
  const RESOLVE_FILTER = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `resolveFilter` : ``
  );
  const WITH_DIRECTIVES = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `withDirectives` : ``
  );
  const RENDER_LIST = Symbol(!!(process.env.NODE_ENV !== "production") ? `renderList` : ``);
  const RENDER_SLOT = Symbol(!!(process.env.NODE_ENV !== "production") ? `renderSlot` : ``);
  const CREATE_SLOTS = Symbol(!!(process.env.NODE_ENV !== "production") ? `createSlots` : ``);
  const TO_DISPLAY_STRING = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `toDisplayString` : ``
  );
  const MERGE_PROPS = Symbol(!!(process.env.NODE_ENV !== "production") ? `mergeProps` : ``);
  const NORMALIZE_CLASS = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `normalizeClass` : ``
  );
  const NORMALIZE_STYLE = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `normalizeStyle` : ``
  );
  const NORMALIZE_PROPS = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `normalizeProps` : ``
  );
  const GUARD_REACTIVE_PROPS = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `guardReactiveProps` : ``
  );
  const TO_HANDLERS = Symbol(!!(process.env.NODE_ENV !== "production") ? `toHandlers` : ``);
  const CAMELIZE = Symbol(!!(process.env.NODE_ENV !== "production") ? `camelize` : ``);
  const CAPITALIZE = Symbol(!!(process.env.NODE_ENV !== "production") ? `capitalize` : ``);
  const TO_HANDLER_KEY = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `toHandlerKey` : ``
  );
  const SET_BLOCK_TRACKING = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `setBlockTracking` : ``
  );
  const PUSH_SCOPE_ID = Symbol(!!(process.env.NODE_ENV !== "production") ? `pushScopeId` : ``);
  const POP_SCOPE_ID = Symbol(!!(process.env.NODE_ENV !== "production") ? `popScopeId` : ``);
  const WITH_CTX = Symbol(!!(process.env.NODE_ENV !== "production") ? `withCtx` : ``);
  const UNREF = Symbol(!!(process.env.NODE_ENV !== "production") ? `unref` : ``);
  const IS_REF = Symbol(!!(process.env.NODE_ENV !== "production") ? `isRef` : ``);
  const WITH_MEMO = Symbol(!!(process.env.NODE_ENV !== "production") ? `withMemo` : ``);
  const IS_MEMO_SAME = Symbol(!!(process.env.NODE_ENV !== "production") ? `isMemoSame` : ``);
  const helperNameMap = {
    [FRAGMENT]: `Fragment`,
    [TELEPORT]: `Teleport`,
    [SUSPENSE]: `Suspense`,
    [KEEP_ALIVE]: `KeepAlive`,
    [BASE_TRANSITION]: `BaseTransition`,
    [OPEN_BLOCK]: `openBlock`,
    [CREATE_BLOCK]: `createBlock`,
    [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
    [CREATE_VNODE]: `createVNode`,
    [CREATE_ELEMENT_VNODE]: `createElementVNode`,
    [CREATE_COMMENT]: `createCommentVNode`,
    [CREATE_TEXT]: `createTextVNode`,
    [CREATE_STATIC]: `createStaticVNode`,
    [RESOLVE_COMPONENT]: `resolveComponent`,
    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
    [RESOLVE_DIRECTIVE]: `resolveDirective`,
    [RESOLVE_FILTER]: `resolveFilter`,
    [WITH_DIRECTIVES]: `withDirectives`,
    [RENDER_LIST]: `renderList`,
    [RENDER_SLOT]: `renderSlot`,
    [CREATE_SLOTS]: `createSlots`,
    [TO_DISPLAY_STRING]: `toDisplayString`,
    [MERGE_PROPS]: `mergeProps`,
    [NORMALIZE_CLASS]: `normalizeClass`,
    [NORMALIZE_STYLE]: `normalizeStyle`,
    [NORMALIZE_PROPS]: `normalizeProps`,
    [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
    [TO_HANDLERS]: `toHandlers`,
    [CAMELIZE]: `camelize`,
    [CAPITALIZE]: `capitalize`,
    [TO_HANDLER_KEY]: `toHandlerKey`,
    [SET_BLOCK_TRACKING]: `setBlockTracking`,
    [PUSH_SCOPE_ID]: `pushScopeId`,
    [POP_SCOPE_ID]: `popScopeId`,
    [WITH_CTX]: `withCtx`,
    [UNREF]: `unref`,
    [IS_REF]: `isRef`,
    [WITH_MEMO]: `withMemo`,
    [IS_MEMO_SAME]: `isMemoSame`
  };
  function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach((s) => {
      helperNameMap[s] = helpers[s];
    });
  }
  const locStub = {
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 },
    source: ""
  };
  function createRoot(children, source = "") {
    return {
      type: 0,
      source,
      children,
      helpers: /* @__PURE__ */ new Set(),
      components: [],
      directives: [],
      hoists: [],
      imports: [],
      cached: [],
      temps: 0,
      codegenNode: void 0,
      loc: locStub
    };
  }
  function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
    if (context) {
      if (isBlock) {
        context.helper(OPEN_BLOCK);
        context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
      } else {
        context.helper(getVNodeHelper(context.inSSR, isComponent));
      }
      if (directives) {
        context.helper(WITH_DIRECTIVES);
      }
    }
    return {
      type: 13,
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives,
      isBlock,
      disableTracking,
      isComponent,
      loc
    };
  }
  function createArrayExpression(elements, loc = locStub) {
    return {
      type: 17,
      loc,
      elements
    };
  }
  function createObjectExpression(properties, loc = locStub) {
    return {
      type: 15,
      loc,
      properties
    };
  }
  function createObjectProperty(key, value) {
    return {
      type: 16,
      loc: locStub,
      key: isString(key) ? createSimpleExpression(key, true) : key,
      value
    };
  }
  function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
    return {
      type: 4,
      loc,
      content,
      isStatic,
      constType: isStatic ? 3 : constType
    };
  }
  function createCompoundExpression(children, loc = locStub) {
    return {
      type: 8,
      loc,
      children
    };
  }
  function createCallExpression(callee, args = [], loc = locStub) {
    return {
      type: 14,
      loc,
      callee,
      arguments: args
    };
  }
  function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
    return {
      type: 18,
      params,
      returns,
      newline,
      isSlot,
      loc
    };
  }
  function createConditionalExpression(test, consequent, alternate, newline = true) {
    return {
      type: 19,
      test,
      consequent,
      alternate,
      newline,
      loc: locStub
    };
  }
  function createCacheExpression(index, value, needPauseTracking = false, inVOnce = false) {
    return {
      type: 20,
      index,
      value,
      needPauseTracking,
      inVOnce,
      needArraySpread: false,
      loc: locStub
    };
  }
  function createBlockStatement(body) {
    return {
      type: 21,
      body,
      loc: locStub
    };
  }
  function getVNodeHelper(ssr, isComponent) {
    return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
  }
  function getVNodeBlockHelper(ssr, isComponent) {
    return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
  }
  function convertToBlock(node, { helper, removeHelper, inSSR }) {
    if (!node.isBlock) {
      node.isBlock = true;
      removeHelper(getVNodeHelper(inSSR, node.isComponent));
      helper(OPEN_BLOCK);
      helper(getVNodeBlockHelper(inSSR, node.isComponent));
    }
  }

  const defaultDelimitersOpen = new Uint8Array([123, 123]);
  const defaultDelimitersClose = new Uint8Array([125, 125]);
  function isTagStartChar(c) {
    return c >= 97 && c <= 122 || c >= 65 && c <= 90;
  }
  function isWhitespace$1(c) {
    return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
  }
  function isEndOfTagSection(c) {
    return c === 47 || c === 62 || isWhitespace$1(c);
  }
  function toCharCodes(str) {
    const ret = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
      ret[i] = str.charCodeAt(i);
    }
    return ret;
  }
  const Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    // CDATA[
    CdataEnd: new Uint8Array([93, 93, 62]),
    // ]]>
    CommentEnd: new Uint8Array([45, 45, 62]),
    // `-->`
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    // `<\/script`
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    // `</style`
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
    // `</title`
    TextareaEnd: new Uint8Array([
      60,
      47,
      116,
      101,
      120,
      116,
      97,
      114,
      101,
      97
    ])
    // `</textarea
  };
  class Tokenizer {
    constructor(stack, cbs) {
      this.stack = stack;
      this.cbs = cbs;
      /** The current state the tokenizer is in. */
      this.state = 1;
      /** The read buffer. */
      this.buffer = "";
      /** The beginning of the section that is currently being read. */
      this.sectionStart = 0;
      /** The index within the buffer that we are currently looking at. */
      this.index = 0;
      /** The start of the last entity. */
      this.entityStart = 0;
      /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
      this.baseState = 1;
      /** For special parsing behavior inside of script and style tags. */
      this.inRCDATA = false;
      /** For disabling RCDATA tags handling */
      this.inXML = false;
      /** For disabling interpolation parsing in v-pre */
      this.inVPre = false;
      /** Record newline positions for fast line / column calculation */
      this.newlines = [];
      this.mode = 0;
      this.delimiterOpen = defaultDelimitersOpen;
      this.delimiterClose = defaultDelimitersClose;
      this.delimiterIndex = -1;
      this.currentSequence = void 0;
      this.sequenceIndex = 0;
    }
    get inSFCRoot() {
      return this.mode === 2 && this.stack.length === 0;
    }
    reset() {
      this.state = 1;
      this.mode = 0;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.baseState = 1;
      this.inRCDATA = false;
      this.currentSequence = void 0;
      this.newlines.length = 0;
      this.delimiterOpen = defaultDelimitersOpen;
      this.delimiterClose = defaultDelimitersClose;
    }
    /**
     * Generate Position object with line / column information using recorded
     * newline positions. We know the index is always going to be an already
     * processed index, so all the newlines up to this index should have been
     * recorded.
     */
    getPos(index) {
      let line = 1;
      let column = index + 1;
      for (let i = this.newlines.length - 1; i >= 0; i--) {
        const newlineIndex = this.newlines[i];
        if (index > newlineIndex) {
          line = i + 2;
          column = index - newlineIndex;
          break;
        }
      }
      return {
        column,
        line,
        offset: index
      };
    }
    peek() {
      return this.buffer.charCodeAt(this.index + 1);
    }
    stateText(c) {
      if (c === 60) {
        if (this.index > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, this.index);
        }
        this.state = 5;
        this.sectionStart = this.index;
      } else if (!this.inVPre && c === this.delimiterOpen[0]) {
        this.state = 2;
        this.delimiterIndex = 0;
        this.stateInterpolationOpen(c);
      }
    }
    stateInterpolationOpen(c) {
      if (c === this.delimiterOpen[this.delimiterIndex]) {
        if (this.delimiterIndex === this.delimiterOpen.length - 1) {
          const start = this.index + 1 - this.delimiterOpen.length;
          if (start > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, start);
          }
          this.state = 3;
          this.sectionStart = start;
        } else {
          this.delimiterIndex++;
        }
      } else if (this.inRCDATA) {
        this.state = 32;
        this.stateInRCDATA(c);
      } else {
        this.state = 1;
        this.stateText(c);
      }
    }
    stateInterpolation(c) {
      if (c === this.delimiterClose[0]) {
        this.state = 4;
        this.delimiterIndex = 0;
        this.stateInterpolationClose(c);
      }
    }
    stateInterpolationClose(c) {
      if (c === this.delimiterClose[this.delimiterIndex]) {
        if (this.delimiterIndex === this.delimiterClose.length - 1) {
          this.cbs.oninterpolation(this.sectionStart, this.index + 1);
          if (this.inRCDATA) {
            this.state = 32;
          } else {
            this.state = 1;
          }
          this.sectionStart = this.index + 1;
        } else {
          this.delimiterIndex++;
        }
      } else {
        this.state = 3;
        this.stateInterpolation(c);
      }
    }
    stateSpecialStartSequence(c) {
      const isEnd = this.sequenceIndex === this.currentSequence.length;
      const isMatch = isEnd ? (
        // If we are at the end of the sequence, make sure the tag name has ended
        isEndOfTagSection(c)
      ) : (
        // Otherwise, do a case-insensitive comparison
        (c | 32) === this.currentSequence[this.sequenceIndex]
      );
      if (!isMatch) {
        this.inRCDATA = false;
      } else if (!isEnd) {
        this.sequenceIndex++;
        return;
      }
      this.sequenceIndex = 0;
      this.state = 6;
      this.stateInTagName(c);
    }
    /** Look for an end tag. For <title> and <textarea>, also decode entities. */
    stateInRCDATA(c) {
      if (this.sequenceIndex === this.currentSequence.length) {
        if (c === 62 || isWhitespace$1(c)) {
          const endOfText = this.index - this.currentSequence.length;
          if (this.sectionStart < endOfText) {
            const actualIndex = this.index;
            this.index = endOfText;
            this.cbs.ontext(this.sectionStart, endOfText);
            this.index = actualIndex;
          }
          this.sectionStart = endOfText + 2;
          this.stateInClosingTagName(c);
          this.inRCDATA = false;
          return;
        }
        this.sequenceIndex = 0;
      }
      if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
        this.sequenceIndex += 1;
      } else if (this.sequenceIndex === 0) {
        if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
          if (!this.inVPre && c === this.delimiterOpen[0]) {
            this.state = 2;
            this.delimiterIndex = 0;
            this.stateInterpolationOpen(c);
          }
        } else if (this.fastForwardTo(60)) {
          this.sequenceIndex = 1;
        }
      } else {
        this.sequenceIndex = Number(c === 60);
      }
    }
    stateCDATASequence(c) {
      if (c === Sequences.Cdata[this.sequenceIndex]) {
        if (++this.sequenceIndex === Sequences.Cdata.length) {
          this.state = 28;
          this.currentSequence = Sequences.CdataEnd;
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
        }
      } else {
        this.sequenceIndex = 0;
        this.state = 23;
        this.stateInDeclaration(c);
      }
    }
    /**
     * When we wait for one specific character, we can speed things up
     * by skipping through the buffer until we find it.
     *
     * @returns Whether the character was found.
     */
    fastForwardTo(c) {
      while (++this.index < this.buffer.length) {
        const cc = this.buffer.charCodeAt(this.index);
        if (cc === 10) {
          this.newlines.push(this.index);
        }
        if (cc === c) {
          return true;
        }
      }
      this.index = this.buffer.length - 1;
      return false;
    }
    /**
     * Comments and CDATA end with `-->` and `]]>`.
     *
     * Their common qualities are:
     * - Their end sequences have a distinct character they start with.
     * - That character is then repeated, so we have to check multiple repeats.
     * - All characters but the start character of the sequence can be skipped.
     */
    stateInCommentLike(c) {
      if (c === this.currentSequence[this.sequenceIndex]) {
        if (++this.sequenceIndex === this.currentSequence.length) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, this.index - 2);
          } else {
            this.cbs.oncomment(this.sectionStart, this.index - 2);
          }
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
          this.state = 1;
        }
      } else if (this.sequenceIndex === 0) {
        if (this.fastForwardTo(this.currentSequence[0])) {
          this.sequenceIndex = 1;
        }
      } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
        this.sequenceIndex = 0;
      }
    }
    startSpecial(sequence, offset) {
      this.enterRCDATA(sequence, offset);
      this.state = 31;
    }
    enterRCDATA(sequence, offset) {
      this.inRCDATA = true;
      this.currentSequence = sequence;
      this.sequenceIndex = offset;
    }
    stateBeforeTagName(c) {
      if (c === 33) {
        this.state = 22;
        this.sectionStart = this.index + 1;
      } else if (c === 63) {
        this.state = 24;
        this.sectionStart = this.index + 1;
      } else if (isTagStartChar(c)) {
        this.sectionStart = this.index;
        if (this.mode === 0) {
          this.state = 6;
        } else if (this.inSFCRoot) {
          this.state = 34;
        } else if (!this.inXML) {
          if (c === 116) {
            this.state = 30;
          } else {
            this.state = c === 115 ? 29 : 6;
          }
        } else {
          this.state = 6;
        }
      } else if (c === 47) {
        this.state = 8;
      } else {
        this.state = 1;
        this.stateText(c);
      }
    }
    stateInTagName(c) {
      if (isEndOfTagSection(c)) {
        this.handleTagName(c);
      }
    }
    stateInSFCRootTagName(c) {
      if (isEndOfTagSection(c)) {
        const tag = this.buffer.slice(this.sectionStart, this.index);
        if (tag !== "template") {
          this.enterRCDATA(toCharCodes(`</` + tag), 0);
        }
        this.handleTagName(c);
      }
    }
    handleTagName(c) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = 11;
      this.stateBeforeAttrName(c);
    }
    stateBeforeClosingTagName(c) {
      if (isWhitespace$1(c)) ; else if (c === 62) {
        if (!!(process.env.NODE_ENV !== "production") || false) {
          this.cbs.onerr(14, this.index);
        }
        this.state = 1;
        this.sectionStart = this.index + 1;
      } else {
        this.state = isTagStartChar(c) ? 9 : 27;
        this.sectionStart = this.index;
      }
    }
    stateInClosingTagName(c) {
      if (c === 62 || isWhitespace$1(c)) {
        this.cbs.onclosetag(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = 10;
        this.stateAfterClosingTagName(c);
      }
    }
    stateAfterClosingTagName(c) {
      if (c === 62) {
        this.state = 1;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeAttrName(c) {
      if (c === 62) {
        this.cbs.onopentagend(this.index);
        if (this.inRCDATA) {
          this.state = 32;
        } else {
          this.state = 1;
        }
        this.sectionStart = this.index + 1;
      } else if (c === 47) {
        this.state = 7;
        if ((!!(process.env.NODE_ENV !== "production") || false) && this.peek() !== 62) {
          this.cbs.onerr(22, this.index);
        }
      } else if (c === 60 && this.peek() === 47) {
        this.cbs.onopentagend(this.index);
        this.state = 5;
        this.sectionStart = this.index;
      } else if (!isWhitespace$1(c)) {
        if ((!!(process.env.NODE_ENV !== "production") || false) && c === 61) {
          this.cbs.onerr(
            19,
            this.index
          );
        }
        this.handleAttrStart(c);
      }
    }
    handleAttrStart(c) {
      if (c === 118 && this.peek() === 45) {
        this.state = 13;
        this.sectionStart = this.index;
      } else if (c === 46 || c === 58 || c === 64 || c === 35) {
        this.cbs.ondirname(this.index, this.index + 1);
        this.state = 14;
        this.sectionStart = this.index + 1;
      } else {
        this.state = 12;
        this.sectionStart = this.index;
      }
    }
    stateInSelfClosingTag(c) {
      if (c === 62) {
        this.cbs.onselfclosingtag(this.index);
        this.state = 1;
        this.sectionStart = this.index + 1;
        this.inRCDATA = false;
      } else if (!isWhitespace$1(c)) {
        this.state = 11;
        this.stateBeforeAttrName(c);
      }
    }
    stateInAttrName(c) {
      if (c === 61 || isEndOfTagSection(c)) {
        this.cbs.onattribname(this.sectionStart, this.index);
        this.handleAttrNameEnd(c);
      } else if ((!!(process.env.NODE_ENV !== "production") || false) && (c === 34 || c === 39 || c === 60)) {
        this.cbs.onerr(
          17,
          this.index
        );
      }
    }
    stateInDirName(c) {
      if (c === 61 || isEndOfTagSection(c)) {
        this.cbs.ondirname(this.sectionStart, this.index);
        this.handleAttrNameEnd(c);
      } else if (c === 58) {
        this.cbs.ondirname(this.sectionStart, this.index);
        this.state = 14;
        this.sectionStart = this.index + 1;
      } else if (c === 46) {
        this.cbs.ondirname(this.sectionStart, this.index);
        this.state = 16;
        this.sectionStart = this.index + 1;
      }
    }
    stateInDirArg(c) {
      if (c === 61 || isEndOfTagSection(c)) {
        this.cbs.ondirarg(this.sectionStart, this.index);
        this.handleAttrNameEnd(c);
      } else if (c === 91) {
        this.state = 15;
      } else if (c === 46) {
        this.cbs.ondirarg(this.sectionStart, this.index);
        this.state = 16;
        this.sectionStart = this.index + 1;
      }
    }
    stateInDynamicDirArg(c) {
      if (c === 93) {
        this.state = 14;
      } else if (c === 61 || isEndOfTagSection(c)) {
        this.cbs.ondirarg(this.sectionStart, this.index + 1);
        this.handleAttrNameEnd(c);
        if (!!(process.env.NODE_ENV !== "production") || false) {
          this.cbs.onerr(
            27,
            this.index
          );
        }
      }
    }
    stateInDirModifier(c) {
      if (c === 61 || isEndOfTagSection(c)) {
        this.cbs.ondirmodifier(this.sectionStart, this.index);
        this.handleAttrNameEnd(c);
      } else if (c === 46) {
        this.cbs.ondirmodifier(this.sectionStart, this.index);
        this.sectionStart = this.index + 1;
      }
    }
    handleAttrNameEnd(c) {
      this.sectionStart = this.index;
      this.state = 17;
      this.cbs.onattribnameend(this.index);
      this.stateAfterAttrName(c);
    }
    stateAfterAttrName(c) {
      if (c === 61) {
        this.state = 18;
      } else if (c === 47 || c === 62) {
        this.cbs.onattribend(0, this.sectionStart);
        this.sectionStart = -1;
        this.state = 11;
        this.stateBeforeAttrName(c);
      } else if (!isWhitespace$1(c)) {
        this.cbs.onattribend(0, this.sectionStart);
        this.handleAttrStart(c);
      }
    }
    stateBeforeAttrValue(c) {
      if (c === 34) {
        this.state = 19;
        this.sectionStart = this.index + 1;
      } else if (c === 39) {
        this.state = 20;
        this.sectionStart = this.index + 1;
      } else if (!isWhitespace$1(c)) {
        this.sectionStart = this.index;
        this.state = 21;
        this.stateInAttrValueNoQuotes(c);
      }
    }
    handleInAttrValue(c, quote) {
      if (c === quote || this.fastForwardTo(quote)) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(
          quote === 34 ? 3 : 2,
          this.index + 1
        );
        this.state = 11;
      }
    }
    stateInAttrValueDoubleQuotes(c) {
      this.handleInAttrValue(c, 34);
    }
    stateInAttrValueSingleQuotes(c) {
      this.handleInAttrValue(c, 39);
    }
    stateInAttrValueNoQuotes(c) {
      if (isWhitespace$1(c) || c === 62) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(1, this.index);
        this.state = 11;
        this.stateBeforeAttrName(c);
      } else if ((!!(process.env.NODE_ENV !== "production") || false) && c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
        this.cbs.onerr(
          18,
          this.index
        );
      } else ;
    }
    stateBeforeDeclaration(c) {
      if (c === 91) {
        this.state = 26;
        this.sequenceIndex = 0;
      } else {
        this.state = c === 45 ? 25 : 23;
      }
    }
    stateInDeclaration(c) {
      if (c === 62 || this.fastForwardTo(62)) {
        this.state = 1;
        this.sectionStart = this.index + 1;
      }
    }
    stateInProcessingInstruction(c) {
      if (c === 62 || this.fastForwardTo(62)) {
        this.cbs.onprocessinginstruction(this.sectionStart, this.index);
        this.state = 1;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeComment(c) {
      if (c === 45) {
        this.state = 28;
        this.currentSequence = Sequences.CommentEnd;
        this.sequenceIndex = 2;
        this.sectionStart = this.index + 1;
      } else {
        this.state = 23;
      }
    }
    stateInSpecialComment(c) {
      if (c === 62 || this.fastForwardTo(62)) {
        this.cbs.oncomment(this.sectionStart, this.index);
        this.state = 1;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeSpecialS(c) {
      if (c === Sequences.ScriptEnd[3]) {
        this.startSpecial(Sequences.ScriptEnd, 4);
      } else if (c === Sequences.StyleEnd[3]) {
        this.startSpecial(Sequences.StyleEnd, 4);
      } else {
        this.state = 6;
        this.stateInTagName(c);
      }
    }
    stateBeforeSpecialT(c) {
      if (c === Sequences.TitleEnd[3]) {
        this.startSpecial(Sequences.TitleEnd, 4);
      } else if (c === Sequences.TextareaEnd[3]) {
        this.startSpecial(Sequences.TextareaEnd, 4);
      } else {
        this.state = 6;
        this.stateInTagName(c);
      }
    }
    startEntity() {
    }
    stateInEntity() {
    }
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */
    parse(input) {
      this.buffer = input;
      while (this.index < this.buffer.length) {
        const c = this.buffer.charCodeAt(this.index);
        if (c === 10 && this.state !== 33) {
          this.newlines.push(this.index);
        }
        switch (this.state) {
          case 1: {
            this.stateText(c);
            break;
          }
          case 2: {
            this.stateInterpolationOpen(c);
            break;
          }
          case 3: {
            this.stateInterpolation(c);
            break;
          }
          case 4: {
            this.stateInterpolationClose(c);
            break;
          }
          case 31: {
            this.stateSpecialStartSequence(c);
            break;
          }
          case 32: {
            this.stateInRCDATA(c);
            break;
          }
          case 26: {
            this.stateCDATASequence(c);
            break;
          }
          case 19: {
            this.stateInAttrValueDoubleQuotes(c);
            break;
          }
          case 12: {
            this.stateInAttrName(c);
            break;
          }
          case 13: {
            this.stateInDirName(c);
            break;
          }
          case 14: {
            this.stateInDirArg(c);
            break;
          }
          case 15: {
            this.stateInDynamicDirArg(c);
            break;
          }
          case 16: {
            this.stateInDirModifier(c);
            break;
          }
          case 28: {
            this.stateInCommentLike(c);
            break;
          }
          case 27: {
            this.stateInSpecialComment(c);
            break;
          }
          case 11: {
            this.stateBeforeAttrName(c);
            break;
          }
          case 6: {
            this.stateInTagName(c);
            break;
          }
          case 34: {
            this.stateInSFCRootTagName(c);
            break;
          }
          case 9: {
            this.stateInClosingTagName(c);
            break;
          }
          case 5: {
            this.stateBeforeTagName(c);
            break;
          }
          case 17: {
            this.stateAfterAttrName(c);
            break;
          }
          case 20: {
            this.stateInAttrValueSingleQuotes(c);
            break;
          }
          case 18: {
            this.stateBeforeAttrValue(c);
            break;
          }
          case 8: {
            this.stateBeforeClosingTagName(c);
            break;
          }
          case 10: {
            this.stateAfterClosingTagName(c);
            break;
          }
          case 29: {
            this.stateBeforeSpecialS(c);
            break;
          }
          case 30: {
            this.stateBeforeSpecialT(c);
            break;
          }
          case 21: {
            this.stateInAttrValueNoQuotes(c);
            break;
          }
          case 7: {
            this.stateInSelfClosingTag(c);
            break;
          }
          case 23: {
            this.stateInDeclaration(c);
            break;
          }
          case 22: {
            this.stateBeforeDeclaration(c);
            break;
          }
          case 25: {
            this.stateBeforeComment(c);
            break;
          }
          case 24: {
            this.stateInProcessingInstruction(c);
            break;
          }
          case 33: {
            this.stateInEntity();
            break;
          }
        }
        this.index++;
      }
      this.cleanup();
      this.finish();
    }
    /**
     * Remove data that has already been consumed from the buffer.
     */
    cleanup() {
      if (this.sectionStart !== this.index) {
        if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
          this.cbs.ontext(this.sectionStart, this.index);
          this.sectionStart = this.index;
        } else if (this.state === 19 || this.state === 20 || this.state === 21) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = this.index;
        }
      }
    }
    finish() {
      this.handleTrailingData();
      this.cbs.onend();
    }
    /** Handle any trailing data. */
    handleTrailingData() {
      const endIndex = this.buffer.length;
      if (this.sectionStart >= endIndex) {
        return;
      }
      if (this.state === 28) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, endIndex);
        } else {
          this.cbs.oncomment(this.sectionStart, endIndex);
        }
      } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ; else {
        this.cbs.ontext(this.sectionStart, endIndex);
      }
    }
    emitCodePoint(cp, consumed) {
    }
  }
  const deprecationData = {
    ["COMPILER_IS_ON_ELEMENT"]: {
      message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
      link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
    },
    ["COMPILER_V_BIND_SYNC"]: {
      message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
      link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
    },
    ["COMPILER_V_BIND_OBJECT_ORDER"]: {
      message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
      link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
    },
    ["COMPILER_V_ON_NATIVE"]: {
      message: `.native modifier for v-on has been removed as is no longer necessary.`,
      link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
    },
    ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
      message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
      link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
    },
    ["COMPILER_NATIVE_TEMPLATE"]: {
      message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
    },
    ["COMPILER_INLINE_TEMPLATE"]: {
      message: `"inline-template" has been removed in Vue 3.`,
      link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
    },
    ["COMPILER_FILTERS"]: {
      message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
      link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
    }
  };
  function getCompatValue(key, { compatConfig }) {
    const value = compatConfig && compatConfig[key];
    if (key === "MODE") {
      return value || 3;
    } else {
      return value;
    }
  }
  function isCompatEnabled(key, context) {
    const mode = getCompatValue("MODE", context);
    const value = getCompatValue(key, context);
    return mode === 3 ? value === true : value !== false;
  }
  function checkCompatEnabled(key, context, loc, ...args) {
    const enabled = isCompatEnabled(key, context);
    if (!!(process.env.NODE_ENV !== "production") && enabled) {
      warnDeprecation(key, context, loc, ...args);
    }
    return enabled;
  }
  function warnDeprecation(key, context, loc, ...args) {
    const val = getCompatValue(key, context);
    if (val === "suppress-warning") {
      return;
    }
    const { message, link } = deprecationData[key];
    const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
    const err = new SyntaxError(msg);
    err.code = key;
    if (loc) err.loc = loc;
    context.onWarn(err);
  }

  function defaultOnError(error) {
    throw error;
  }
  function defaultOnWarn(msg) {
    !!(process.env.NODE_ENV !== "production") && console.warn(`[Vue warn] ${msg.message}`);
  }
  function createCompilerError(code, loc, messages, additionalMessage) {
    const msg = !!(process.env.NODE_ENV !== "production") || false ? (messages || errorMessages)[code] + (additionalMessage || ``) : `https://vuejs.org/error-reference/#compiler-${code}`;
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
  }
  const errorMessages = {
    // parse errors
    [0]: "Illegal comment.",
    [1]: "CDATA section is allowed only in XML context.",
    [2]: "Duplicate attribute.",
    [3]: "End tag cannot have attributes.",
    [4]: "Illegal '/' in tags.",
    [5]: "Unexpected EOF in tag.",
    [6]: "Unexpected EOF in CDATA section.",
    [7]: "Unexpected EOF in comment.",
    [8]: "Unexpected EOF in script.",
    [9]: "Unexpected EOF in tag.",
    [10]: "Incorrectly closed comment.",
    [11]: "Incorrectly opened comment.",
    [12]: "Illegal tag name. Use '&lt;' to print '<'.",
    [13]: "Attribute value was expected.",
    [14]: "End tag name was expected.",
    [15]: "Whitespace was expected.",
    [16]: "Unexpected '<!--' in comment.",
    [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
    [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
    [19]: "Attribute name cannot start with '='.",
    [21]: "'<?' is allowed only in XML context.",
    [20]: `Unexpected null character.`,
    [22]: "Illegal '/' in tags.",
    // Vue-specific parse errors
    [23]: "Invalid end tag.",
    [24]: "Element is missing end tag.",
    [25]: "Interpolation end sign was not found.",
    [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
    [26]: "Legal directive name was expected.",
    // transform errors
    [28]: `v-if/v-else-if is missing expression.`,
    [29]: `v-if/else branches must use unique keys.`,
    [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
    [31]: `v-for is missing expression.`,
    [32]: `v-for has invalid expression.`,
    [33]: `<template v-for> key should be placed on the <template> tag.`,
    [34]: `v-bind is missing expression.`,
    [52]: `v-bind with same-name shorthand only allows static argument.`,
    [35]: `v-on is missing expression.`,
    [36]: `Unexpected custom directive on <slot> outlet.`,
    [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
    [38]: `Duplicate slot names found. `,
    [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
    [40]: `v-slot can only be used on components or <template> tags.`,
    [41]: `v-model is missing expression.`,
    [42]: `v-model value must be a valid JavaScript member expression.`,
    [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
    [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
    [45]: `Error parsing JavaScript expression: `,
    [46]: `<KeepAlive> expects exactly one child component.`,
    [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
    // generic errors
    [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
    [48]: `ES module mode is not supported in this build of compiler.`,
    [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
    [50]: `"scopeId" option is only supported in module mode.`,
    // just to fulfill types
    [53]: ``
  };

  const isStaticExp = (p) => p.type === 4 && p.isStatic;
  function isCoreComponent(tag) {
    switch (tag) {
      case "Teleport":
      case "teleport":
        return TELEPORT;
      case "Suspense":
      case "suspense":
        return SUSPENSE;
      case "KeepAlive":
      case "keep-alive":
        return KEEP_ALIVE;
      case "BaseTransition":
      case "base-transition":
        return BASE_TRANSITION;
    }
  }
  const nonIdentifierRE = /^$|^\d|[^\$\w\xA0-\uFFFF]/;
  const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
  const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
  const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
  const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
  const getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
  const isMemberExpressionBrowser = (exp) => {
    const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
    let state = 0 /* inMemberExp */;
    let stateStack = [];
    let currentOpenBracketCount = 0;
    let currentOpenParensCount = 0;
    let currentStringType = null;
    for (let i = 0; i < path.length; i++) {
      const char = path.charAt(i);
      switch (state) {
        case 0 /* inMemberExp */:
          if (char === "[") {
            stateStack.push(state);
            state = 1 /* inBrackets */;
            currentOpenBracketCount++;
          } else if (char === "(") {
            stateStack.push(state);
            state = 2 /* inParens */;
            currentOpenParensCount++;
          } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
            return false;
          }
          break;
        case 1 /* inBrackets */:
          if (char === `'` || char === `"` || char === "`") {
            stateStack.push(state);
            state = 3 /* inString */;
            currentStringType = char;
          } else if (char === `[`) {
            currentOpenBracketCount++;
          } else if (char === `]`) {
            if (!--currentOpenBracketCount) {
              state = stateStack.pop();
            }
          }
          break;
        case 2 /* inParens */:
          if (char === `'` || char === `"` || char === "`") {
            stateStack.push(state);
            state = 3 /* inString */;
            currentStringType = char;
          } else if (char === `(`) {
            currentOpenParensCount++;
          } else if (char === `)`) {
            if (i === path.length - 1) {
              return false;
            }
            if (!--currentOpenParensCount) {
              state = stateStack.pop();
            }
          }
          break;
        case 3 /* inString */:
          if (char === currentStringType) {
            state = stateStack.pop();
            currentStringType = null;
          }
          break;
      }
    }
    return !currentOpenBracketCount && !currentOpenParensCount;
  };
  const isMemberExpression = isMemberExpressionBrowser ;
  const fnExpRE = /^\s*(?:async\s*)?(?:\([^)]*?\)|[\w$_]+)\s*(?::[^=]+)?=>|^\s*(?:async\s+)?function(?:\s+[\w$]+)?\s*\(/;
  const isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
  const isFnExpression = isFnExpressionBrowser ;
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg || `unexpected compiler condition`);
    }
  }
  function findDir(node, name, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
      const p = node.props[i];
      if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
        return p;
      }
    }
  }
  function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
      const p = node.props[i];
      if (p.type === 6) {
        if (dynamicOnly) continue;
        if (p.name === name && (p.value || allowEmpty)) {
          return p;
        }
      } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
        return p;
      }
    }
  }
  function isStaticArgOf(arg, name) {
    return !!(arg && isStaticExp(arg) && arg.content === name);
  }
  function hasDynamicKeyVBind(node) {
    return node.props.some(
      (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
      p.arg.type !== 4 || // v-bind:[_ctx.foo]
      !p.arg.isStatic)
      // v-bind:[foo]
    );
  }
  function isText$1(node) {
    return node.type === 5 || node.type === 2;
  }
  function isVPre(p) {
    return p.type === 7 && p.name === "pre";
  }
  function isVSlot(p) {
    return p.type === 7 && p.name === "slot";
  }
  function isTemplateNode(node) {
    return node.type === 1 && node.tagType === 3;
  }
  function isSlotOutlet(node) {
    return node.type === 1 && node.tagType === 2;
  }
  const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
  function getUnnormalizedProps(props, callPath = []) {
    if (props && !isString(props) && props.type === 14) {
      const callee = props.callee;
      if (!isString(callee) && propsHelperSet.has(callee)) {
        return getUnnormalizedProps(
          props.arguments[0],
          callPath.concat(props)
        );
      }
    }
    return [props, callPath];
  }
  function injectProp(node, prop, context) {
    let propsWithInjection;
    let props = node.type === 13 ? node.props : node.arguments[2];
    let callPath = [];
    let parentCall;
    if (props && !isString(props) && props.type === 14) {
      const ret = getUnnormalizedProps(props);
      props = ret[0];
      callPath = ret[1];
      parentCall = callPath[callPath.length - 1];
    }
    if (props == null || isString(props)) {
      propsWithInjection = createObjectExpression([prop]);
    } else if (props.type === 14) {
      const first = props.arguments[0];
      if (!isString(first) && first.type === 15) {
        if (!hasProp(prop, first)) {
          first.properties.unshift(prop);
        }
      } else {
        if (props.callee === TO_HANDLERS) {
          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
          ]);
        } else {
          props.arguments.unshift(createObjectExpression([prop]));
        }
      }
      !propsWithInjection && (propsWithInjection = props);
    } else if (props.type === 15) {
      if (!hasProp(prop, props)) {
        props.properties.unshift(prop);
      }
      propsWithInjection = props;
    } else {
      propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
        createObjectExpression([prop]),
        props
      ]);
      if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
        parentCall = callPath[callPath.length - 2];
      }
    }
    if (node.type === 13) {
      if (parentCall) {
        parentCall.arguments[0] = propsWithInjection;
      } else {
        node.props = propsWithInjection;
      }
    } else {
      if (parentCall) {
        parentCall.arguments[0] = propsWithInjection;
      } else {
        node.arguments[2] = propsWithInjection;
      }
    }
  }
  function hasProp(prop, props) {
    let result = false;
    if (prop.key.type === 4) {
      const propKeyName = prop.key.content;
      result = props.properties.some(
        (p) => p.key.type === 4 && p.key.content === propKeyName
      );
    }
    return result;
  }
  function toValidAssetId(name, type) {
    return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
  }
  function getMemoedVNodeCall(node) {
    if (node.type === 14 && node.callee === WITH_MEMO) {
      return node.arguments[1].returns;
    } else {
      return node;
    }
  }
  const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;

  const defaultParserOptions = {
    parseMode: "base",
    ns: 0,
    delimiters: [`{{`, `}}`],
    getNamespace: () => 0,
    isVoidTag: NO,
    isPreTag: NO,
    isIgnoreNewlineTag: NO,
    isCustomElement: NO,
    onError: defaultOnError,
    onWarn: defaultOnWarn,
    comments: !!(process.env.NODE_ENV !== "production"),
    prefixIdentifiers: false
  };
  let currentOptions = defaultParserOptions;
  let currentRoot = null;
  let currentInput = "";
  let currentOpenTag = null;
  let currentProp = null;
  let currentAttrValue = "";
  let currentAttrStartIndex = -1;
  let currentAttrEndIndex = -1;
  let inPre = 0;
  let inVPre = false;
  let currentVPreBoundary = null;
  const stack = [];
  const tokenizer = new Tokenizer(stack, {
    onerr: emitError,
    ontext(start, end) {
      onText(getSlice(start, end), start, end);
    },
    ontextentity(char, start, end) {
      onText(char, start, end);
    },
    oninterpolation(start, end) {
      if (inVPre) {
        return onText(getSlice(start, end), start, end);
      }
      let innerStart = start + tokenizer.delimiterOpen.length;
      let innerEnd = end - tokenizer.delimiterClose.length;
      while (isWhitespace$1(currentInput.charCodeAt(innerStart))) {
        innerStart++;
      }
      while (isWhitespace$1(currentInput.charCodeAt(innerEnd - 1))) {
        innerEnd--;
      }
      let exp = getSlice(innerStart, innerEnd);
      if (exp.includes("&")) {
        {
          exp = currentOptions.decodeEntities(exp, false);
        }
      }
      addNode({
        type: 5,
        content: createExp(exp, false, getLoc(innerStart, innerEnd)),
        loc: getLoc(start, end)
      });
    },
    onopentagname(start, end) {
      const name = getSlice(start, end);
      currentOpenTag = {
        type: 1,
        tag: name,
        ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
        tagType: 0,
        // will be refined on tag close
        props: [],
        children: [],
        loc: getLoc(start - 1, end),
        codegenNode: void 0
      };
    },
    onopentagend(end) {
      endOpenTag(end);
    },
    onclosetag(start, end) {
      const name = getSlice(start, end);
      if (!currentOptions.isVoidTag(name)) {
        let found = false;
        for (let i = 0; i < stack.length; i++) {
          const e = stack[i];
          if (e.tag.toLowerCase() === name.toLowerCase()) {
            found = true;
            if (i > 0) {
              emitError(24, stack[0].loc.start.offset);
            }
            for (let j = 0; j <= i; j++) {
              const el = stack.shift();
              onCloseTag(el, end, j < i);
            }
            break;
          }
        }
        if (!found) {
          emitError(23, backTrack(start, 60));
        }
      }
    },
    onselfclosingtag(end) {
      const name = currentOpenTag.tag;
      currentOpenTag.isSelfClosing = true;
      endOpenTag(end);
      if (stack[0] && stack[0].tag === name) {
        onCloseTag(stack.shift(), end);
      }
    },
    onattribname(start, end) {
      currentProp = {
        type: 6,
        name: getSlice(start, end),
        nameLoc: getLoc(start, end),
        value: void 0,
        loc: getLoc(start)
      };
    },
    ondirname(start, end) {
      const raw = getSlice(start, end);
      const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
      if (!inVPre && name === "") {
        emitError(26, start);
      }
      if (inVPre || name === "") {
        currentProp = {
          type: 6,
          name: raw,
          nameLoc: getLoc(start, end),
          value: void 0,
          loc: getLoc(start)
        };
      } else {
        currentProp = {
          type: 7,
          name,
          rawName: raw,
          exp: void 0,
          arg: void 0,
          modifiers: raw === "." ? [createSimpleExpression("prop")] : [],
          loc: getLoc(start)
        };
        if (name === "pre") {
          inVPre = tokenizer.inVPre = true;
          currentVPreBoundary = currentOpenTag;
          const props = currentOpenTag.props;
          for (let i = 0; i < props.length; i++) {
            if (props[i].type === 7) {
              props[i] = dirToAttr(props[i]);
            }
          }
        }
      }
    },
    ondirarg(start, end) {
      if (start === end) return;
      const arg = getSlice(start, end);
      if (inVPre && !isVPre(currentProp)) {
        currentProp.name += arg;
        setLocEnd(currentProp.nameLoc, end);
      } else {
        const isStatic = arg[0] !== `[`;
        currentProp.arg = createExp(
          isStatic ? arg : arg.slice(1, -1),
          isStatic,
          getLoc(start, end),
          isStatic ? 3 : 0
        );
      }
    },
    ondirmodifier(start, end) {
      const mod = getSlice(start, end);
      if (inVPre && !isVPre(currentProp)) {
        currentProp.name += "." + mod;
        setLocEnd(currentProp.nameLoc, end);
      } else if (currentProp.name === "slot") {
        const arg = currentProp.arg;
        if (arg) {
          arg.content += "." + mod;
          setLocEnd(arg.loc, end);
        }
      } else {
        const exp = createSimpleExpression(mod, true, getLoc(start, end));
        currentProp.modifiers.push(exp);
      }
    },
    onattribdata(start, end) {
      currentAttrValue += getSlice(start, end);
      if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
      currentAttrEndIndex = end;
    },
    onattribentity(char, start, end) {
      currentAttrValue += char;
      if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
      currentAttrEndIndex = end;
    },
    onattribnameend(end) {
      const start = currentProp.loc.start.offset;
      const name = getSlice(start, end);
      if (currentProp.type === 7) {
        currentProp.rawName = name;
      }
      if (currentOpenTag.props.some(
        (p) => (p.type === 7 ? p.rawName : p.name) === name
      )) {
        emitError(2, start);
      }
    },
    onattribend(quote, end) {
      if (currentOpenTag && currentProp) {
        setLocEnd(currentProp.loc, end);
        if (quote !== 0) {
          if (currentAttrValue.includes("&")) {
            currentAttrValue = currentOptions.decodeEntities(
              currentAttrValue,
              true
            );
          }
          if (currentProp.type === 6) {
            if (currentProp.name === "class") {
              currentAttrValue = condense(currentAttrValue).trim();
            }
            if (quote === 1 && !currentAttrValue) {
              emitError(13, end);
            }
            currentProp.value = {
              type: 2,
              content: currentAttrValue,
              loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
            };
            if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
              tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
            }
          } else {
            let expParseMode = 0 /* Normal */;
            currentProp.exp = createExp(
              currentAttrValue,
              false,
              getLoc(currentAttrStartIndex, currentAttrEndIndex),
              0,
              expParseMode
            );
            if (currentProp.name === "for") {
              currentProp.forParseResult = parseForExpression(currentProp.exp);
            }
            let syncIndex = -1;
            if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex(
              (mod) => mod.content === "sync"
            )) > -1 && checkCompatEnabled(
              "COMPILER_V_BIND_SYNC",
              currentOptions,
              currentProp.loc,
              currentProp.arg.loc.source
            )) {
              currentProp.name = "model";
              currentProp.modifiers.splice(syncIndex, 1);
            }
          }
        }
        if (currentProp.type !== 7 || currentProp.name !== "pre") {
          currentOpenTag.props.push(currentProp);
        }
      }
      currentAttrValue = "";
      currentAttrStartIndex = currentAttrEndIndex = -1;
    },
    oncomment(start, end) {
      if (currentOptions.comments) {
        addNode({
          type: 3,
          content: getSlice(start, end),
          loc: getLoc(start - 4, end + 3)
        });
      }
    },
    onend() {
      const end = currentInput.length;
      if ((!!(process.env.NODE_ENV !== "production") || false) && tokenizer.state !== 1) {
        switch (tokenizer.state) {
          case 5:
          case 8:
            emitError(5, end);
            break;
          case 3:
          case 4:
            emitError(
              25,
              tokenizer.sectionStart
            );
            break;
          case 28:
            if (tokenizer.currentSequence === Sequences.CdataEnd) {
              emitError(6, end);
            } else {
              emitError(7, end);
            }
            break;
          case 6:
          case 7:
          case 9:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          // "
          case 20:
          // '
          case 21:
            emitError(9, end);
            break;
        }
      }
      for (let index = 0; index < stack.length; index++) {
        onCloseTag(stack[index], end - 1);
        emitError(24, stack[index].loc.start.offset);
      }
    },
    oncdata(start, end) {
      if (stack[0].ns !== 0) {
        onText(getSlice(start, end), start, end);
      } else {
        emitError(1, start - 9);
      }
    },
    onprocessinginstruction(start) {
      if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
        emitError(
          21,
          start - 1
        );
      }
    }
  });
  const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  const stripParensRE = /^\(|\)$/g;
  function parseForExpression(input) {
    const loc = input.loc;
    const exp = input.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch) return;
    const [, LHS, RHS] = inMatch;
    const createAliasExpression = (content, offset, asParam = false) => {
      const start = loc.start.offset + offset;
      const end = start + content.length;
      return createExp(
        content,
        false,
        getLoc(start, end),
        0,
        asParam ? 1 /* Params */ : 0 /* Normal */
      );
    };
    const result = {
      source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
      value: void 0,
      key: void 0,
      index: void 0,
      finalized: false
    };
    let valueContent = LHS.trim().replace(stripParensRE, "").trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
      valueContent = valueContent.replace(forIteratorRE, "").trim();
      const keyContent = iteratorMatch[1].trim();
      let keyOffset;
      if (keyContent) {
        keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
        result.key = createAliasExpression(keyContent, keyOffset, true);
      }
      if (iteratorMatch[2]) {
        const indexContent = iteratorMatch[2].trim();
        if (indexContent) {
          result.index = createAliasExpression(
            indexContent,
            exp.indexOf(
              indexContent,
              result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
            ),
            true
          );
        }
      }
    }
    if (valueContent) {
      result.value = createAliasExpression(valueContent, trimmedOffset, true);
    }
    return result;
  }
  function getSlice(start, end) {
    return currentInput.slice(start, end);
  }
  function endOpenTag(end) {
    if (tokenizer.inSFCRoot) {
      currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
    }
    addNode(currentOpenTag);
    const { tag, ns } = currentOpenTag;
    if (ns === 0 && currentOptions.isPreTag(tag)) {
      inPre++;
    }
    if (currentOptions.isVoidTag(tag)) {
      onCloseTag(currentOpenTag, end);
    } else {
      stack.unshift(currentOpenTag);
      if (ns === 1 || ns === 2) {
        tokenizer.inXML = true;
      }
    }
    currentOpenTag = null;
  }
  function onText(content, start, end) {
    {
      const tag = stack[0] && stack[0].tag;
      if (tag !== "script" && tag !== "style" && content.includes("&")) {
        content = currentOptions.decodeEntities(content, false);
      }
    }
    const parent = stack[0] || currentRoot;
    const lastNode = parent.children[parent.children.length - 1];
    if (lastNode && lastNode.type === 2) {
      lastNode.content += content;
      setLocEnd(lastNode.loc, end);
    } else {
      parent.children.push({
        type: 2,
        content,
        loc: getLoc(start, end)
      });
    }
  }
  function onCloseTag(el, end, isImplied = false) {
    if (isImplied) {
      setLocEnd(el.loc, backTrack(end, 60));
    } else {
      setLocEnd(el.loc, lookAhead(end, 62) + 1);
    }
    if (tokenizer.inSFCRoot) {
      if (el.children.length) {
        el.innerLoc.end = extend$1({}, el.children[el.children.length - 1].loc.end);
      } else {
        el.innerLoc.end = extend$1({}, el.innerLoc.start);
      }
      el.innerLoc.source = getSlice(
        el.innerLoc.start.offset,
        el.innerLoc.end.offset
      );
    }
    const { tag, ns, children } = el;
    if (!inVPre) {
      if (tag === "slot") {
        el.tagType = 2;
      } else if (isFragmentTemplate(el)) {
        el.tagType = 3;
      } else if (isComponent(el)) {
        el.tagType = 1;
      }
    }
    if (!tokenizer.inRCDATA) {
      el.children = condenseWhitespace(children);
    }
    if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
      const first = children[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
    if (ns === 0 && currentOptions.isPreTag(tag)) {
      inPre--;
    }
    if (currentVPreBoundary === el) {
      inVPre = tokenizer.inVPre = false;
      currentVPreBoundary = null;
    }
    if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
      tokenizer.inXML = false;
    }
    {
      const props = el.props;
      if (!!(process.env.NODE_ENV !== "production") && isCompatEnabled(
        "COMPILER_V_IF_V_FOR_PRECEDENCE",
        currentOptions
      )) {
        let hasIf = false;
        let hasFor = false;
        for (let i = 0; i < props.length; i++) {
          const p = props[i];
          if (p.type === 7) {
            if (p.name === "if") {
              hasIf = true;
            } else if (p.name === "for") {
              hasFor = true;
            }
          }
          if (hasIf && hasFor) {
            warnDeprecation(
              "COMPILER_V_IF_V_FOR_PRECEDENCE",
              currentOptions,
              el.loc
            );
            break;
          }
        }
      }
      if (!tokenizer.inSFCRoot && isCompatEnabled(
        "COMPILER_NATIVE_TEMPLATE",
        currentOptions
      ) && el.tag === "template" && !isFragmentTemplate(el)) {
        !!(process.env.NODE_ENV !== "production") && warnDeprecation(
          "COMPILER_NATIVE_TEMPLATE",
          currentOptions,
          el.loc
        );
        const parent = stack[0] || currentRoot;
        const index = parent.children.indexOf(el);
        parent.children.splice(index, 1, ...el.children);
      }
      const inlineTemplateProp = props.find(
        (p) => p.type === 6 && p.name === "inline-template"
      );
      if (inlineTemplateProp && checkCompatEnabled(
        "COMPILER_INLINE_TEMPLATE",
        currentOptions,
        inlineTemplateProp.loc
      ) && el.children.length) {
        inlineTemplateProp.value = {
          type: 2,
          content: getSlice(
            el.children[0].loc.start.offset,
            el.children[el.children.length - 1].loc.end.offset
          ),
          loc: inlineTemplateProp.loc
        };
      }
    }
  }
  function lookAhead(index, c) {
    let i = index;
    while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;
    return i;
  }
  function backTrack(index, c) {
    let i = index;
    while (currentInput.charCodeAt(i) !== c && i >= 0) i--;
    return i;
  }
  const specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
  function isFragmentTemplate({ tag, props }) {
    if (tag === "template") {
      for (let i = 0; i < props.length; i++) {
        if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
          return true;
        }
      }
    }
    return false;
  }
  function isComponent({ tag, props }) {
    if (currentOptions.isCustomElement(tag)) {
      return false;
    }
    if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
      return true;
    }
    for (let i = 0; i < props.length; i++) {
      const p = props[i];
      if (p.type === 6) {
        if (p.name === "is" && p.value) {
          if (p.value.content.startsWith("vue:")) {
            return true;
          } else if (checkCompatEnabled(
            "COMPILER_IS_ON_ELEMENT",
            currentOptions,
            p.loc
          )) {
            return true;
          }
        }
      } else if (// :is on plain element - only treat as component in compat mode
      p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        currentOptions,
        p.loc
      )) {
        return true;
      }
    }
    return false;
  }
  function isUpperCase(c) {
    return c > 64 && c < 91;
  }
  const windowsNewlineRE = /\r\n/g;
  function condenseWhitespace(nodes) {
    const shouldCondense = currentOptions.whitespace !== "preserve";
    let removedWhitespace = false;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node.type === 2) {
        if (!inPre) {
          if (isAllWhitespace(node.content)) {
            const prev = nodes[i - 1] && nodes[i - 1].type;
            const next = nodes[i + 1] && nodes[i + 1].type;
            if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
              removedWhitespace = true;
              nodes[i] = null;
            } else {
              node.content = " ";
            }
          } else if (shouldCondense) {
            node.content = condense(node.content);
          }
        } else {
          node.content = node.content.replace(windowsNewlineRE, "\n");
        }
      }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
  function isAllWhitespace(str) {
    for (let i = 0; i < str.length; i++) {
      if (!isWhitespace$1(str.charCodeAt(i))) {
        return false;
      }
    }
    return true;
  }
  function hasNewlineChar(str) {
    for (let i = 0; i < str.length; i++) {
      const c = str.charCodeAt(i);
      if (c === 10 || c === 13) {
        return true;
      }
    }
    return false;
  }
  function condense(str) {
    let ret = "";
    let prevCharIsWhitespace = false;
    for (let i = 0; i < str.length; i++) {
      if (isWhitespace$1(str.charCodeAt(i))) {
        if (!prevCharIsWhitespace) {
          ret += " ";
          prevCharIsWhitespace = true;
        }
      } else {
        ret += str[i];
        prevCharIsWhitespace = false;
      }
    }
    return ret;
  }
  function addNode(node) {
    (stack[0] || currentRoot).children.push(node);
  }
  function getLoc(start, end) {
    return {
      start: tokenizer.getPos(start),
      // @ts-expect-error allow late attachment
      end: end == null ? end : tokenizer.getPos(end),
      // @ts-expect-error allow late attachment
      source: end == null ? end : getSlice(start, end)
    };
  }
  function cloneLoc(loc) {
    return getLoc(loc.start.offset, loc.end.offset);
  }
  function setLocEnd(loc, end) {
    loc.end = tokenizer.getPos(end);
    loc.source = getSlice(loc.start.offset, end);
  }
  function dirToAttr(dir) {
    const attr = {
      type: 6,
      name: dir.rawName,
      nameLoc: getLoc(
        dir.loc.start.offset,
        dir.loc.start.offset + dir.rawName.length
      ),
      value: void 0,
      loc: dir.loc
    };
    if (dir.exp) {
      const loc = dir.exp.loc;
      if (loc.end.offset < dir.loc.end.offset) {
        loc.start.offset--;
        loc.start.column--;
        loc.end.offset++;
        loc.end.column++;
      }
      attr.value = {
        type: 2,
        content: dir.exp.content,
        loc
      };
    }
    return attr;
  }
  function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0 /* Normal */) {
    const exp = createSimpleExpression(content, isStatic, loc, constType);
    return exp;
  }
  function emitError(code, index, message) {
    currentOptions.onError(
      createCompilerError(code, getLoc(index, index), void 0, message)
    );
  }
  function reset() {
    tokenizer.reset();
    currentOpenTag = null;
    currentProp = null;
    currentAttrValue = "";
    currentAttrStartIndex = -1;
    currentAttrEndIndex = -1;
    stack.length = 0;
  }
  function baseParse(input, options) {
    reset();
    currentInput = input;
    currentOptions = extend$1({}, defaultParserOptions);
    if (options) {
      let key;
      for (key in options) {
        if (options[key] != null) {
          currentOptions[key] = options[key];
        }
      }
    }
    if (!!(process.env.NODE_ENV !== "production")) {
      if (!currentOptions.decodeEntities) {
        throw new Error(
          `[@vue/compiler-core] decodeEntities option is required in browser builds.`
        );
      }
    }
    tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
    tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
    const delimiters = options && options.delimiters;
    if (delimiters) {
      tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
      tokenizer.delimiterClose = toCharCodes(delimiters[1]);
    }
    const root = currentRoot = createRoot([], input);
    tokenizer.parse(currentInput);
    root.loc = getLoc(0, input.length);
    root.children = condenseWhitespace(root.children);
    currentRoot = null;
    return root;
  }

  function cacheStatic(root, context) {
    walk(
      root,
      void 0,
      context,
      // Root node is unfortunately non-hoistable due to potential parent
      // fallthrough attributes.
      !!getSingleElementRoot(root)
    );
  }
  function getSingleElementRoot(root) {
    const children = root.children.filter((x) => x.type !== 3);
    return children.length === 1 && children[0].type === 1 && !isSlotOutlet(children[0]) ? children[0] : null;
  }
  function walk(node, parent, context, doNotHoistNode = false, inFor = false) {
    const { children } = node;
    const toCache = [];
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.type === 1 && child.tagType === 0) {
        const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
        if (constantType > 0) {
          if (constantType >= 2) {
            child.codegenNode.patchFlag = -1;
            toCache.push(child);
            continue;
          }
        } else {
          const codegenNode = child.codegenNode;
          if (codegenNode.type === 13) {
            const flag = codegenNode.patchFlag;
            if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
              const props = getNodeProps(child);
              if (props) {
                codegenNode.props = context.hoist(props);
              }
            }
            if (codegenNode.dynamicProps) {
              codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
            }
          }
        }
      } else if (child.type === 12) {
        const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
        if (constantType >= 2) {
          if (child.codegenNode.type === 14 && child.codegenNode.arguments.length > 0) {
            child.codegenNode.arguments.push(
              -1 + (!!(process.env.NODE_ENV !== "production") ? ` /* ${PatchFlagNames[-1]} */` : ``)
            );
          }
          toCache.push(child);
          continue;
        }
      }
      if (child.type === 1) {
        const isComponent = child.tagType === 1;
        if (isComponent) {
          context.scopes.vSlot++;
        }
        walk(child, node, context, false, inFor);
        if (isComponent) {
          context.scopes.vSlot--;
        }
      } else if (child.type === 11) {
        walk(child, node, context, child.children.length === 1, true);
      } else if (child.type === 9) {
        for (let i2 = 0; i2 < child.branches.length; i2++) {
          walk(
            child.branches[i2],
            node,
            context,
            child.branches[i2].children.length === 1,
            inFor
          );
        }
      }
    }
    let cachedAsArray = false;
    if (toCache.length === children.length && node.type === 1) {
      if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
        node.codegenNode.children = getCacheExpression(
          createArrayExpression(node.codegenNode.children)
        );
        cachedAsArray = true;
      } else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !isArray(node.codegenNode.children) && node.codegenNode.children.type === 15) {
        const slot = getSlotNode(node.codegenNode, "default");
        if (slot) {
          slot.returns = getCacheExpression(
            createArrayExpression(slot.returns)
          );
          cachedAsArray = true;
        }
      } else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
        const slotName = findDir(node, "slot", true);
        const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
        if (slot) {
          slot.returns = getCacheExpression(
            createArrayExpression(slot.returns)
          );
          cachedAsArray = true;
        }
      }
    }
    if (!cachedAsArray) {
      for (const child of toCache) {
        child.codegenNode = context.cache(child.codegenNode);
      }
    }
    function getCacheExpression(value) {
      const exp = context.cache(value);
      exp.needArraySpread = true;
      return exp;
    }
    function getSlotNode(node2, name) {
      if (node2.children && !isArray(node2.children) && node2.children.type === 15) {
        const slot = node2.children.properties.find(
          (p) => p.key === name || p.key.content === name
        );
        return slot && slot.value;
      }
    }
    if (toCache.length && context.transformHoist) {
      context.transformHoist(children, context, node);
    }
  }
  function getConstantType(node, context) {
    const { constantCache } = context;
    switch (node.type) {
      case 1:
        if (node.tagType !== 0) {
          return 0;
        }
        const cached = constantCache.get(node);
        if (cached !== void 0) {
          return cached;
        }
        const codegenNode = node.codegenNode;
        if (codegenNode.type !== 13) {
          return 0;
        }
        if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
          return 0;
        }
        if (codegenNode.patchFlag === void 0) {
          let returnType2 = 3;
          const generatedPropsType = getGeneratedPropsConstantType(node, context);
          if (generatedPropsType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (generatedPropsType < returnType2) {
            returnType2 = generatedPropsType;
          }
          for (let i = 0; i < node.children.length; i++) {
            const childType = getConstantType(node.children[i], context);
            if (childType === 0) {
              constantCache.set(node, 0);
              return 0;
            }
            if (childType < returnType2) {
              returnType2 = childType;
            }
          }
          if (returnType2 > 1) {
            for (let i = 0; i < node.props.length; i++) {
              const p = node.props[i];
              if (p.type === 7 && p.name === "bind" && p.exp) {
                const expType = getConstantType(p.exp, context);
                if (expType === 0) {
                  constantCache.set(node, 0);
                  return 0;
                }
                if (expType < returnType2) {
                  returnType2 = expType;
                }
              }
            }
          }
          if (codegenNode.isBlock) {
            for (let i = 0; i < node.props.length; i++) {
              const p = node.props[i];
              if (p.type === 7) {
                constantCache.set(node, 0);
                return 0;
              }
            }
            context.removeHelper(OPEN_BLOCK);
            context.removeHelper(
              getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
            );
            codegenNode.isBlock = false;
            context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
          }
          constantCache.set(node, returnType2);
          return returnType2;
        } else {
          constantCache.set(node, 0);
          return 0;
        }
      case 2:
      case 3:
        return 3;
      case 9:
      case 11:
      case 10:
        return 0;
      case 5:
      case 12:
        return getConstantType(node.content, context);
      case 4:
        return node.constType;
      case 8:
        let returnType = 3;
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (isString(child) || isSymbol(child)) {
            continue;
          }
          const childType = getConstantType(child, context);
          if (childType === 0) {
            return 0;
          } else if (childType < returnType) {
            returnType = childType;
          }
        }
        return returnType;
      case 20:
        return 2;
      default:
        if (!!(process.env.NODE_ENV !== "production")) ;
        return 0;
    }
  }
  const allowHoistedHelperSet = /* @__PURE__ */ new Set([
    NORMALIZE_CLASS,
    NORMALIZE_STYLE,
    NORMALIZE_PROPS,
    GUARD_REACTIVE_PROPS
  ]);
  function getConstantTypeOfHelperCall(value, context) {
    if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
      const arg = value.arguments[0];
      if (arg.type === 4) {
        return getConstantType(arg, context);
      } else if (arg.type === 14) {
        return getConstantTypeOfHelperCall(arg, context);
      }
    }
    return 0;
  }
  function getGeneratedPropsConstantType(node, context) {
    let returnType = 3;
    const props = getNodeProps(node);
    if (props && props.type === 15) {
      const { properties } = props;
      for (let i = 0; i < properties.length; i++) {
        const { key, value } = properties[i];
        const keyType = getConstantType(key, context);
        if (keyType === 0) {
          return keyType;
        }
        if (keyType < returnType) {
          returnType = keyType;
        }
        let valueType;
        if (value.type === 4) {
          valueType = getConstantType(value, context);
        } else if (value.type === 14) {
          valueType = getConstantTypeOfHelperCall(value, context);
        } else {
          valueType = 0;
        }
        if (valueType === 0) {
          return valueType;
        }
        if (valueType < returnType) {
          returnType = valueType;
        }
      }
    }
    return returnType;
  }
  function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13) {
      return codegenNode.props;
    }
  }

  function createTransformContext(root, {
    filename = "",
    prefixIdentifiers = false,
    hoistStatic = false,
    hmr = false,
    cacheHandlers = false,
    nodeTransforms = [],
    directiveTransforms = {},
    transformHoist = null,
    isBuiltInComponent = NOOP,
    isCustomElement = NOOP,
    expressionPlugins = [],
    scopeId = null,
    slotted = true,
    ssr = false,
    inSSR = false,
    ssrCssVars = ``,
    bindingMetadata = EMPTY_OBJ,
    inline = false,
    isTS = false,
    onError = defaultOnError,
    onWarn = defaultOnWarn,
    compatConfig
  }) {
    const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
    const context = {
      // options
      filename,
      selfName: nameMatch && capitalize(camelize(nameMatch[1])),
      prefixIdentifiers,
      hoistStatic,
      hmr,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      isCustomElement,
      expressionPlugins,
      scopeId,
      slotted,
      ssr,
      inSSR,
      ssrCssVars,
      bindingMetadata,
      inline,
      isTS,
      onError,
      onWarn,
      compatConfig,
      // state
      root,
      helpers: /* @__PURE__ */ new Map(),
      components: /* @__PURE__ */ new Set(),
      directives: /* @__PURE__ */ new Set(),
      hoists: [],
      imports: [],
      cached: [],
      constantCache: /* @__PURE__ */ new WeakMap(),
      temps: 0,
      identifiers: /* @__PURE__ */ Object.create(null),
      scopes: {
        vFor: 0,
        vSlot: 0,
        vPre: 0,
        vOnce: 0
      },
      parent: null,
      grandParent: null,
      currentNode: root,
      childIndex: 0,
      inVOnce: false,
      // methods
      helper(name) {
        const count = context.helpers.get(name) || 0;
        context.helpers.set(name, count + 1);
        return name;
      },
      removeHelper(name) {
        const count = context.helpers.get(name);
        if (count) {
          const currentCount = count - 1;
          if (!currentCount) {
            context.helpers.delete(name);
          } else {
            context.helpers.set(name, currentCount);
          }
        }
      },
      helperString(name) {
        return `_${helperNameMap[context.helper(name)]}`;
      },
      replaceNode(node) {
        if (!!(process.env.NODE_ENV !== "production")) {
          if (!context.currentNode) {
            throw new Error(`Node being replaced is already removed.`);
          }
          if (!context.parent) {
            throw new Error(`Cannot replace root node.`);
          }
        }
        context.parent.children[context.childIndex] = context.currentNode = node;
      },
      removeNode(node) {
        if (!!(process.env.NODE_ENV !== "production") && !context.parent) {
          throw new Error(`Cannot remove root node.`);
        }
        const list = context.parent.children;
        const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
        if (!!(process.env.NODE_ENV !== "production") && removalIndex < 0) {
          throw new Error(`node being removed is not a child of current parent`);
        }
        if (!node || node === context.currentNode) {
          context.currentNode = null;
          context.onNodeRemoved();
        } else {
          if (context.childIndex > removalIndex) {
            context.childIndex--;
            context.onNodeRemoved();
          }
        }
        context.parent.children.splice(removalIndex, 1);
      },
      onNodeRemoved: NOOP,
      addIdentifiers(exp) {
      },
      removeIdentifiers(exp) {
      },
      hoist(exp) {
        if (isString(exp)) exp = createSimpleExpression(exp);
        context.hoists.push(exp);
        const identifier = createSimpleExpression(
          `_hoisted_${context.hoists.length}`,
          false,
          exp.loc,
          2
        );
        identifier.hoisted = exp;
        return identifier;
      },
      cache(exp, isVNode = false, inVOnce = false) {
        const cacheExp = createCacheExpression(
          context.cached.length,
          exp,
          isVNode,
          inVOnce
        );
        context.cached.push(cacheExp);
        return cacheExp;
      }
    };
    {
      context.filters = /* @__PURE__ */ new Set();
    }
    return context;
  }
  function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic) {
      cacheStatic(root, context);
    }
    if (!options.ssr) {
      createRootCodegen(root, context);
    }
    root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = context.imports;
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
    root.transformed = true;
    {
      root.filters = [...context.filters];
    }
  }
  function createRootCodegen(root, context) {
    const { helper } = context;
    const { children } = root;
    if (children.length === 1) {
      const singleElementRootChild = getSingleElementRoot(root);
      if (singleElementRootChild && singleElementRootChild.codegenNode) {
        const codegenNode = singleElementRootChild.codegenNode;
        if (codegenNode.type === 13) {
          convertToBlock(codegenNode, context);
        }
        root.codegenNode = codegenNode;
      } else {
        root.codegenNode = children[0];
      }
    } else if (children.length > 1) {
      let patchFlag = 64;
      if (!!(process.env.NODE_ENV !== "production") && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
      }
      root.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        void 0,
        root.children,
        patchFlag,
        void 0,
        void 0,
        true,
        void 0,
        false
      );
    } else ;
  }
  function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
      i--;
    };
    for (; i < parent.children.length; i++) {
      const child = parent.children[i];
      if (isString(child)) continue;
      context.grandParent = context.parent;
      context.parent = parent;
      context.childIndex = i;
      context.onNodeRemoved = nodeRemoved;
      traverseNode(child, context);
    }
  }
  function traverseNode(node, context) {
    context.currentNode = node;
    const { nodeTransforms } = context;
    const exitFns = [];
    for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
      const onExit = nodeTransforms[i2](node, context);
      if (onExit) {
        if (isArray(onExit)) {
          exitFns.push(...onExit);
        } else {
          exitFns.push(onExit);
        }
      }
      if (!context.currentNode) {
        return;
      } else {
        node = context.currentNode;
      }
    }
    switch (node.type) {
      case 3:
        if (!context.ssr) {
          context.helper(CREATE_COMMENT);
        }
        break;
      case 5:
        if (!context.ssr) {
          context.helper(TO_DISPLAY_STRING);
        }
        break;
      // for container types, further traverse downwards
      case 9:
        for (let i2 = 0; i2 < node.branches.length; i2++) {
          traverseNode(node.branches[i2], context);
        }
        break;
      case 10:
      case 11:
      case 1:
      case 0:
        traverseChildren(node, context);
        break;
    }
    context.currentNode = node;
    let i = exitFns.length;
    while (i--) {
      exitFns[i]();
    }
  }
  function createStructuralDirectiveTransform(name, fn) {
    const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
    return (node, context) => {
      if (node.type === 1) {
        const { props } = node;
        if (node.tagType === 3 && props.some(isVSlot)) {
          return;
        }
        const exitFns = [];
        for (let i = 0; i < props.length; i++) {
          const prop = props[i];
          if (prop.type === 7 && matches(prop.name)) {
            props.splice(i, 1);
            i--;
            const onExit = fn(node, prop, context);
            if (onExit) exitFns.push(onExit);
          }
        }
        return exitFns;
      }
    };
  }

  const PURE_ANNOTATION = `/*@__PURE__*/`;
  const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
  function createCodegenContext(ast, {
    mode = "function",
    prefixIdentifiers = mode === "module",
    sourceMap = false,
    filename = `template.vue.html`,
    scopeId = null,
    optimizeImports = false,
    runtimeGlobalName = `Vue`,
    runtimeModuleName = `vue`,
    ssrRuntimeModuleName = "vue/server-renderer",
    ssr = false,
    isTS = false,
    inSSR = false
  }) {
    const context = {
      mode,
      prefixIdentifiers,
      sourceMap,
      filename,
      scopeId,
      optimizeImports,
      runtimeGlobalName,
      runtimeModuleName,
      ssrRuntimeModuleName,
      ssr,
      isTS,
      inSSR,
      source: ast.source,
      code: ``,
      column: 1,
      line: 1,
      offset: 0,
      indentLevel: 0,
      pure: false,
      map: void 0,
      helper(key) {
        return `_${helperNameMap[key]}`;
      },
      push(code, newlineIndex = -2 /* None */, node) {
        context.code += code;
      },
      indent() {
        newline(++context.indentLevel);
      },
      deindent(withoutNewLine = false) {
        if (withoutNewLine) {
          --context.indentLevel;
        } else {
          newline(--context.indentLevel);
        }
      },
      newline() {
        newline(context.indentLevel);
      }
    };
    function newline(n) {
      context.push("\n" + `  `.repeat(n), 0 /* Start */);
    }
    return context;
  }
  function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    if (options.onContextCreated) options.onContextCreated(context);
    const {
      mode,
      push,
      prefixIdentifiers,
      indent,
      deindent,
      newline,
      scopeId,
      ssr
    } = context;
    const helpers = Array.from(ast.helpers);
    const hasHelpers = helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== "module";
    const preambleContext = context;
    {
      genFunctionPreamble(ast, preambleContext);
    }
    const functionName = ssr ? `ssrRender` : `render`;
    const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
    const signature = args.join(", ");
    {
      push(`function ${functionName}(${signature}) {`);
    }
    indent();
    if (useWithBlock) {
      push(`with (_ctx) {`);
      indent();
      if (hasHelpers) {
        push(
          `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
          -1 /* End */
        );
        newline();
      }
    }
    if (ast.components.length) {
      genAssets(ast.components, "component", context);
      if (ast.directives.length || ast.temps > 0) {
        newline();
      }
    }
    if (ast.directives.length) {
      genAssets(ast.directives, "directive", context);
      if (ast.temps > 0) {
        newline();
      }
    }
    if (ast.filters && ast.filters.length) {
      newline();
      genAssets(ast.filters, "filter", context);
      newline();
    }
    if (ast.temps > 0) {
      push(`let `);
      for (let i = 0; i < ast.temps; i++) {
        push(`${i > 0 ? `, ` : ``}_temp${i}`);
      }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
      push(`
`, 0 /* Start */);
      newline();
    }
    if (!ssr) {
      push(`return `);
    }
    if (ast.codegenNode) {
      genNode(ast.codegenNode, context);
    } else {
      push(`null`);
    }
    if (useWithBlock) {
      deindent();
      push(`}`);
    }
    deindent();
    push(`}`);
    return {
      ast,
      code: context.code,
      preamble: ``,
      map: context.map ? context.map.toJSON() : void 0
    };
  }
  function genFunctionPreamble(ast, context) {
    const {
      ssr,
      prefixIdentifiers,
      push,
      newline,
      runtimeModuleName,
      runtimeGlobalName,
      ssrRuntimeModuleName
    } = context;
    const VueBinding = runtimeGlobalName;
    const helpers = Array.from(ast.helpers);
    if (helpers.length > 0) {
      {
        push(`const _Vue = ${VueBinding}
`, -1 /* End */);
        if (ast.hoists.length) {
          const staticHelpers = [
            CREATE_VNODE,
            CREATE_ELEMENT_VNODE,
            CREATE_COMMENT,
            CREATE_TEXT,
            CREATE_STATIC
          ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
          push(`const { ${staticHelpers} } = _Vue
`, -1 /* End */);
        }
      }
    }
    genHoists(ast.hoists, context);
    newline();
    push(`return `);
  }
  function genAssets(assets, type, { helper, push, newline, isTS }) {
    const resolver = helper(
      type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
    );
    for (let i = 0; i < assets.length; i++) {
      let id = assets[i];
      const maybeSelfReference = id.endsWith("__self");
      if (maybeSelfReference) {
        id = id.slice(0, -6);
      }
      push(
        `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
      );
      if (i < assets.length - 1) {
        newline();
      }
    }
  }
  function genHoists(hoists, context) {
    if (!hoists.length) {
      return;
    }
    context.pure = true;
    const { push, newline } = context;
    newline();
    for (let i = 0; i < hoists.length; i++) {
      const exp = hoists[i];
      if (exp) {
        push(`const _hoisted_${i + 1} = `);
        genNode(exp, context);
        newline();
      }
    }
    context.pure = false;
  }
  function isText(n) {
    return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
  }
  function genNodeListAsArray(nodes, context) {
    const multilines = nodes.length > 3 || !!(process.env.NODE_ENV !== "production") && nodes.some((n) => isArray(n) || !isText(n));
    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
  }
  function genNodeList(nodes, context, multilines = false, comma = true) {
    const { push, newline } = context;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (isString(node)) {
        push(node, -3 /* Unknown */);
      } else if (isArray(node)) {
        genNodeListAsArray(node, context);
      } else {
        genNode(node, context);
      }
      if (i < nodes.length - 1) {
        if (multilines) {
          comma && push(",");
          newline();
        } else {
          comma && push(", ");
        }
      }
    }
  }
  function genNode(node, context) {
    if (isString(node)) {
      context.push(node, -3 /* Unknown */);
      return;
    }
    if (isSymbol(node)) {
      context.push(context.helper(node));
      return;
    }
    switch (node.type) {
      case 1:
      case 9:
      case 11:
        !!(process.env.NODE_ENV !== "production") && assert(
          node.codegenNode != null,
          `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
        );
        genNode(node.codegenNode, context);
        break;
      case 2:
        genText(node, context);
        break;
      case 4:
        genExpression(node, context);
        break;
      case 5:
        genInterpolation(node, context);
        break;
      case 12:
        genNode(node.codegenNode, context);
        break;
      case 8:
        genCompoundExpression(node, context);
        break;
      case 3:
        genComment(node, context);
        break;
      case 13:
        genVNodeCall(node, context);
        break;
      case 14:
        genCallExpression(node, context);
        break;
      case 15:
        genObjectExpression(node, context);
        break;
      case 17:
        genArrayExpression(node, context);
        break;
      case 18:
        genFunctionExpression(node, context);
        break;
      case 19:
        genConditionalExpression(node, context);
        break;
      case 20:
        genCacheExpression(node, context);
        break;
      case 21:
        genNodeList(node.body, context, true, false);
        break;
      // SSR only types
      case 22:
        break;
      case 23:
        break;
      case 24:
        break;
      case 25:
        break;
      case 26:
        break;
      /* v8 ignore start */
      case 10:
        break;
      default:
        if (!!(process.env.NODE_ENV !== "production")) {
          assert(false, `unhandled codegen node type: ${node.type}`);
          const exhaustiveCheck = node;
          return exhaustiveCheck;
        }
    }
  }
  function genText(node, context) {
    context.push(JSON.stringify(node.content), -3 /* Unknown */, node);
  }
  function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(
      isStatic ? JSON.stringify(content) : content,
      -3 /* Unknown */,
      node
    );
  }
  function genInterpolation(node, context) {
    const { push, helper, pure } = context;
    if (pure) push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context);
    push(`)`);
  }
  function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (isString(child)) {
        context.push(child, -3 /* Unknown */);
      } else {
        genNode(child, context);
      }
    }
  }
  function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === 8) {
      push(`[`);
      genCompoundExpression(node, context);
      push(`]`);
    } else if (node.isStatic) {
      const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
      push(text, -2 /* None */, node);
    } else {
      push(`[${node.content}]`, -3 /* Unknown */, node);
    }
  }
  function genComment(node, context) {
    const { push, helper, pure } = context;
    if (pure) {
      push(PURE_ANNOTATION);
    }
    push(
      `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
      -3 /* Unknown */,
      node
    );
  }
  function genVNodeCall(node, context) {
    const { push, helper, pure } = context;
    const {
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives,
      isBlock,
      disableTracking,
      isComponent
    } = node;
    let patchFlagString;
    if (patchFlag) {
      if (!!(process.env.NODE_ENV !== "production")) {
        if (patchFlag < 0) {
          patchFlagString = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
        } else {
          const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
          patchFlagString = patchFlag + ` /* ${flagNames} */`;
        }
      } else {
        patchFlagString = String(patchFlag);
      }
    }
    if (directives) {
      push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
      push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
    }
    if (pure) {
      push(PURE_ANNOTATION);
    }
    const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent);
    push(helper(callHelper) + `(`, -2 /* None */, node);
    genNodeList(
      genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),
      context
    );
    push(`)`);
    if (isBlock) {
      push(`)`);
    }
    if (directives) {
      push(`, `);
      genNode(directives, context);
      push(`)`);
    }
  }
  function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
      if (args[i] != null) break;
    }
    return args.slice(0, i + 1).map((arg) => arg || `null`);
  }
  function genCallExpression(node, context) {
    const { push, helper, pure } = context;
    const callee = isString(node.callee) ? node.callee : helper(node.callee);
    if (pure) {
      push(PURE_ANNOTATION);
    }
    push(callee + `(`, -2 /* None */, node);
    genNodeList(node.arguments, context);
    push(`)`);
  }
  function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
      push(`{}`, -2 /* None */, node);
      return;
    }
    const multilines = properties.length > 1 || !!(process.env.NODE_ENV !== "production") && properties.some((p) => p.value.type !== 4);
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      genExpressionAsPropertyKey(key, context);
      push(`: `);
      genNode(value, context);
      if (i < properties.length - 1) {
        push(`,`);
        newline();
      }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
  }
  function genArrayExpression(node, context) {
    genNodeListAsArray(node.elements, context);
  }
  function genFunctionExpression(node, context) {
    const { push, indent, deindent } = context;
    const { params, returns, body, newline, isSlot } = node;
    if (isSlot) {
      push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, -2 /* None */, node);
    if (isArray(params)) {
      genNodeList(params, context);
    } else if (params) {
      genNode(params, context);
    }
    push(`) => `);
    if (newline || body) {
      push(`{`);
      indent();
    }
    if (returns) {
      if (newline) {
        push(`return `);
      }
      if (isArray(returns)) {
        genNodeListAsArray(returns, context);
      } else {
        genNode(returns, context);
      }
    } else if (body) {
      genNode(body, context);
    }
    if (newline || body) {
      deindent();
      push(`}`);
    }
    if (isSlot) {
      if (node.isNonScopedSlot) {
        push(`, undefined, true`);
      }
      push(`)`);
    }
  }
  function genConditionalExpression(node, context) {
    const { test, consequent, alternate, newline: needNewline } = node;
    const { push, indent, deindent, newline } = context;
    if (test.type === 4) {
      const needsParens = !isSimpleIdentifier(test.content);
      needsParens && push(`(`);
      genExpression(test, context);
      needsParens && push(`)`);
    } else {
      push(`(`);
      genNode(test, context);
      push(`)`);
    }
    needNewline && indent();
    context.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context);
    context.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19;
    if (!isNested) {
      context.indentLevel++;
    }
    genNode(alternate, context);
    if (!isNested) {
      context.indentLevel--;
    }
    needNewline && deindent(
      true
      /* without newline */
    );
  }
  function genCacheExpression(node, context) {
    const { push, helper, indent, deindent, newline } = context;
    const { needPauseTracking, needArraySpread } = node;
    if (needArraySpread) {
      push(`[...(`);
    }
    push(`_cache[${node.index}] || (`);
    if (needPauseTracking) {
      indent();
      push(`${helper(SET_BLOCK_TRACKING)}(-1`);
      if (node.inVOnce) push(`, true`);
      push(`),`);
      newline();
      push(`(`);
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context);
    if (needPauseTracking) {
      push(`).cacheIndex = ${node.index},`);
      newline();
      push(`${helper(SET_BLOCK_TRACKING)}(1),`);
      newline();
      push(`_cache[${node.index}]`);
      deindent();
    }
    push(`)`);
    if (needArraySpread) {
      push(`)]`);
    }
  }

  const prohibitedKeywordRE = new RegExp(
    "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
  );
  const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
  function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
    const exp = node.content;
    if (!exp.trim()) {
      return;
    }
    try {
      new Function(
        asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
      );
    } catch (e) {
      let message = e.message;
      const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
      if (keywordMatch) {
        message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
      }
      context.onError(
        createCompilerError(
          45,
          node.loc,
          void 0,
          message
        )
      );
    }
  }

  const transformExpression = (node, context) => {
    if (node.type === 5) {
      node.content = processExpression(
        node.content,
        context
      );
    } else if (node.type === 1) {
      const memo = findDir(node, "memo");
      for (let i = 0; i < node.props.length; i++) {
        const dir = node.props[i];
        if (dir.type === 7 && dir.name !== "for") {
          const exp = dir.exp;
          const arg = dir.arg;
          if (exp && exp.type === 4 && !(dir.name === "on" && arg) && // key has been processed in transformFor(vMemo + vFor)
          !(memo && arg && arg.type === 4 && arg.content === "key")) {
            dir.exp = processExpression(
              exp,
              context,
              // slot args must be processed as function params
              dir.name === "slot"
            );
          }
          if (arg && arg.type === 4 && !arg.isStatic) {
            dir.arg = processExpression(arg, context);
          }
        }
      }
    }
  };
  function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
    {
      if (!!(process.env.NODE_ENV !== "production")) {
        validateBrowserExpression(node, context, asParams, asRawStatements);
      }
      return node;
    }
  }

  const transformIf = createStructuralDirectiveTransform(
    /^(?:if|else|else-if)$/,
    (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
          const sibling = siblings[i];
          if (sibling && sibling.type === 9) {
            key += sibling.branches.length;
          }
        }
        return () => {
          if (isRoot) {
            ifNode.codegenNode = createCodegenNodeForBranch(
              branch,
              key,
              context
            );
          } else {
            const parentCondition = getParentCondition(ifNode.codegenNode);
            parentCondition.alternate = createCodegenNodeForBranch(
              branch,
              key + ifNode.branches.length - 1,
              context
            );
          }
        };
      });
    }
  );
  function processIf(node, dir, context, processCodegen) {
    if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
      const loc = dir.exp ? dir.exp.loc : node.loc;
      context.onError(
        createCompilerError(28, dir.loc)
      );
      dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if (!!(process.env.NODE_ENV !== "production") && true && dir.exp) {
      validateBrowserExpression(dir.exp, context);
    }
    if (dir.name === "if") {
      const branch = createIfBranch(node, dir);
      const ifNode = {
        type: 9,
        loc: cloneLoc(node.loc),
        branches: [branch]
      };
      context.replaceNode(ifNode);
      if (processCodegen) {
        return processCodegen(ifNode, branch, true);
      }
    } else {
      const siblings = context.parent.children;
      const comments = [];
      let i = siblings.indexOf(node);
      while (i-- >= -1) {
        const sibling = siblings[i];
        if (sibling && sibling.type === 3) {
          context.removeNode(sibling);
          !!(process.env.NODE_ENV !== "production") && comments.unshift(sibling);
          continue;
        }
        if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
          context.removeNode(sibling);
          continue;
        }
        if (sibling && sibling.type === 9) {
          if ((dir.name === "else-if" || dir.name === "else") && sibling.branches[sibling.branches.length - 1].condition === void 0) {
            context.onError(
              createCompilerError(30, node.loc)
            );
          }
          context.removeNode();
          const branch = createIfBranch(node, dir);
          if (!!(process.env.NODE_ENV !== "production") && comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
          !(context.parent && context.parent.type === 1 && (context.parent.tag === "transition" || context.parent.tag === "Transition"))) {
            branch.children = [...comments, ...branch.children];
          }
          if (!!(process.env.NODE_ENV !== "production") || false) {
            const key = branch.userKey;
            if (key) {
              sibling.branches.forEach(({ userKey }) => {
                if (isSameKey(userKey, key)) {
                  context.onError(
                    createCompilerError(
                      29,
                      branch.userKey.loc
                    )
                  );
                }
              });
            }
          }
          sibling.branches.push(branch);
          const onExit = processCodegen && processCodegen(sibling, branch, false);
          traverseNode(branch, context);
          if (onExit) onExit();
          context.currentNode = null;
        } else {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        break;
      }
    }
  }
  function createIfBranch(node, dir) {
    const isTemplateIf = node.tagType === 3;
    return {
      type: 10,
      loc: node.loc,
      condition: dir.name === "else" ? void 0 : dir.exp,
      children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
      userKey: findProp(node, `key`),
      isTemplateIf
    };
  }
  function createCodegenNodeForBranch(branch, keyIndex, context) {
    if (branch.condition) {
      return createConditionalExpression(
        branch.condition,
        createChildrenCodegenNode(branch, keyIndex, context),
        // make sure to pass in asBlock: true so that the comment node call
        // closes the current block.
        createCallExpression(context.helper(CREATE_COMMENT), [
          !!(process.env.NODE_ENV !== "production") ? '"v-if"' : '""',
          "true"
        ])
      );
    } else {
      return createChildrenCodegenNode(branch, keyIndex, context);
    }
  }
  function createChildrenCodegenNode(branch, keyIndex, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(
      `key`,
      createSimpleExpression(
        `${keyIndex}`,
        false,
        locStub,
        2
      )
    );
    const { children } = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
    if (needFragmentWrapper) {
      if (children.length === 1 && firstChild.type === 11) {
        const vnodeCall = firstChild.codegenNode;
        injectProp(vnodeCall, keyProperty, context);
        return vnodeCall;
      } else {
        let patchFlag = 64;
        if (!!(process.env.NODE_ENV !== "production") && !branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
          patchFlag |= 2048;
        }
        return createVNodeCall(
          context,
          helper(FRAGMENT),
          createObjectExpression([keyProperty]),
          children,
          patchFlag,
          void 0,
          void 0,
          true,
          false,
          false,
          branch.loc
        );
      }
    } else {
      const ret = firstChild.codegenNode;
      const vnodeCall = getMemoedVNodeCall(ret);
      if (vnodeCall.type === 13) {
        convertToBlock(vnodeCall, context);
      }
      injectProp(vnodeCall, keyProperty, context);
      return ret;
    }
  }
  function isSameKey(a, b) {
    if (!a || a.type !== b.type) {
      return false;
    }
    if (a.type === 6) {
      if (a.value.content !== b.value.content) {
        return false;
      }
    } else {
      const exp = a.exp;
      const branchExp = b.exp;
      if (exp.type !== branchExp.type) {
        return false;
      }
      if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
        return false;
      }
    }
    return true;
  }
  function getParentCondition(node) {
    while (true) {
      if (node.type === 19) {
        if (node.alternate.type === 19) {
          node = node.alternate;
        } else {
          return node;
        }
      } else if (node.type === 20) {
        node = node.value;
      }
    }
  }

  const transformFor = createStructuralDirectiveTransform(
    "for",
    (node, dir, context) => {
      const { helper, removeHelper } = context;
      return processFor(node, dir, context, (forNode) => {
        const renderExp = createCallExpression(helper(RENDER_LIST), [
          forNode.source
        ]);
        const isTemplate = isTemplateNode(node);
        const memo = findDir(node, "memo");
        const keyProp = findProp(node, `key`, false, true);
        keyProp && keyProp.type === 7;
        let keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
        const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
        const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
        forNode.codegenNode = createVNodeCall(
          context,
          helper(FRAGMENT),
          void 0,
          renderExp,
          fragmentFlag,
          void 0,
          void 0,
          true,
          !isStableFragment,
          false,
          node.loc
        );
        return () => {
          let childBlock;
          const { children } = forNode;
          if ((!!(process.env.NODE_ENV !== "production") || false) && isTemplate) {
            node.children.some((c) => {
              if (c.type === 1) {
                const key = findProp(c, "key");
                if (key) {
                  context.onError(
                    createCompilerError(
                      33,
                      key.loc
                    )
                  );
                  return true;
                }
              }
            });
          }
          const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
          const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
          if (slotOutlet) {
            childBlock = slotOutlet.codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
          } else if (needFragmentWrapper) {
            childBlock = createVNodeCall(
              context,
              helper(FRAGMENT),
              keyProperty ? createObjectExpression([keyProperty]) : void 0,
              node.children,
              64,
              void 0,
              void 0,
              true,
              void 0,
              false
            );
          } else {
            childBlock = children[0].codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
            if (childBlock.isBlock !== !isStableFragment) {
              if (childBlock.isBlock) {
                removeHelper(OPEN_BLOCK);
                removeHelper(
                  getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                );
              } else {
                removeHelper(
                  getVNodeHelper(context.inSSR, childBlock.isComponent)
                );
              }
            }
            childBlock.isBlock = !isStableFragment;
            if (childBlock.isBlock) {
              helper(OPEN_BLOCK);
              helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
            } else {
              helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
            }
          }
          if (memo) {
            const loop = createFunctionExpression(
              createForLoopParams(forNode.parseResult, [
                createSimpleExpression(`_cached`)
              ])
            );
            loop.body = createBlockStatement([
              createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
              createCompoundExpression([
                `if (_cached`,
                ...keyExp ? [` && _cached.key === `, keyExp] : [],
                ` && ${context.helperString(
                IS_MEMO_SAME
              )}(_cached, _memo)) return _cached`
              ]),
              createCompoundExpression([`const _item = `, childBlock]),
              createSimpleExpression(`_item.memo = _memo`),
              createSimpleExpression(`return _item`)
            ]);
            renderExp.arguments.push(
              loop,
              createSimpleExpression(`_cache`),
              createSimpleExpression(String(context.cached.length))
            );
            context.cached.push(null);
          } else {
            renderExp.arguments.push(
              createFunctionExpression(
                createForLoopParams(forNode.parseResult),
                childBlock,
                true
              )
            );
          }
        };
      });
    }
  );
  function processFor(node, dir, context, processCodegen) {
    if (!dir.exp) {
      context.onError(
        createCompilerError(31, dir.loc)
      );
      return;
    }
    const parseResult = dir.forParseResult;
    if (!parseResult) {
      context.onError(
        createCompilerError(32, dir.loc)
      );
      return;
    }
    finalizeForParseResult(parseResult, context);
    const { addIdentifiers, removeIdentifiers, scopes } = context;
    const { source, value, key, index } = parseResult;
    const forNode = {
      type: 11,
      loc: dir.loc,
      source,
      valueAlias: value,
      keyAlias: key,
      objectIndexAlias: index,
      parseResult,
      children: isTemplateNode(node) ? node.children : [node]
    };
    context.replaceNode(forNode);
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
      scopes.vFor--;
      if (onExit) onExit();
    };
  }
  function finalizeForParseResult(result, context) {
    if (result.finalized) return;
    if (!!(process.env.NODE_ENV !== "production") && true) {
      validateBrowserExpression(result.source, context);
      if (result.key) {
        validateBrowserExpression(
          result.key,
          context,
          true
        );
      }
      if (result.index) {
        validateBrowserExpression(
          result.index,
          context,
          true
        );
      }
      if (result.value) {
        validateBrowserExpression(
          result.value,
          context,
          true
        );
      }
    }
    result.finalized = true;
  }
  function createForLoopParams({ value, key, index }, memoArgs = []) {
    return createParamsList([value, key, index, ...memoArgs]);
  }
  function createParamsList(args) {
    let i = args.length;
    while (i--) {
      if (args[i]) break;
    }
    return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
  }

  const defaultFallback = createSimpleExpression(`undefined`, false);
  const trackSlotScopes = (node, context) => {
    if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
      const vSlot = findDir(node, "slot");
      if (vSlot) {
        vSlot.exp;
        context.scopes.vSlot++;
        return () => {
          context.scopes.vSlot--;
        };
      }
    }
  };
  const buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
    props,
    children,
    false,
    true,
    children.length ? children[0].loc : loc
  );
  function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
    context.helper(WITH_CTX);
    const { children, loc } = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
    const onComponentSlot = findDir(node, "slot", true);
    if (onComponentSlot) {
      const { arg, exp } = onComponentSlot;
      if (arg && !isStaticExp(arg)) {
        hasDynamicSlots = true;
      }
      slotsProperties.push(
        createObjectProperty(
          arg || createSimpleExpression("default", true),
          buildSlotFn(exp, void 0, children, loc)
        )
      );
    }
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = /* @__PURE__ */ new Set();
    let conditionalBranchIndex = 0;
    for (let i = 0; i < children.length; i++) {
      const slotElement = children[i];
      let slotDir;
      if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
        if (slotElement.type !== 3) {
          implicitDefaultChildren.push(slotElement);
        }
        continue;
      }
      if (onComponentSlot) {
        context.onError(
          createCompilerError(37, slotDir.loc)
        );
        break;
      }
      hasTemplateSlots = true;
      const { children: slotChildren, loc: slotLoc } = slotElement;
      const {
        arg: slotName = createSimpleExpression(`default`, true),
        exp: slotProps,
        loc: dirLoc
      } = slotDir;
      let staticSlotName;
      if (isStaticExp(slotName)) {
        staticSlotName = slotName ? slotName.content : `default`;
      } else {
        hasDynamicSlots = true;
      }
      const vFor = findDir(slotElement, "for");
      const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
      let vIf;
      let vElse;
      if (vIf = findDir(slotElement, "if")) {
        hasDynamicSlots = true;
        dynamicSlots.push(
          createConditionalExpression(
            vIf.exp,
            buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
            defaultFallback
          )
        );
      } else if (vElse = findDir(
        slotElement,
        /^else(?:-if)?$/,
        true
        /* allowEmpty */
      )) {
        let j = i;
        let prev;
        while (j--) {
          prev = children[j];
          if (prev.type !== 3 && isNonWhitespaceContent(prev)) {
            break;
          }
        }
        if (prev && isTemplateNode(prev) && findDir(prev, /^(?:else-)?if$/)) {
          let conditional = dynamicSlots[dynamicSlots.length - 1];
          while (conditional.alternate.type === 19) {
            conditional = conditional.alternate;
          }
          conditional.alternate = vElse.exp ? createConditionalExpression(
            vElse.exp,
            buildDynamicSlot(
              slotName,
              slotFunction,
              conditionalBranchIndex++
            ),
            defaultFallback
          ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
        } else {
          context.onError(
            createCompilerError(30, vElse.loc)
          );
        }
      } else if (vFor) {
        hasDynamicSlots = true;
        const parseResult = vFor.forParseResult;
        if (parseResult) {
          finalizeForParseResult(parseResult, context);
          dynamicSlots.push(
            createCallExpression(context.helper(RENDER_LIST), [
              parseResult.source,
              createFunctionExpression(
                createForLoopParams(parseResult),
                buildDynamicSlot(slotName, slotFunction),
                true
              )
            ])
          );
        } else {
          context.onError(
            createCompilerError(
              32,
              vFor.loc
            )
          );
        }
      } else {
        if (staticSlotName) {
          if (seenSlotNames.has(staticSlotName)) {
            context.onError(
              createCompilerError(
                38,
                dirLoc
              )
            );
            continue;
          }
          seenSlotNames.add(staticSlotName);
          if (staticSlotName === "default") {
            hasNamedDefaultSlot = true;
          }
        }
        slotsProperties.push(createObjectProperty(slotName, slotFunction));
      }
    }
    if (!onComponentSlot) {
      const buildDefaultSlotProperty = (props, children2) => {
        const fn = buildSlotFn(props, void 0, children2, loc);
        if (context.compatConfig) {
          fn.isNonScopedSlot = true;
        }
        return createObjectProperty(`default`, fn);
      };
      if (!hasTemplateSlots) {
        slotsProperties.push(buildDefaultSlotProperty(void 0, children));
      } else if (implicitDefaultChildren.length && // #3766
      // with whitespace: 'preserve', whitespaces between slots will end up in
      // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
      implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
        if (hasNamedDefaultSlot) {
          context.onError(
            createCompilerError(
              39,
              implicitDefaultChildren[0].loc
            )
          );
        } else {
          slotsProperties.push(
            buildDefaultSlotProperty(void 0, implicitDefaultChildren)
          );
        }
      }
    }
    const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
    let slots = createObjectExpression(
      slotsProperties.concat(
        createObjectProperty(
          `_`,
          // 2 = compiled but dynamic = can skip normalization, but must run diff
          // 1 = compiled and static = can skip normalization AND diff as optimized
          createSimpleExpression(
            slotFlag + (!!(process.env.NODE_ENV !== "production") ? ` /* ${slotFlagsText[slotFlag]} */` : ``),
            false
          )
        )
      ),
      loc
    );
    if (dynamicSlots.length) {
      slots = createCallExpression(context.helper(CREATE_SLOTS), [
        slots,
        createArrayExpression(dynamicSlots)
      ]);
    }
    return {
      slots,
      hasDynamicSlots
    };
  }
  function buildDynamicSlot(name, fn, index) {
    const props = [
      createObjectProperty(`name`, name),
      createObjectProperty(`fn`, fn)
    ];
    if (index != null) {
      props.push(
        createObjectProperty(`key`, createSimpleExpression(String(index), true))
      );
    }
    return createObjectExpression(props);
  }
  function hasForwardedSlots(children) {
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      switch (child.type) {
        case 1:
          if (child.tagType === 2 || hasForwardedSlots(child.children)) {
            return true;
          }
          break;
        case 9:
          if (hasForwardedSlots(child.branches)) return true;
          break;
        case 10:
        case 11:
          if (hasForwardedSlots(child.children)) return true;
          break;
      }
    }
    return false;
  }
  function isNonWhitespaceContent(node) {
    if (node.type !== 2 && node.type !== 12)
      return true;
    return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
  }

  const directiveImportMap = /* @__PURE__ */ new WeakMap();
  const transformElement = (node, context) => {
    return function postTransformElement() {
      node = context.currentNode;
      if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
        return;
      }
      const { tag, props } = node;
      const isComponent = node.tagType === 1;
      let vnodeTag = isComponent ? resolveComponentType(node, context) : `"${tag}"`;
      const isDynamicComponent = isObject$1(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
      let vnodeProps;
      let vnodeChildren;
      let patchFlag = 0;
      let vnodeDynamicProps;
      let dynamicPropNames;
      let vnodeDirectives;
      let shouldUseBlock = (
        // dynamic component may resolve to plain elements
        isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && // <svg> and <foreignObject> must be forced into blocks so that block
        // updates inside get proper isSVG flag at runtime. (#639, #643)
        // This is technically web-specific, but splitting the logic out of core
        // leads to too much unnecessary complexity.
        (tag === "svg" || tag === "foreignObject" || tag === "math")
      );
      if (props.length > 0) {
        const propsBuildResult = buildProps(
          node,
          context,
          void 0,
          isComponent,
          isDynamicComponent
        );
        vnodeProps = propsBuildResult.props;
        patchFlag = propsBuildResult.patchFlag;
        dynamicPropNames = propsBuildResult.dynamicPropNames;
        const directives = propsBuildResult.directives;
        vnodeDirectives = directives && directives.length ? createArrayExpression(
          directives.map((dir) => buildDirectiveArgs(dir, context))
        ) : void 0;
        if (propsBuildResult.shouldUseBlock) {
          shouldUseBlock = true;
        }
      }
      if (node.children.length > 0) {
        if (vnodeTag === KEEP_ALIVE) {
          shouldUseBlock = true;
          patchFlag |= 1024;
          if (!!(process.env.NODE_ENV !== "production") && node.children.length > 1) {
            context.onError(
              createCompilerError(46, {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              })
            );
          }
        }
        const shouldBuildAsSlots = isComponent && // Teleport is not a real component and has dedicated runtime handling
        vnodeTag !== TELEPORT && // explained above.
        vnodeTag !== KEEP_ALIVE;
        if (shouldBuildAsSlots) {
          const { slots, hasDynamicSlots } = buildSlots(node, context);
          vnodeChildren = slots;
          if (hasDynamicSlots) {
            patchFlag |= 1024;
          }
        } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
          const child = node.children[0];
          const type = child.type;
          const hasDynamicTextChild = type === 5 || type === 8;
          if (hasDynamicTextChild && getConstantType(child, context) === 0) {
            patchFlag |= 1;
          }
          if (hasDynamicTextChild || type === 2) {
            vnodeChildren = child;
          } else {
            vnodeChildren = node.children;
          }
        } else {
          vnodeChildren = node.children;
        }
      }
      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
      }
      node.codegenNode = createVNodeCall(
        context,
        vnodeTag,
        vnodeProps,
        vnodeChildren,
        patchFlag === 0 ? void 0 : patchFlag,
        vnodeDynamicProps,
        vnodeDirectives,
        !!shouldUseBlock,
        false,
        isComponent,
        node.loc
      );
    };
  };
  function resolveComponentType(node, context, ssr = false) {
    let { tag } = node;
    const isExplicitDynamic = isComponentTag(tag);
    const isProp = findProp(
      node,
      "is",
      false,
      true
      /* allow empty */
    );
    if (isProp) {
      if (isExplicitDynamic || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      )) {
        let exp;
        if (isProp.type === 6) {
          exp = isProp.value && createSimpleExpression(isProp.value.content, true);
        } else {
          exp = isProp.exp;
          if (!exp) {
            exp = createSimpleExpression(`is`, false, isProp.arg.loc);
          }
        }
        if (exp) {
          return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
            exp
          ]);
        }
      } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
        tag = isProp.value.content.slice(4);
      }
    }
    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
    if (builtIn) {
      if (!ssr) context.helper(builtIn);
      return builtIn;
    }
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag);
    return toValidAssetId(tag, `component`);
  }
  function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
    const { tag, loc: elementLoc, children } = node;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    const hasChildren = children.length > 0;
    let shouldUseBlock = false;
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    let hasVnodeHook = false;
    const dynamicPropNames = [];
    const pushMergeArg = (arg) => {
      if (properties.length) {
        mergeArgs.push(
          createObjectExpression(dedupeProperties(properties), elementLoc)
        );
        properties = [];
      }
      if (arg) mergeArgs.push(arg);
    };
    const pushRefVForMarker = () => {
      if (context.scopes.vFor > 0) {
        properties.push(
          createObjectProperty(
            createSimpleExpression("ref_for", true),
            createSimpleExpression("true")
          )
        );
      }
    };
    const analyzePatchFlag = ({ key, value }) => {
      if (isStaticExp(key)) {
        const name = key.content;
        const isEventHandler = isOn(name);
        if (isEventHandler && (!isComponent || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
        // dedicated fast path.
        name.toLowerCase() !== "onclick" && // omit v-model handlers
        name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
        !isReservedProp(name)) {
          hasHydrationEventBinding = true;
        }
        if (isEventHandler && isReservedProp(name)) {
          hasVnodeHook = true;
        }
        if (isEventHandler && value.type === 14) {
          value = value.arguments[0];
        }
        if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
          return;
        }
        if (name === "ref") {
          hasRef = true;
        } else if (name === "class") {
          hasClassBinding = true;
        } else if (name === "style") {
          hasStyleBinding = true;
        } else if (name !== "key" && !dynamicPropNames.includes(name)) {
          dynamicPropNames.push(name);
        }
        if (isComponent && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
          dynamicPropNames.push(name);
        }
      } else {
        hasDynamicKeys = true;
      }
    };
    for (let i = 0; i < props.length; i++) {
      const prop = props[i];
      if (prop.type === 6) {
        const { loc, name, nameLoc, value } = prop;
        let isStatic = true;
        if (name === "ref") {
          hasRef = true;
          pushRefVForMarker();
        }
        if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          context
        ))) {
          continue;
        }
        properties.push(
          createObjectProperty(
            createSimpleExpression(name, true, nameLoc),
            createSimpleExpression(
              value ? value.content : "",
              isStatic,
              value ? value.loc : loc
            )
          )
        );
      } else {
        const { name, arg, exp, loc, modifiers } = prop;
        const isVBind = name === "bind";
        const isVOn = name === "on";
        if (name === "slot") {
          if (!isComponent) {
            context.onError(
              createCompilerError(40, loc)
            );
          }
          continue;
        }
        if (name === "once" || name === "memo") {
          continue;
        }
        if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          context
        ))) {
          continue;
        }
        if (isVOn && ssr) {
          continue;
        }
        if (
          // #938: elements with dynamic keys should be forced into blocks
          isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
          // before children
          isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
        ) {
          shouldUseBlock = true;
        }
        if (isVBind && isStaticArgOf(arg, "ref")) {
          pushRefVForMarker();
        }
        if (!arg && (isVBind || isVOn)) {
          hasDynamicKeys = true;
          if (exp) {
            if (isVBind) {
              {
                pushMergeArg();
                if (!!(process.env.NODE_ENV !== "production")) {
                  const hasOverridableKeys = mergeArgs.some((arg2) => {
                    if (arg2.type === 15) {
                      return arg2.properties.some(({ key }) => {
                        if (key.type !== 4 || !key.isStatic) {
                          return true;
                        }
                        return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                      });
                    } else {
                      return true;
                    }
                  });
                  if (hasOverridableKeys) {
                    checkCompatEnabled(
                      "COMPILER_V_BIND_OBJECT_ORDER",
                      context,
                      loc
                    );
                  }
                }
                if (isCompatEnabled(
                  "COMPILER_V_BIND_OBJECT_ORDER",
                  context
                )) {
                  mergeArgs.unshift(exp);
                  continue;
                }
              }
              pushRefVForMarker();
              pushMergeArg();
              mergeArgs.push(exp);
            } else {
              pushMergeArg({
                type: 14,
                loc,
                callee: context.helper(TO_HANDLERS),
                arguments: isComponent ? [exp] : [exp, `true`]
              });
            }
          } else {
            context.onError(
              createCompilerError(
                isVBind ? 34 : 35,
                loc
              )
            );
          }
          continue;
        }
        if (isVBind && modifiers.some((mod) => mod.content === "prop")) {
          patchFlag |= 32;
        }
        const directiveTransform = context.directiveTransforms[name];
        if (directiveTransform) {
          const { props: props2, needRuntime } = directiveTransform(prop, node, context);
          !ssr && props2.forEach(analyzePatchFlag);
          if (isVOn && arg && !isStaticExp(arg)) {
            pushMergeArg(createObjectExpression(props2, elementLoc));
          } else {
            properties.push(...props2);
          }
          if (needRuntime) {
            runtimeDirectives.push(prop);
            if (isSymbol(needRuntime)) {
              directiveImportMap.set(prop, needRuntime);
            }
          }
        } else if (!isBuiltInDirective(name)) {
          runtimeDirectives.push(prop);
          if (hasChildren) {
            shouldUseBlock = true;
          }
        }
      }
    }
    let propsExpression = void 0;
    if (mergeArgs.length) {
      pushMergeArg();
      if (mergeArgs.length > 1) {
        propsExpression = createCallExpression(
          context.helper(MERGE_PROPS),
          mergeArgs,
          elementLoc
        );
      } else {
        propsExpression = mergeArgs[0];
      }
    } else if (properties.length) {
      propsExpression = createObjectExpression(
        dedupeProperties(properties),
        elementLoc
      );
    }
    if (hasDynamicKeys) {
      patchFlag |= 16;
    } else {
      if (hasClassBinding && !isComponent) {
        patchFlag |= 2;
      }
      if (hasStyleBinding && !isComponent) {
        patchFlag |= 4;
      }
      if (dynamicPropNames.length) {
        patchFlag |= 8;
      }
      if (hasHydrationEventBinding) {
        patchFlag |= 32;
      }
    }
    if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
      patchFlag |= 512;
    }
    if (!context.inSSR && propsExpression) {
      switch (propsExpression.type) {
        case 15:
          let classKeyIndex = -1;
          let styleKeyIndex = -1;
          let hasDynamicKey = false;
          for (let i = 0; i < propsExpression.properties.length; i++) {
            const key = propsExpression.properties[i].key;
            if (isStaticExp(key)) {
              if (key.content === "class") {
                classKeyIndex = i;
              } else if (key.content === "style") {
                styleKeyIndex = i;
              }
            } else if (!key.isHandlerKey) {
              hasDynamicKey = true;
            }
          }
          const classProp = propsExpression.properties[classKeyIndex];
          const styleProp = propsExpression.properties[styleKeyIndex];
          if (!hasDynamicKey) {
            if (classProp && !isStaticExp(classProp.value)) {
              classProp.value = createCallExpression(
                context.helper(NORMALIZE_CLASS),
                [classProp.value]
              );
            }
            if (styleProp && // the static style is compiled into an object,
            // so use `hasStyleBinding` to ensure that it is a dynamic style binding
            (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
            // v-bind:style with static literal object
            styleProp.value.type === 17)) {
              styleProp.value = createCallExpression(
                context.helper(NORMALIZE_STYLE),
                [styleProp.value]
              );
            }
          } else {
            propsExpression = createCallExpression(
              context.helper(NORMALIZE_PROPS),
              [propsExpression]
            );
          }
          break;
        case 14:
          break;
        default:
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [
              createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                propsExpression
              ])
            ]
          );
          break;
      }
    }
    return {
      props: propsExpression,
      directives: runtimeDirectives,
      patchFlag,
      dynamicPropNames,
      shouldUseBlock
    };
  }
  function dedupeProperties(properties) {
    const knownProps = /* @__PURE__ */ new Map();
    const deduped = [];
    for (let i = 0; i < properties.length; i++) {
      const prop = properties[i];
      if (prop.key.type === 8 || !prop.key.isStatic) {
        deduped.push(prop);
        continue;
      }
      const name = prop.key.content;
      const existing = knownProps.get(name);
      if (existing) {
        if (name === "style" || name === "class" || isOn(name)) {
          mergeAsArray(existing, prop);
        }
      } else {
        knownProps.set(name, prop);
        deduped.push(prop);
      }
    }
    return deduped;
  }
  function mergeAsArray(existing, incoming) {
    if (existing.value.type === 17) {
      existing.value.elements.push(incoming.value);
    } else {
      existing.value = createArrayExpression(
        [existing.value, incoming.value],
        existing.loc
      );
    }
  }
  function buildDirectiveArgs(dir, context) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
      dirArgs.push(context.helperString(runtime));
    } else {
      {
        context.helper(RESOLVE_DIRECTIVE);
        context.directives.add(dir.name);
        dirArgs.push(toValidAssetId(dir.name, `directive`));
      }
    }
    const { loc } = dir;
    if (dir.exp) dirArgs.push(dir.exp);
    if (dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
      if (!dir.arg) {
        if (!dir.exp) {
          dirArgs.push(`void 0`);
        }
        dirArgs.push(`void 0`);
      }
      const trueExpression = createSimpleExpression(`true`, false, loc);
      dirArgs.push(
        createObjectExpression(
          dir.modifiers.map(
            (modifier) => createObjectProperty(modifier, trueExpression)
          ),
          loc
        )
      );
    }
    return createArrayExpression(dirArgs, dir.loc);
  }
  function stringifyDynamicPropNames(props) {
    let propsNamesString = `[`;
    for (let i = 0, l = props.length; i < l; i++) {
      propsNamesString += JSON.stringify(props[i]);
      if (i < l - 1) propsNamesString += ", ";
    }
    return propsNamesString + `]`;
  }
  function isComponentTag(tag) {
    return tag === "component" || tag === "Component";
  }

  const transformSlotOutlet = (node, context) => {
    if (isSlotOutlet(node)) {
      const { children, loc } = node;
      const { slotName, slotProps } = processSlotOutlet(node, context);
      const slotArgs = [
        context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
        slotName,
        "{}",
        "undefined",
        "true"
      ];
      let expectedLen = 2;
      if (slotProps) {
        slotArgs[2] = slotProps;
        expectedLen = 3;
      }
      if (children.length) {
        slotArgs[3] = createFunctionExpression([], children, false, false, loc);
        expectedLen = 4;
      }
      if (context.scopeId && !context.slotted) {
        expectedLen = 5;
      }
      slotArgs.splice(expectedLen);
      node.codegenNode = createCallExpression(
        context.helper(RENDER_SLOT),
        slotArgs,
        loc
      );
    }
  };
  function processSlotOutlet(node, context) {
    let slotName = `"default"`;
    let slotProps = void 0;
    const nonNameProps = [];
    for (let i = 0; i < node.props.length; i++) {
      const p = node.props[i];
      if (p.type === 6) {
        if (p.value) {
          if (p.name === "name") {
            slotName = JSON.stringify(p.value.content);
          } else {
            p.name = camelize(p.name);
            nonNameProps.push(p);
          }
        }
      } else {
        if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
          if (p.exp) {
            slotName = p.exp;
          } else if (p.arg && p.arg.type === 4) {
            const name = camelize(p.arg.content);
            slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
          }
        } else {
          if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
            p.arg.content = camelize(p.arg.content);
          }
          nonNameProps.push(p);
        }
      }
    }
    if (nonNameProps.length > 0) {
      const { props, directives } = buildProps(
        node,
        context,
        nonNameProps,
        false,
        false
      );
      slotProps = props;
      if (directives.length) {
        context.onError(
          createCompilerError(
            36,
            directives[0].loc
          )
        );
      }
    }
    return {
      slotName,
      slotProps
    };
  }

  const transformOn$1 = (dir, node, context, augmentor) => {
    const { loc, modifiers, arg } = dir;
    if (!dir.exp && !modifiers.length) {
      context.onError(createCompilerError(35, loc));
    }
    let eventName;
    if (arg.type === 4) {
      if (arg.isStatic) {
        let rawName = arg.content;
        if (!!(process.env.NODE_ENV !== "production") && rawName.startsWith("vnode")) {
          context.onError(createCompilerError(51, arg.loc));
        }
        if (rawName.startsWith("vue:")) {
          rawName = `vnode-${rawName.slice(4)}`;
        }
        const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
          // for non-element and vnode lifecycle event listeners, auto convert
          // it to camelCase. See issue #2249
          toHandlerKey(camelize(rawName))
        ) : (
          // preserve case for plain element listeners that have uppercase
          // letters, as these may be custom elements' custom events
          `on:${rawName}`
        );
        eventName = createSimpleExpression(eventString, true, arg.loc);
      } else {
        eventName = createCompoundExpression([
          `${context.helperString(TO_HANDLER_KEY)}(`,
          arg,
          `)`
        ]);
      }
    } else {
      eventName = arg;
      eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
      eventName.children.push(`)`);
    }
    let exp = dir.exp;
    if (exp && !exp.content.trim()) {
      exp = void 0;
    }
    let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
    if (exp) {
      const isMemberExp = isMemberExpression(exp);
      const isInlineStatement = !(isMemberExp || isFnExpression(exp));
      const hasMultipleStatements = exp.content.includes(`;`);
      if (!!(process.env.NODE_ENV !== "production") && true) {
        validateBrowserExpression(
          exp,
          context,
          false,
          hasMultipleStatements
        );
      }
      if (isInlineStatement || shouldCache && isMemberExp) {
        exp = createCompoundExpression([
          `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
          exp,
          hasMultipleStatements ? `}` : `)`
        ]);
      }
    }
    let ret = {
      props: [
        createObjectProperty(
          eventName,
          exp || createSimpleExpression(`() => {}`, false, loc)
        )
      ]
    };
    if (augmentor) {
      ret = augmentor(ret);
    }
    if (shouldCache) {
      ret.props[0].value = context.cache(ret.props[0].value);
    }
    ret.props.forEach((p) => p.key.isHandlerKey = true);
    return ret;
  };

  const transformBind = (dir, _node, context) => {
    const { modifiers, loc } = dir;
    const arg = dir.arg;
    let { exp } = dir;
    if (exp && exp.type === 4 && !exp.content.trim()) {
      {
        exp = void 0;
      }
    }
    if (arg.type !== 4) {
      arg.children.unshift(`(`);
      arg.children.push(`) || ""`);
    } else if (!arg.isStatic) {
      arg.content = arg.content ? `${arg.content} || ""` : `""`;
    }
    if (modifiers.some((mod) => mod.content === "camel")) {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = camelize(arg.content);
        } else {
          arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
        }
      } else {
        arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
        arg.children.push(`)`);
      }
    }
    if (!context.inSSR) {
      if (modifiers.some((mod) => mod.content === "prop")) {
        injectPrefix(arg, ".");
      }
      if (modifiers.some((mod) => mod.content === "attr")) {
        injectPrefix(arg, "^");
      }
    }
    return {
      props: [createObjectProperty(arg, exp)]
    };
  };
  const injectPrefix = (arg, prefix) => {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = prefix + arg.content;
      } else {
        arg.content = `\`${prefix}\${${arg.content}}\``;
      }
    } else {
      arg.children.unshift(`'${prefix}' + (`);
      arg.children.push(`)`);
    }
  };

  const transformText = (node, context) => {
    if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
      return () => {
        const children = node.children;
        let currentContainer = void 0;
        let hasText = false;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (isText$1(child)) {
            hasText = true;
            for (let j = i + 1; j < children.length; j++) {
              const next = children[j];
              if (isText$1(next)) {
                if (!currentContainer) {
                  currentContainer = children[i] = createCompoundExpression(
                    [child],
                    child.loc
                  );
                }
                currentContainer.children.push(` + `, next);
                children.splice(j, 1);
                j--;
              } else {
                currentContainer = void 0;
                break;
              }
            }
          }
        }
        if (!hasText || // if this is a plain element with a single text child, leave it
        // as-is since the runtime has dedicated fast path for this by directly
        // setting textContent of the element.
        // for component root it's always normalized anyway.
        children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
        // custom directives can potentially add DOM elements arbitrarily,
        // we need to avoid setting textContent of the element at runtime
        // to avoid accidentally overwriting the DOM elements added
        // by the user through custom directives.
        !node.props.find(
          (p) => p.type === 7 && !context.directiveTransforms[p.name]
        ) && // in compat mode, <template> tags with no special directives
        // will be rendered as a fragment so its children must be
        // converted into vnodes.
        !(node.tag === "template"))) {
          return;
        }
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (isText$1(child) || child.type === 8) {
            const callArgs = [];
            if (child.type !== 2 || child.content !== " ") {
              callArgs.push(child);
            }
            if (!context.ssr && getConstantType(child, context) === 0) {
              callArgs.push(
                1 + (!!(process.env.NODE_ENV !== "production") ? ` /* ${PatchFlagNames[1]} */` : ``)
              );
            }
            children[i] = {
              type: 12,
              content: child,
              loc: child.loc,
              codegenNode: createCallExpression(
                context.helper(CREATE_TEXT),
                callArgs
              )
            };
          }
        }
      };
    }
  };

  const seen$1 = /* @__PURE__ */ new WeakSet();
  const transformOnce = (node, context) => {
    if (node.type === 1 && findDir(node, "once", true)) {
      if (seen$1.has(node) || context.inVOnce || context.inSSR) {
        return;
      }
      seen$1.add(node);
      context.inVOnce = true;
      context.helper(SET_BLOCK_TRACKING);
      return () => {
        context.inVOnce = false;
        const cur = context.currentNode;
        if (cur.codegenNode) {
          cur.codegenNode = context.cache(
            cur.codegenNode,
            true,
            true
          );
        }
      };
    }
  };

  const transformModel$1 = (dir, node, context) => {
    const { exp, arg } = dir;
    if (!exp) {
      context.onError(
        createCompilerError(41, dir.loc)
      );
      return createTransformProps();
    }
    const rawExp = exp.loc.source.trim();
    const expString = exp.type === 4 ? exp.content : rawExp;
    const bindingType = context.bindingMetadata[rawExp];
    if (bindingType === "props" || bindingType === "props-aliased") {
      context.onError(createCompilerError(44, exp.loc));
      return createTransformProps();
    }
    if (!expString.trim() || !isMemberExpression(exp) && true) {
      context.onError(
        createCompilerError(42, exp.loc)
      );
      return createTransformProps();
    }
    const propName = arg ? arg : createSimpleExpression("modelValue", true);
    const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
    let assignmentExp;
    const eventArg = context.isTS ? `($event: any)` : `$event`;
    {
      assignmentExp = createCompoundExpression([
        `${eventArg} => ((`,
        exp,
        `) = $event)`
      ]);
    }
    const props = [
      // modelValue: foo
      createObjectProperty(propName, dir.exp),
      // "onUpdate:modelValue": $event => (foo = $event)
      createObjectProperty(eventName, assignmentExp)
    ];
    if (dir.modifiers.length && node.tagType === 1) {
      const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
      const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
      props.push(
        createObjectProperty(
          modifiersKey,
          createSimpleExpression(
            `{ ${modifiers} }`,
            false,
            dir.loc,
            2
          )
        )
      );
    }
    return createTransformProps(props);
  };
  function createTransformProps(props = []) {
    return { props };
  }

  const validDivisionCharRE = /[\w).+\-_$\]]/;
  const transformFilter = (node, context) => {
    if (!isCompatEnabled("COMPILER_FILTERS", context)) {
      return;
    }
    if (node.type === 5) {
      rewriteFilter(node.content, context);
    } else if (node.type === 1) {
      node.props.forEach((prop) => {
        if (prop.type === 7 && prop.name !== "for" && prop.exp) {
          rewriteFilter(prop.exp, context);
        }
      });
    }
  };
  function rewriteFilter(node, context) {
    if (node.type === 4) {
      parseFilter(node, context);
    } else {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (typeof child !== "object") continue;
        if (child.type === 4) {
          parseFilter(child, context);
        } else if (child.type === 8) {
          rewriteFilter(node, context);
        } else if (child.type === 5) {
          rewriteFilter(child.content, context);
        }
      }
    }
  }
  function parseFilter(node, context) {
    const exp = node.content;
    let inSingle = false;
    let inDouble = false;
    let inTemplateString = false;
    let inRegex = false;
    let curly = 0;
    let square = 0;
    let paren = 0;
    let lastFilterIndex = 0;
    let c, prev, i, expression, filters = [];
    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);
      if (inSingle) {
        if (c === 39 && prev !== 92) inSingle = false;
      } else if (inDouble) {
        if (c === 34 && prev !== 92) inDouble = false;
      } else if (inTemplateString) {
        if (c === 96 && prev !== 92) inTemplateString = false;
      } else if (inRegex) {
        if (c === 47 && prev !== 92) inRegex = false;
      } else if (c === 124 && // pipe
      exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
        if (expression === void 0) {
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 34:
            inDouble = true;
            break;
          // "
          case 39:
            inSingle = true;
            break;
          // '
          case 96:
            inTemplateString = true;
            break;
          // `
          case 40:
            paren++;
            break;
          // (
          case 41:
            paren--;
            break;
          // )
          case 91:
            square++;
            break;
          // [
          case 93:
            square--;
            break;
          // ]
          case 123:
            curly++;
            break;
          // {
          case 125:
            curly--;
            break;
        }
        if (c === 47) {
          let j = i - 1;
          let p;
          for (; j >= 0; j--) {
            p = exp.charAt(j);
            if (p !== " ") break;
          }
          if (!p || !validDivisionCharRE.test(p)) {
            inRegex = true;
          }
        }
      }
    }
    if (expression === void 0) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }
    function pushFilter() {
      filters.push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }
    if (filters.length) {
      !!(process.env.NODE_ENV !== "production") && warnDeprecation(
        "COMPILER_FILTERS",
        context,
        node.loc
      );
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i], context);
      }
      node.content = expression;
      node.ast = void 0;
    }
  }
  function wrapFilter(exp, filter, context) {
    context.helper(RESOLVE_FILTER);
    const i = filter.indexOf("(");
    if (i < 0) {
      context.filters.add(filter);
      return `${toValidAssetId(filter, "filter")}(${exp})`;
    } else {
      const name = filter.slice(0, i);
      const args = filter.slice(i + 1);
      context.filters.add(name);
      return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
    }
  }

  const seen = /* @__PURE__ */ new WeakSet();
  const transformMemo = (node, context) => {
    if (node.type === 1) {
      const dir = findDir(node, "memo");
      if (!dir || seen.has(node) || context.inSSR) {
        return;
      }
      seen.add(node);
      return () => {
        const codegenNode = node.codegenNode || context.currentNode.codegenNode;
        if (codegenNode && codegenNode.type === 13) {
          if (node.tagType !== 1) {
            convertToBlock(codegenNode, context);
          }
          node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
            dir.exp,
            createFunctionExpression(void 0, codegenNode),
            `_cache`,
            String(context.cached.length)
          ]);
          context.cached.push(null);
        }
      };
    }
  };

  const transformVBindShorthand = (node, context) => {
    if (node.type === 1) {
      for (const prop of node.props) {
        if (prop.type === 7 && prop.name === "bind" && !prop.exp) {
          const arg = prop.arg;
          if (arg.type !== 4 || !arg.isStatic) {
            context.onError(
              createCompilerError(
                52,
                arg.loc
              )
            );
            prop.exp = createSimpleExpression("", true, arg.loc);
          } else {
            const propName = camelize(arg.content);
            if (validFirstIdentCharRE.test(propName[0]) || // allow hyphen first char for https://github.com/vuejs/language-tools/pull/3424
            propName[0] === "-") {
              prop.exp = createSimpleExpression(propName, false, arg.loc);
            }
          }
        }
      }
    }
  };

  function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        transformVBindShorthand,
        transformOnce,
        transformIf,
        transformMemo,
        transformFor,
        ...[transformFilter] ,
        ...!!(process.env.NODE_ENV !== "production") ? [transformExpression] : [],
        transformSlotOutlet,
        transformElement,
        trackSlotScopes,
        transformText
      ],
      {
        on: transformOn$1,
        bind: transformBind,
        model: transformModel$1
      }
    ];
  }
  function baseCompile(source, options = {}) {
    const onError = options.onError || defaultOnError;
    const isModuleMode = options.mode === "module";
    {
      if (options.prefixIdentifiers === true) {
        onError(createCompilerError(47));
      } else if (isModuleMode) {
        onError(createCompilerError(48));
      }
    }
    const prefixIdentifiers = false;
    if (options.cacheHandlers) {
      onError(createCompilerError(49));
    }
    if (options.scopeId && !isModuleMode) {
      onError(createCompilerError(50));
    }
    const resolvedOptions = extend$1({}, options, {
      prefixIdentifiers
    });
    const ast = isString(source) ? baseParse(source, resolvedOptions) : source;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(
      ast,
      extend$1({}, resolvedOptions, {
        nodeTransforms: [
          ...nodeTransforms,
          ...options.nodeTransforms || []
          // user transforms
        ],
        directiveTransforms: extend$1(
          {},
          directiveTransforms,
          options.directiveTransforms || {}
          // user transforms
        )
      })
    );
    return generate(ast, resolvedOptions);
  }

  const noopDirectiveTransform = () => ({ props: [] });

  /**
  * @vue/compiler-dom v3.5.22
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/

  const V_MODEL_RADIO = Symbol(!!(process.env.NODE_ENV !== "production") ? `vModelRadio` : ``);
  const V_MODEL_CHECKBOX = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `vModelCheckbox` : ``
  );
  const V_MODEL_TEXT = Symbol(!!(process.env.NODE_ENV !== "production") ? `vModelText` : ``);
  const V_MODEL_SELECT = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `vModelSelect` : ``
  );
  const V_MODEL_DYNAMIC = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `vModelDynamic` : ``
  );
  const V_ON_WITH_MODIFIERS = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `vOnModifiersGuard` : ``
  );
  const V_ON_WITH_KEYS = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `vOnKeysGuard` : ``
  );
  const V_SHOW = Symbol(!!(process.env.NODE_ENV !== "production") ? `vShow` : ``);
  const TRANSITION = Symbol(!!(process.env.NODE_ENV !== "production") ? `Transition` : ``);
  const TRANSITION_GROUP = Symbol(
    !!(process.env.NODE_ENV !== "production") ? `TransitionGroup` : ``
  );
  registerRuntimeHelpers({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
  });

  let decoder;
  function decodeHtmlBrowser(raw, asAttr = false) {
    if (!decoder) {
      decoder = document.createElement("div");
    }
    if (asAttr) {
      decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
      return decoder.children[0].getAttribute("foo");
    } else {
      decoder.innerHTML = raw;
      return decoder.textContent;
    }
  }

  const parserOptions = {
    parseMode: "html",
    isVoidTag,
    isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
    isPreTag: (tag) => tag === "pre",
    isIgnoreNewlineTag: (tag) => tag === "pre" || tag === "textarea",
    decodeEntities: decodeHtmlBrowser ,
    isBuiltInComponent: (tag) => {
      if (tag === "Transition" || tag === "transition") {
        return TRANSITION;
      } else if (tag === "TransitionGroup" || tag === "transition-group") {
        return TRANSITION_GROUP;
      }
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent, rootNamespace) {
      let ns = parent ? parent.ns : rootNamespace;
      if (parent && ns === 2) {
        if (parent.tag === "annotation-xml") {
          if (tag === "svg") {
            return 1;
          }
          if (parent.props.some(
            (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
          )) {
            ns = 0;
          }
        } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
          ns = 0;
        }
      } else if (parent && ns === 1) {
        if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
          ns = 0;
        }
      }
      if (ns === 0) {
        if (tag === "svg") {
          return 1;
        }
        if (tag === "math") {
          return 2;
        }
      }
      return ns;
    }
  };

  const transformStyle = (node) => {
    if (node.type === 1) {
      node.props.forEach((p, i) => {
        if (p.type === 6 && p.name === "style" && p.value) {
          node.props[i] = {
            type: 7,
            name: `bind`,
            arg: createSimpleExpression(`style`, true, p.loc),
            exp: parseInlineCSS(p.value.content, p.loc),
            modifiers: [],
            loc: p.loc
          };
        }
      });
    }
  };
  const parseInlineCSS = (cssText, loc) => {
    const normalized = parseStringStyle(cssText);
    return createSimpleExpression(
      JSON.stringify(normalized),
      false,
      loc,
      3
    );
  };

  function createDOMCompilerError(code, loc) {
    return createCompilerError(
      code,
      loc,
      !!(process.env.NODE_ENV !== "production") || false ? DOMErrorMessages : void 0
    );
  }
  const DOMErrorMessages = {
    [53]: `v-html is missing expression.`,
    [54]: `v-html will override element children.`,
    [55]: `v-text is missing expression.`,
    [56]: `v-text will override element children.`,
    [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [58]: `v-model argument is not supported on plain elements.`,
    [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [61]: `v-show is missing expression.`,
    [62]: `<Transition> expects exactly one child element or component.`,
    [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
  };

  const transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
      context.onError(
        createDOMCompilerError(53, loc)
      );
    }
    if (node.children.length) {
      context.onError(
        createDOMCompilerError(54, loc)
      );
      node.children.length = 0;
    }
    return {
      props: [
        createObjectProperty(
          createSimpleExpression(`innerHTML`, true, loc),
          exp || createSimpleExpression("", true)
        )
      ]
    };
  };

  const transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
      context.onError(
        createDOMCompilerError(55, loc)
      );
    }
    if (node.children.length) {
      context.onError(
        createDOMCompilerError(56, loc)
      );
      node.children.length = 0;
    }
    return {
      props: [
        createObjectProperty(
          createSimpleExpression(`textContent`, true),
          exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
            context.helperString(TO_DISPLAY_STRING),
            [exp],
            loc
          ) : createSimpleExpression("", true)
        )
      ]
    };
  };

  const transformModel = (dir, node, context) => {
    const baseResult = transformModel$1(dir, node, context);
    if (!baseResult.props.length || node.tagType === 1) {
      return baseResult;
    }
    if (dir.arg) {
      context.onError(
        createDOMCompilerError(
          58,
          dir.arg.loc
        )
      );
    }
    function checkDuplicatedValue() {
      const value = findDir(node, "bind");
      if (value && isStaticArgOf(value.arg, "value")) {
        context.onError(
          createDOMCompilerError(
            60,
            value.loc
          )
        );
      }
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
      let directiveToUse = V_MODEL_TEXT;
      let isInvalidType = false;
      if (tag === "input" || isCustomElement) {
        const type = findProp(node, `type`);
        if (type) {
          if (type.type === 7) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else if (type.value) {
            switch (type.value.content) {
              case "radio":
                directiveToUse = V_MODEL_RADIO;
                break;
              case "checkbox":
                directiveToUse = V_MODEL_CHECKBOX;
                break;
              case "file":
                isInvalidType = true;
                context.onError(
                  createDOMCompilerError(
                    59,
                    dir.loc
                  )
                );
                break;
              default:
                !!(process.env.NODE_ENV !== "production") && checkDuplicatedValue();
                break;
            }
          }
        } else if (hasDynamicKeyVBind(node)) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else {
          !!(process.env.NODE_ENV !== "production") && checkDuplicatedValue();
        }
      } else if (tag === "select") {
        directiveToUse = V_MODEL_SELECT;
      } else {
        !!(process.env.NODE_ENV !== "production") && checkDuplicatedValue();
      }
      if (!isInvalidType) {
        baseResult.needRuntime = context.helper(directiveToUse);
      }
    } else {
      context.onError(
        createDOMCompilerError(
          57,
          dir.loc
        )
      );
    }
    baseResult.props = baseResult.props.filter(
      (p) => !(p.key.type === 4 && p.key.content === "modelValue")
    );
    return baseResult;
  };

  const isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
  const isNonKeyModifier = /* @__PURE__ */ makeMap(
    // event propagation management
    `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
  );
  const maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
  const isKeyboardEvent = /* @__PURE__ */ makeMap(`onkeyup,onkeydown,onkeypress`);
  const resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
      const modifier = modifiers[i].content;
      if (modifier === "native" && checkCompatEnabled(
        "COMPILER_V_ON_NATIVE",
        context,
        loc
      )) {
        eventOptionModifiers.push(modifier);
      } else if (isEventOptionModifier(modifier)) {
        eventOptionModifiers.push(modifier);
      } else {
        if (maybeKeyModifier(modifier)) {
          if (isStaticExp(key)) {
            if (isKeyboardEvent(key.content.toLowerCase())) {
              keyModifiers.push(modifier);
            } else {
              nonKeyModifiers.push(modifier);
            }
          } else {
            keyModifiers.push(modifier);
            nonKeyModifiers.push(modifier);
          }
        } else {
          if (isNonKeyModifier(modifier)) {
            nonKeyModifiers.push(modifier);
          } else {
            keyModifiers.push(modifier);
          }
        }
      }
    }
    return {
      keyModifiers,
      nonKeyModifiers,
      eventOptionModifiers
    };
  };
  const transformClick = (key, event) => {
    const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
    return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
      `(`,
      key,
      `) === "onClick" ? "${event}" : (`,
      key,
      `)`
    ]) : key;
  };
  const transformOn = (dir, node, context) => {
    return transformOn$1(dir, node, context, (baseResult) => {
      const { modifiers } = dir;
      if (!modifiers.length) return baseResult;
      let { key, value: handlerExp } = baseResult.props[0];
      const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
      if (nonKeyModifiers.includes("right")) {
        key = transformClick(key, `onContextmenu`);
      }
      if (nonKeyModifiers.includes("middle")) {
        key = transformClick(key, `onMouseup`);
      }
      if (nonKeyModifiers.length) {
        handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
          handlerExp,
          JSON.stringify(nonKeyModifiers)
        ]);
      }
      if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
      (!isStaticExp(key) || isKeyboardEvent(key.content.toLowerCase()))) {
        handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
          handlerExp,
          JSON.stringify(keyModifiers)
        ]);
      }
      if (eventOptionModifiers.length) {
        const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
        key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
      }
      return {
        props: [createObjectProperty(key, handlerExp)]
      };
    });
  };

  const transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
      context.onError(
        createDOMCompilerError(61, loc)
      );
    }
    return {
      props: [],
      needRuntime: context.helper(V_SHOW)
    };
  };

  const transformTransition = (node, context) => {
    if (node.type === 1 && node.tagType === 1) {
      const component = context.isBuiltInComponent(node.tag);
      if (component === TRANSITION) {
        return () => {
          if (!node.children.length) {
            return;
          }
          if (hasMultipleChildren(node)) {
            context.onError(
              createDOMCompilerError(
                62,
                {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                }
              )
            );
          }
          const child = node.children[0];
          if (child.type === 1) {
            for (const p of child.props) {
              if (p.type === 7 && p.name === "show") {
                node.props.push({
                  type: 6,
                  name: "persisted",
                  nameLoc: node.loc,
                  value: void 0,
                  loc: node.loc
                });
              }
            }
          }
        };
      }
    }
  };
  function hasMultipleChildren(node) {
    const children = node.children = node.children.filter(
      (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
    );
    const child = children[0];
    return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
  }

  const ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
      !!(process.env.NODE_ENV !== "production") && context.onError(
        createDOMCompilerError(
          63,
          node.loc
        )
      );
      context.removeNode();
    }
  };

  function isValidHTMLNesting(parent, child) {
    if (parent === "template") {
      return true;
    }
    if (parent in onlyValidChildren) {
      return onlyValidChildren[parent].has(child);
    }
    if (child in onlyValidParents) {
      return onlyValidParents[child].has(parent);
    }
    if (parent in knownInvalidChildren) {
      if (knownInvalidChildren[parent].has(child)) return false;
    }
    if (child in knownInvalidParents) {
      if (knownInvalidParents[child].has(parent)) return false;
    }
    return true;
  }
  const headings = /* @__PURE__ */ new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
  const emptySet = /* @__PURE__ */ new Set([]);
  const onlyValidChildren = {
    head: /* @__PURE__ */ new Set([
      "base",
      "basefront",
      "bgsound",
      "link",
      "meta",
      "title",
      "noscript",
      "noframes",
      "style",
      "script",
      "template"
    ]),
    optgroup: /* @__PURE__ */ new Set(["option"]),
    select: /* @__PURE__ */ new Set(["optgroup", "option", "hr"]),
    // table
    table: /* @__PURE__ */ new Set(["caption", "colgroup", "tbody", "tfoot", "thead"]),
    tr: /* @__PURE__ */ new Set(["td", "th"]),
    colgroup: /* @__PURE__ */ new Set(["col"]),
    tbody: /* @__PURE__ */ new Set(["tr"]),
    thead: /* @__PURE__ */ new Set(["tr"]),
    tfoot: /* @__PURE__ */ new Set(["tr"]),
    // these elements can not have any children elements
    script: emptySet,
    iframe: emptySet,
    option: emptySet,
    textarea: emptySet,
    style: emptySet,
    title: emptySet
  };
  const onlyValidParents = {
    // sections
    html: emptySet,
    body: /* @__PURE__ */ new Set(["html"]),
    head: /* @__PURE__ */ new Set(["html"]),
    // table
    td: /* @__PURE__ */ new Set(["tr"]),
    colgroup: /* @__PURE__ */ new Set(["table"]),
    caption: /* @__PURE__ */ new Set(["table"]),
    tbody: /* @__PURE__ */ new Set(["table"]),
    tfoot: /* @__PURE__ */ new Set(["table"]),
    col: /* @__PURE__ */ new Set(["colgroup"]),
    th: /* @__PURE__ */ new Set(["tr"]),
    thead: /* @__PURE__ */ new Set(["table"]),
    tr: /* @__PURE__ */ new Set(["tbody", "thead", "tfoot"]),
    // data list
    dd: /* @__PURE__ */ new Set(["dl", "div"]),
    dt: /* @__PURE__ */ new Set(["dl", "div"]),
    // other
    figcaption: /* @__PURE__ */ new Set(["figure"]),
    // li: new Set(["ul", "ol"]),
    summary: /* @__PURE__ */ new Set(["details"]),
    area: /* @__PURE__ */ new Set(["map"])
  };
  const knownInvalidChildren = {
    p: /* @__PURE__ */ new Set([
      "address",
      "article",
      "aside",
      "blockquote",
      "center",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "fieldset",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "hr",
      "li",
      "main",
      "nav",
      "menu",
      "ol",
      "p",
      "pre",
      "section",
      "table",
      "ul"
    ]),
    svg: /* @__PURE__ */ new Set([
      "b",
      "blockquote",
      "br",
      "code",
      "dd",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "hr",
      "i",
      "img",
      "li",
      "menu",
      "meta",
      "ol",
      "p",
      "pre",
      "ruby",
      "s",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "table",
      "u",
      "ul",
      "var"
    ])
  };
  const knownInvalidParents = {
    a: /* @__PURE__ */ new Set(["a"]),
    button: /* @__PURE__ */ new Set(["button"]),
    dd: /* @__PURE__ */ new Set(["dd", "dt"]),
    dt: /* @__PURE__ */ new Set(["dd", "dt"]),
    form: /* @__PURE__ */ new Set(["form"]),
    li: /* @__PURE__ */ new Set(["li"]),
    h1: headings,
    h2: headings,
    h3: headings,
    h4: headings,
    h5: headings,
    h6: headings
  };

  const validateHtmlNesting = (node, context) => {
    if (node.type === 1 && node.tagType === 0 && context.parent && context.parent.type === 1 && context.parent.tagType === 0 && !isValidHTMLNesting(context.parent.tag, node.tag)) {
      const error = new SyntaxError(
        `<${node.tag}> cannot be child of <${context.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`
      );
      error.loc = node.loc;
      context.onWarn(error);
    }
  };

  const DOMNodeTransforms = [
    transformStyle,
    ...!!(process.env.NODE_ENV !== "production") ? [transformTransition, validateHtmlNesting] : []
  ];
  const DOMDirectiveTransforms = {
    cloak: noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel,
    // override compiler-core
    on: transformOn,
    // override compiler-core
    show: transformShow
  };
  function compile(src, options = {}) {
    return baseCompile(
      src,
      extend$1({}, parserOptions, options, {
        nodeTransforms: [
          // ignore <script> and <tag>
          // this is not put inside DOMNodeTransforms because that list is used
          // by compiler-ssr to generate vnode fallback branches
          ignoreSideEffectTags,
          ...DOMNodeTransforms,
          ...options.nodeTransforms || []
        ],
        directiveTransforms: extend$1(
          {},
          DOMDirectiveTransforms,
          options.directiveTransforms || {}
        ),
        transformHoist: null 
      })
    );
  }

  const createDynamicComponent = (template) => {
    const { code } = compile(template);
    const render = new Function("Vue", code)(Vue__namespace);
    return Vue.defineComponent({ render });
  };

  const _hoisted_1$N = ["aria-label"];
  var _sfc_main$17 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ArticleTitle" },
    __name: "index",
    props: {
      post: {},
      titleTagProps: {}
    },
    setup(__props) {
      const ns = useNamespace("article-title");
      const { t } = useLocale();
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("span", {
          class: Vue.normalizeClass(Vue.unref(ns).b()),
          "aria-label": Vue.unref(t)("tk.articleTitle.label")
        }, [
          __props.post.frontmatter.titleTag && __props.titleTagProps?.position === "left" ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1b), Vue.mergeProps({
            key: 0,
            text: __props.post.frontmatter.titleTag
          }, __props.titleTagProps, {
            "aria-label": __props.post.frontmatter.titleTag
          }), null, 16, ["text", "aria-label"])) : Vue.createCommentVNode("v-if", true),
          Vue.renderSlot(_ctx.$slots, "default", {}, () => [
            __props.post.title ? (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(Vue.unref(createDynamicComponent)(__props.post.title)), { key: 0 })) : Vue.createCommentVNode("v-if", true)
          ]),
          __props.post.frontmatter.titleTag && __props.titleTagProps?.position === "right" ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1b), Vue.mergeProps({
            key: 1,
            text: __props.post.frontmatter.titleTag
          }, __props.titleTagProps, {
            "aria-label": __props.post.frontmatter.titleTag
          }), null, 16, ["text", "aria-label"])) : Vue.createCommentVNode("v-if", true)
        ], 10, _hoisted_1$N);
      };
    }
  });

  const _hoisted_1$M = { class: "count" };
  const _hoisted_2$C = { class: "vp-doc" };
  const _hoisted_3$t = { class: "year" };
  const _hoisted_4$q = { class: "count" };
  const _hoisted_5$h = { class: "month" };
  const _hoisted_6$d = { class: "count" };
  const _hoisted_7$8 = ["href", "aria-label"];
  const _hoisted_8$5 = { class: "date" };
  var _sfc_main$16 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ArchivesPage" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("archives");
      const { t } = useLocale();
      const { frontmatter } = vitepress.useData();
      const posts = usePosts();
      const defaultLabel = Vue.computed(() => {
        const frontmatterConst = frontmatter.value;
        return {
          title: frontmatterConst.title ?? t("tk.archives.title"),
          totalCount: frontmatterConst.totalCount ?? t("tk.archives.totalCount"),
          year: frontmatterConst.year ?? t("tk.archives.year"),
          month: frontmatterConst.month ?? t("tk.archives.month"),
          count: frontmatterConst.count ?? t("tk.archives.count"),
          notFound: frontmatterConst.notFound ?? t("tk.archives.notFound")
        };
      });
      const windowTransition = useWindowTransitionConfig((config) => config.archives);
      const timelineItemListInstance = Vue.ref(null);
      const { start } = useWindowTransition(timelineItemListInstance, false);
      Vue.onMounted(() => {
        windowTransition.value && start();
      });
      return (_ctx, _cache) => {
        const _component_Content = Vue.resolveComponent("Content");
        return Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1y), {
          class: Vue.normalizeClass(Vue.unref(ns).b()),
          "aria-label": Vue.unref(t)("tk.archives.label")
        }, {
          default: Vue.withCtx(() => [
            Vue.renderSlot(_ctx.$slots, "teek-archives-top-before"),
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass(`${Vue.unref(ns).e("header")} flx-justify-between`)
              },
              [
                Vue.createElementVNode(
                  "h1",
                  null,
                  Vue.toDisplayString(defaultLabel.value.title),
                  1
                  /* TEXT */
                ),
                Vue.createElementVNode(
                  "div",
                  _hoisted_1$M,
                  Vue.toDisplayString(defaultLabel.value.totalCount.replace("{count}", Vue.unref(posts).sortPostsByDate.length)),
                  1
                  /* TEXT */
                )
              ],
              2
              /* CLASS */
            ),
            Vue.renderSlot(_ctx.$slots, "teek-archives-top-after"),
            Vue.createElementVNode("div", _hoisted_2$C, [
              Vue.createVNode(_component_Content)
            ]),
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass(Vue.unref(ns).e("timeline"))
              },
              [
                (Vue.openBlock(true), Vue.createElementBlock(
                  Vue.Fragment,
                  null,
                  Vue.renderList(Vue.unref(posts).groupPostsByYearMonth, (monthPosts, year) => {
                    return Vue.openBlock(), Vue.createElementBlock(
                      Vue.Fragment,
                      { key: year },
                      [
                        Vue.createElementVNode(
                          "div",
                          {
                            class: Vue.normalizeClass(`${Vue.unref(ns).em("timeline", "year")} flx-justify-between`)
                          },
                          [
                            Vue.createElementVNode(
                              "div",
                              _hoisted_3$t,
                              Vue.toDisplayString(String(year).trim() === "NaN" ? defaultLabel.value.notFound : String(year).trim() + defaultLabel.value.year),
                              1
                              /* TEXT */
                            ),
                            Vue.createElementVNode(
                              "div",
                              _hoisted_4$q,
                              Vue.toDisplayString(Vue.unref(posts).groupPostsByYear[year].length + defaultLabel.value.count),
                              1
                              /* TEXT */
                            )
                          ],
                          2
                          /* CLASS */
                        ),
                        Vue.createElementVNode(
                          "div",
                          {
                            class: Vue.normalizeClass(Vue.unref(ns).e("timeline__m"))
                          },
                          [
                            (Vue.openBlock(true), Vue.createElementBlock(
                              Vue.Fragment,
                              null,
                              Vue.renderList(monthPosts, (p, month) => {
                                return Vue.openBlock(), Vue.createElementBlock(
                                  Vue.Fragment,
                                  { key: month },
                                  [
                                    Vue.createElementVNode(
                                      "div",
                                      {
                                        class: Vue.normalizeClass(`${Vue.unref(ns).em("timeline__m", "month")} flx-justify-between`)
                                      },
                                      [
                                        Vue.createElementVNode(
                                          "div",
                                          _hoisted_5$h,
                                          Vue.toDisplayString(String(month) === "NaN" ? defaultLabel.value.notFound : month + defaultLabel.value.month),
                                          1
                                          /* TEXT */
                                        ),
                                        Vue.createElementVNode(
                                          "div",
                                          _hoisted_6$d,
                                          Vue.toDisplayString(p.length + defaultLabel.value.count),
                                          1
                                          /* TEXT */
                                        )
                                      ],
                                      2
                                      /* CLASS */
                                    ),
                                    Vue.createElementVNode("ul", null, [
                                      (Vue.openBlock(true), Vue.createElementBlock(
                                        Vue.Fragment,
                                        null,
                                        Vue.renderList(p, (item) => {
                                          return Vue.openBlock(), Vue.createElementBlock("li", {
                                            ref_for: true,
                                            ref_key: "timelineItemListInstance",
                                            ref: timelineItemListInstance,
                                            key: item.url
                                          }, [
                                            Vue.createElementVNode("a", {
                                              href: item.url && Vue.unref(vitepress.withBase)(item.url),
                                              "aria-label": `${item.title}`
                                            }, [
                                              Vue.createElementVNode(
                                                "span",
                                                _hoisted_8$5,
                                                Vue.toDisplayString(item.date?.slice(5, 10)),
                                                1
                                                /* TEXT */
                                              ),
                                              Vue.createVNode(Vue.unref(_sfc_main$17), {
                                                post: item,
                                                "title-tag-props": { position: "right", size: "small" }
                                              }, null, 8, ["post"])
                                            ], 8, _hoisted_7$8)
                                          ]);
                                        }),
                                        128
                                        /* KEYED_FRAGMENT */
                                      ))
                                    ])
                                  ],
                                  64
                                  /* STABLE_FRAGMENT */
                                );
                              }),
                              128
                              /* KEYED_FRAGMENT */
                            ))
                          ],
                          2
                          /* CLASS */
                        )
                      ],
                      64
                      /* STABLE_FRAGMENT */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ],
              2
              /* CLASS */
            )
          ]),
          _: 3
          /* FORWARDED */
        }, 8, ["class", "aria-label"]);
      };
    }
  });

  const _hoisted_1$L = ["aria-label"];
  const _hoisted_2$B = ["href", "title", "aria-label"];
  var _sfc_main$15 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ArticleBreadcrumb" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("article-breadcrumb");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const { localeIndex, theme, page } = vitepress.useData();
      const breadcrumb = getTeekConfigRef("breadcrumb", {
        enabled: true,
        showCurrentName: false,
        separator: "/",
        homeLabel: t("tk.articleBreadcrumb.home")
      });
      const relativePathArr = Vue.computed(() => page.value.filePath.split("/") || []);
      const breadcrumbList = Vue.computed(() => {
        const classifyList = [];
        const relativePathArrConst = relativePathArr.value;
        relativePathArrConst.forEach((item, index) => {
          const fileName = item.replace(/^\d+\./, "").split(".")?.[0] || "";
          if ((index !== relativePathArrConst.length - 1 || breadcrumb.value.showCurrentName) && fileName !== localeIndex.value) {
            classifyList.push({
              fileName,
              url: theme.value.catalogues?.inv[item]?.url || ""
            });
          }
        });
        return classifyList;
      });
      return (_ctx, _cache) => {
        return Vue.unref(breadcrumb)?.enabled ? (Vue.openBlock(), Vue.createElementBlock("div", {
          key: 0,
          class: Vue.normalizeClass(Vue.unref(ns).b()),
          role: "navigation",
          "aria-label": Vue.unref(t)("tk.articleBreadcrumb.label")
        }, [
          Vue.createVNode(Vue.unref(_sfc_main$1r), {
            separator: Vue.unref(breadcrumb).separator
          }, {
            default: Vue.withCtx(() => [
              Vue.createVNode(Vue.unref(_sfc_main$1q), null, {
                default: Vue.withCtx(() => [
                  Vue.createElementVNode("a", {
                    href: Vue.unref(vitepress.withBase)("/"),
                    title: Vue.unref(breadcrumb).homeLabel,
                    class: "home hover-color",
                    "aria-label": Vue.unref(breadcrumb).homeLabel
                  }, [
                    Vue.createVNode(Vue.unref(_sfc_main$1t), {
                      icon: Vue.unref(houseIcon),
                      "aria-hidden": "true"
                    }, null, 8, ["icon"])
                  ], 8, _hoisted_2$B)
                ]),
                _: 1
                /* STABLE */
              }),
              (Vue.openBlock(true), Vue.createElementBlock(
                Vue.Fragment,
                null,
                Vue.renderList(breadcrumbList.value, (item, index) => {
                  return Vue.openBlock(), Vue.createBlock(
                    Vue.unref(_sfc_main$1q),
                    { key: index },
                    {
                      default: Vue.withCtx(() => [
                        (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(item.url ? "a" : "span"), {
                          href: item.url && Vue.unref(vitepress.withBase)(`/${item.url}`),
                          title: item.fileName,
                          class: Vue.normalizeClass([item.url ? "hover-color" : ""]),
                          "aria-label": item.fileName
                        }, {
                          default: Vue.withCtx(() => [
                            Vue.createTextVNode(
                              Vue.toDisplayString(item.fileName),
                              1
                              /* TEXT */
                            )
                          ]),
                          _: 2
                          /* DYNAMIC */
                        }, 1032, ["href", "title", "class", "aria-label"]))
                      ]),
                      _: 2
                      /* DYNAMIC */
                    },
                    1024
                    /* DYNAMIC_SLOTS */
                  );
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]),
            _: 1
            /* STABLE */
          }, 8, ["separator"])
        ], 10, _hoisted_1$L)) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  const _hoisted_1$K = ["aria-label"];
  const _hoisted_2$A = ["aria-label"];
  const _hoisted_3$s = ["title", "href", "target", "aria-label"];
  const _hoisted_4$p = ["title", "href", "aria-label"];
  var _sfc_main$14 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ArticleInfo" },
    __name: "index",
    props: {
      post: {},
      scope: {},
      split: { type: Boolean, default: false }
    },
    setup(__props) {
      const ns = useNamespace("article-info");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const { page } = vitepress.useData();
      const articleConfig = getTeekConfigRef("articleAnalyze", {
        showIcon: true,
        dateFormat: "yyyy-MM-dd",
        showAuthor: true,
        showCreateDate: true,
        showUpdateDate: false,
        showCategory: false,
        showTag: false
      });
      const posts = usePosts();
      const route = vitepress.useRoute();
      const createDate = Vue.computed(() => {
        const originPosts = posts.value.originPosts;
        const date = __props.post.date || originPosts.find((item) => [item.url, item.frontmatter.permalink].includes(route.path))?.date;
        const dateFormatConst = articleConfig.value.dateFormat;
        if (isFunction(dateFormatConst)) return dateFormatConst(date || "");
        return formatDate(date || /* @__PURE__ */ new Date(), dateFormatConst);
      });
      const updateDate = Vue.computed(() => {
        const date = page.value.lastUpdated;
        if (!date) return "";
        const dateFormatConst = articleConfig.value.dateFormat;
        if (isFunction(dateFormatConst)) return dateFormatConst(date);
        return formatDate(date, dateFormatConst);
      });
      const baseInfo = Vue.computed(() => {
        const { showAuthor, showCreateDate, showUpdateDate, showCategory, showTag } = articleConfig.value;
        return [
          {
            title: t("tk.articleInfo.author"),
            icon: userIcon,
            data: __props.post.author?.name,
            href: __props.post.author?.link,
            target: __props.post.author?.link ? "_blank" : "_self",
            show: isShow(showAuthor)
          },
          {
            title: t("tk.articleInfo.createTime"),
            icon: calendarIcon,
            data: createDate.value,
            show: isShow(showCreateDate)
          },
          {
            title: t("tk.articleInfo.updateTime"),
            icon: editPenIcon,
            data: updateDate.value,
            show: updateDate.value && (__props.scope === "article" && showUpdateDate || __props.scope === "article-banner")
          },
          {
            title: t("tk.articleInfo.category"),
            icon: folderOpenedIcon,
            dataList: __props.post.frontmatter?.categories || [],
            href: "/categories?category={data}",
            class: "or",
            show: __props.scope !== "article-banner" && (__props.scope === "post" || isShow(showCategory))
          },
          {
            title: t("tk.articleInfo.tag"),
            icon: collectionTagIcon,
            dataList: __props.post.frontmatter?.tags || [],
            href: "/tags?tag={data}",
            class: "or",
            show: __props.scope !== "article-banner" && (__props.scope === "post" || isShow(showTag))
          }
        ];
      });
      const isShow = (showInfo) => {
        const arr = [showInfo || []].flat();
        return arr.includes(true) || arr.includes(__props.scope);
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass([Vue.unref(ns).b(), __props.scope]),
          role: "group",
          "aria-label": Vue.unref(t)("tk.articleInfo.label")
        }, [
          (Vue.openBlock(true), Vue.createElementBlock(
            Vue.Fragment,
            null,
            Vue.renderList(baseInfo.value, (item) => {
              return Vue.openBlock(), Vue.createElementBlock(
                Vue.Fragment,
                {
                  key: item.title
                },
                [
                  item.show && (item.data || item.dataList?.length) ? (Vue.openBlock(), Vue.createElementBlock("span", {
                    key: 0,
                    class: Vue.normalizeClass([Vue.unref(ns).e("item"), { split: __props.split }]),
                    role: "group",
                    "aria-label": item.title
                  }, [
                    Vue.unref(articleConfig).showIcon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                      key: 0,
                      icon: item.icon,
                      class: Vue.normalizeClass(Vue.unref(ns).e("icon")),
                      "aria-hidden": "true"
                    }, null, 8, ["icon", "class"])) : Vue.createCommentVNode("v-if", true),
                    item.data ? (Vue.openBlock(), Vue.createElementBlock("a", {
                      key: 1,
                      title: item.title,
                      href: item.href && Vue.unref(vitepress.withBase)(item.href),
                      target: item.target,
                      class: Vue.normalizeClass([item.class, "hover-color"]),
                      "aria-label": item.data
                    }, Vue.toDisplayString(item.data), 11, _hoisted_3$s)) : (Vue.openBlock(true), Vue.createElementBlock(
                      Vue.Fragment,
                      { key: 2 },
                      Vue.renderList(item.dataList, (data, index) => {
                        return Vue.openBlock(), Vue.createElementBlock("a", {
                          key: index,
                          title: item.title,
                          href: item.href && Vue.unref(vitepress.withBase)(item.href.replace("{data}", encodeURIComponent(data))),
                          class: Vue.normalizeClass([item.class, "hover-color"]),
                          "aria-label": data
                        }, Vue.toDisplayString(data), 11, _hoisted_4$p);
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    ))
                  ], 10, _hoisted_2$A)) : Vue.createCommentVNode("v-if", true)
                ],
                64
                /* STABLE_FRAGMENT */
              );
            }),
            128
            /* KEYED_FRAGMENT */
          )),
          Vue.renderSlot(_ctx.$slots, "default")
        ], 10, _hoisted_1$K);
      };
    }
  });

  const _hoisted_1$J = ["aria-label"];
  const _hoisted_2$z = {
    key: 0,
    class: "flx-center"
  };
  const _hoisted_3$r = ["title", "aria-label"];
  const _hoisted_4$o = {
    key: 1,
    class: "flx-center"
  };
  const _hoisted_5$g = ["title", "aria-label"];
  const _hoisted_6$c = {
    key: 2,
    class: "flx-center"
  };
  const _hoisted_7$7 = ["title", "aria-label"];
  var _sfc_main$13 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ArticleAnalyze" },
    __name: "index",
    props: {
      breadcrumb: { type: Boolean, default: true },
      scope: { default: "article" }
    },
    setup(__props) {
      const ns = useNamespace("article-analyze");
      const { t } = useLocale();
      const { getTeekConfig, getTeekConfigRef } = useTeekConfig();
      const { theme, frontmatter } = vitepress.useData();
      const vpRouter = useVpRouter();
      const { router } = vpRouter;
      const post = Vue.computed(() => ({
        author: getTeekConfig("author", {}),
        date: frontmatter.value.date,
        frontmatter: frontmatter.value,
        url: "",
        relativePath: ""
      }));
      const docAnalysisInfo = Vue.computed(() => theme.value.docAnalysisInfo || {});
      const pageViewInfo = Vue.computed(() => {
        let pageViewInfo2 = {};
        docAnalysisInfo.value.eachFileWords?.forEach((item) => {
          if (item.fileInfo.relativePath === router.route.data.filePath) pageViewInfo2 = item;
        });
        return pageViewInfo2;
      });
      const articleConfig = getTeekConfigRef("articleAnalyze", {
        showInfo: true,
        showIcon: true,
        teleport: {}
      });
      const isShowInfo = Vue.computed(() => {
        const arr = [articleConfig.value.showInfo].flat();
        if (arr.includes(true) || arr.includes("article")) return true;
        return false;
      });
      const baseInfoRef = Vue.ref();
      const teleportInfo = () => {
        const { selector, position = "after", className = "teleport" } = articleConfig.value.teleport || {};
        const baseInfoRefConst = baseInfoRef.value;
        if (!selector || !baseInfoRefConst) return;
        const docDomContainer = document.querySelector("#VPContent");
        const targetDom = docDomContainer?.querySelector(selector);
        targetDom?.parentElement?.querySelectorAll(`.${ns.e("wrapper")}`).forEach((v) => v.remove());
        baseInfoRefConst.classList.add(className);
        targetDom?.[position]?.(baseInfoRefConst);
      };
      Vue.watch(router.route, () => Vue.nextTick(teleportInfo), { immediate: true, flush: "post" });
      const docAnalysisConfig = getTeekConfigRef("docAnalysis", {
        wordCount: true,
        readingTime: true,
        statistics: {}
      });
      const statisticsConfig = Vue.computed(() => ({
        url: "",
        provider: "",
        pageView: true,
        tryRequest: false,
        tryCount: 5,
        tryIterationTime: 2e3,
        permalink: true,
        ...docAnalysisConfig.value.statistics
      }));
      const usePageView = Vue.computed(() => !!statisticsConfig.value.provider && statisticsConfig.value.pageView);
      const { pagePv, isGet, request } = useUvPv(false, statisticsConfig.value);
      Vue.watch(usePageView, (newVal) => {
        if (newVal) request();
      });
      Vue.watch(
        router.route,
        () => {
          if (usePageView.value) {
            if (statisticsConfig.value.permalink && router.state?.permalinkPlugin) {
              Vue.nextTick(request);
            } else request();
          }
        },
        { immediate: true }
      );
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(`${Vue.unref(ns).b()} flx-justify-between`),
          "aria-label": Vue.unref(t)("tk.articleAnalyze.label")
        }, [
          __props.breadcrumb ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$15), { key: 0 })) : Vue.createCommentVNode("v-if", true),
          isShowInfo.value ? (Vue.openBlock(), Vue.createElementBlock(
            "div",
            {
              key: 1,
              ref_key: "baseInfoRef",
              ref: baseInfoRef,
              class: Vue.normalizeClass(`${Vue.unref(ns).e("wrapper")} flx-align-center`)
            },
            [
              Vue.createVNode(Vue.unref(_sfc_main$14), {
                post: post.value,
                scope: __props.scope
              }, null, 8, ["post", "scope"]),
              Vue.unref(docAnalysisConfig).wordCount && pageViewInfo.value.wordCount ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$z, [
                Vue.unref(articleConfig).showIcon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                  key: 0,
                  icon: Vue.unref(readingIcon),
                  "aria-hidden": "true"
                }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true),
                Vue.createElementVNode("a", {
                  title: Vue.unref(t)("tk.articleAnalyze.wordCount"),
                  class: "hover-color",
                  "aria-label": Vue.unref(t)("tk.articleAnalyze.wordCount")
                }, Vue.toDisplayString(pageViewInfo.value.wordCount), 9, _hoisted_3$r)
              ])) : Vue.createCommentVNode("v-if", true),
              Vue.unref(docAnalysisConfig).readingTime && pageViewInfo.value.readingTime ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_4$o, [
                Vue.unref(articleConfig).showIcon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                  key: 0,
                  icon: Vue.unref(clockIcon)
                }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true),
                Vue.createElementVNode("a", {
                  title: Vue.unref(t)("tk.articleAnalyze.readingTime"),
                  class: "hover-color",
                  "aria-label": Vue.unref(t)("tk.articleAnalyze.readingTime")
                }, Vue.toDisplayString(pageViewInfo.value.readingTime), 9, _hoisted_5$g)
              ])) : Vue.createCommentVNode("v-if", true),
              usePageView.value ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_6$c, [
                Vue.unref(articleConfig).showIcon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                  key: 0,
                  icon: Vue.unref(viewIcon)
                }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true),
                Vue.createElementVNode("a", {
                  title: Vue.unref(t)("tk.articleAnalyze.pageView"),
                  class: "hover-color",
                  "aria-label": Vue.unref(t)("tk.articleAnalyze.pageView")
                }, Vue.toDisplayString(Vue.unref(isGet) ? Vue.unref(pagePv) : "Get..."), 9, _hoisted_7$7)
              ])) : Vue.createCommentVNode("v-if", true)
            ],
            2
            /* CLASS */
          )) : Vue.createCommentVNode("v-if", true)
        ], 10, _hoisted_1$J);
      };
    }
  });

  const _hoisted_1$I = ["aria-label"];
  const _hoisted_2$y = ["innerHTML"];
  const _hoisted_3$q = ["innerHTML"];
  var _sfc_main$12 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "AsideBottomAppreciation" },
    __name: "AsideBottomAppreciation",
    setup(__props) {
      const ns = useNamespace("article-appreciation");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const appreciateConfig = getTeekConfigRef("appreciation", { position: "" });
      const asideBottomOptions = Vue.computed(() => appreciateConfig.value.options || {});
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).m("aside-bottom")]),
          "aria-label": Vue.unref(t)("tk.articleAppreciation.label")
        }, [
          Vue.createElementVNode("span", {
            innerHTML: asideBottomOptions.value.title
          }, null, 8, _hoisted_2$y),
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(Vue.unref(ns).e("content")),
            innerHTML: asideBottomOptions.value.content
          }, null, 10, _hoisted_3$q)
        ], 10, _hoisted_1$I);
      };
    }
  });

  const _hoisted_1$H = ["aria-label"];
  const _hoisted_2$x = ["innerHTML", "aria-expanded", "aria-controls"];
  const _hoisted_3$p = ["aria-expanded", "aria-controls"];
  const _hoisted_4$n = ["innerHTML"];
  const _hoisted_5$f = ["innerHTML"];
  const _hoisted_6$b = ["aria-label"];
  const _hoisted_7$6 = ["innerHTML"];
  var _sfc_main$11 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "DocAfterAppreciation" },
    __name: "DocAfterAppreciation",
    setup(__props) {
      const ns = useNamespace("article-appreciation");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const appreciateConfig = getTeekConfigRef("appreciation", { position: "" });
      const docAfterOptions = Vue.computed(() => appreciateConfig.value.options || { expand: false });
      const showContent = Vue.ref(docAfterOptions.value.expand);
      const icon = Vue.computed(() => {
        const { icon: icon2 } = docAfterOptions.value;
        if (icon2 === "aliPay") return aliPayIcon;
        if (icon2 === "weChatPay") return weChatPayIcon;
        return icon2;
      });
      const toggleShowContent = () => {
        showContent.value = !showContent.value;
      };
      Vue.watch(
        () => docAfterOptions.value.expand,
        (newValue) => {
          showContent.value = newValue;
        }
      );
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).m("doc-after")]),
          "aria-label": Vue.unref(t)("tk.articleAppreciation.label")
        }, [
          docAfterOptions.value.buttonHtml ? (Vue.openBlock(), Vue.createElementBlock("div", {
            key: 0,
            innerHTML: docAfterOptions.value.buttonHtml,
            role: "button",
            "aria-expanded": showContent.value,
            "aria-controls": `${Vue.unref(ns).e("content")}`
          }, null, 8, _hoisted_2$x)) : docAfterOptions.value.expandTitle || docAfterOptions.value.collapseTitle ? (Vue.openBlock(), Vue.createElementBlock("button", {
            key: 1,
            class: Vue.normalizeClass(Vue.unref(ns).e("button")),
            onClick: toggleShowContent,
            "aria-expanded": showContent.value,
            "aria-controls": `${Vue.unref(ns).e("content")}`,
            "aria-live": "polite"
          }, [
            icon.value ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
              key: 0,
              class: Vue.normalizeClass(Vue.unref(ns).e("button__icon")),
              icon: icon.value,
              size: 16,
              "aria-hidden": "true"
            }, null, 8, ["class", "icon"])) : Vue.createCommentVNode("v-if", true),
            showContent.value ? (Vue.openBlock(), Vue.createElementBlock("span", {
              key: 1,
              innerHTML: docAfterOptions.value.collapseTitle
            }, null, 8, _hoisted_4$n)) : (Vue.openBlock(), Vue.createElementBlock("span", {
              key: 2,
              innerHTML: docAfterOptions.value.expandTitle
            }, null, 8, _hoisted_5$f))
          ], 10, _hoisted_3$p)) : Vue.createCommentVNode("v-if", true),
          Vue.createVNode(Vue.Transition, {
            name: Vue.unref(ns).join("fade")
          }, {
            default: Vue.withCtx(() => [
              showContent.value ? (Vue.openBlock(), Vue.createElementBlock("div", {
                key: 0,
                class: Vue.normalizeClass(Vue.unref(ns).e("content")),
                "aria-label": Vue.unref(t)("tk.articleAppreciation.contentLabel")
              }, [
                Vue.createElementVNode("div", {
                  class: Vue.normalizeClass(Vue.unref(ns).e("content")),
                  innerHTML: docAfterOptions.value.content
                }, null, 10, _hoisted_7$6)
              ], 10, _hoisted_6$b)) : Vue.createCommentVNode("v-if", true)
            ]),
            _: 1
            /* STABLE */
          }, 8, ["name"])
        ], 10, _hoisted_1$H);
      };
    }
  });

  const _hoisted_1$G = ["aria-label"];
  const _hoisted_2$w = ["innerHTML", "aria-expanded", "aria-controls"];
  const _hoisted_3$o = ["aria-expanded", "aria-controls"];
  const _hoisted_4$m = ["innerHTML"];
  const _hoisted_5$e = ["aria-label"];
  const _hoisted_6$a = ["innerHTML"];
  var _sfc_main$10 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "DocAfterAppreciationPopper" },
    __name: "DocAfterAppreciationPopper",
    setup(__props) {
      const ns = useNamespace("article-appreciation");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const appreciateConfig = getTeekConfigRef("appreciation", { position: "" });
      const showContent = Vue.ref(false);
      const docAfterPopperOptions = Vue.computed(
        () => ({ trigger: "click", ...appreciateConfig.value.options })
      );
      const icon = Vue.computed(() => {
        const { icon: icon2 } = docAfterPopperOptions.value;
        if (icon2 === "aliPay") return aliPayIcon;
        if (icon2 === "weChatPay") return weChatPayIcon;
        return icon2;
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(Vue.unref(ns).b()),
          "aria-label": Vue.unref(t)("tk.articleAppreciation.label")
        }, [
          Vue.createVNode(Vue.unref(_sfc_main$1e), {
            modelValue: showContent.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showContent.value = $event),
            trigger: docAfterPopperOptions.value.trigger
          }, {
            reference: Vue.withCtx(() => [
              docAfterPopperOptions.value.buttonHtml ? (Vue.openBlock(), Vue.createElementBlock("div", {
                key: 0,
                innerHTML: docAfterPopperOptions.value.buttonHtml,
                role: "button",
                "aria-expanded": showContent.value,
                "aria-controls": `${Vue.unref(ns).e("content")}`
              }, null, 8, _hoisted_2$w)) : docAfterPopperOptions.value.title ? (Vue.openBlock(), Vue.createElementBlock("button", {
                key: 1,
                class: Vue.normalizeClass(Vue.unref(ns).e("button")),
                "aria-expanded": showContent.value,
                "aria-controls": `${Vue.unref(ns).e("content")}`,
                "aria-live": "polite"
              }, [
                icon.value ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                  key: 0,
                  class: Vue.normalizeClass(Vue.unref(ns).e("button__icon")),
                  icon: icon.value,
                  size: 16,
                  "aria-hidden": "true"
                }, null, 8, ["class", "icon"])) : Vue.createCommentVNode("v-if", true),
                docAfterPopperOptions.value.title ? (Vue.openBlock(), Vue.createElementBlock("span", {
                  key: 1,
                  innerHTML: docAfterPopperOptions.value.title
                }, null, 8, _hoisted_4$m)) : Vue.createCommentVNode("v-if", true)
              ], 10, _hoisted_3$o)) : Vue.createCommentVNode("v-if", true)
            ]),
            default: Vue.withCtx(() => [
              Vue.createElementVNode("div", {
                class: Vue.normalizeClass([Vue.unref(ns).e("content"), Vue.unref(ns).m("doc-after-popper")]),
                "aria-label": Vue.unref(t)("tk.articleAppreciation.contentLabel")
              }, [
                Vue.createElementVNode("div", {
                  class: Vue.normalizeClass(Vue.unref(ns).e("content")),
                  innerHTML: docAfterPopperOptions.value.content
                }, null, 10, _hoisted_6$a)
              ], 10, _hoisted_5$e)
            ]),
            _: 1
            /* STABLE */
          }, 8, ["modelValue", "trigger"])
        ], 10, _hoisted_1$G);
      };
    }
  });

  var _sfc_main$$ = /* @__PURE__ */ Vue.defineComponent({
    __name: "index",
    setup(__props) {
      const ns = useNamespace("article-heading-highlight");
      const handleHighlight = () => {
        if (!isClient || !window.location.hash) return;
        const targetedHashId = decodeURIComponent(window.location.hash);
        if (!targetedHashId) return;
        let elem;
        try {
          elem = document.querySelector(targetedHashId);
        } catch (e) {
          return console.error(e);
        }
        if (!elem) return;
        if (!elem.classList.contains(ns.b())) {
          elem.classList.add(ns.b());
        }
        elem.classList.remove(ns.b());
        setTimeout(() => {
          if (elem) elem.classList.add(ns.b());
        }, 10);
      };
      const route = vitepress.useRoute();
      Vue.watch(route, async () => {
        await Vue.nextTick();
        handleHighlight();
      });
      useEventListener(() => window, "hashchange", handleHighlight);
      return (_ctx, _cache) => {
        return null;
      };
    }
  });

  var _sfc_main$_ = /* @__PURE__ */ Vue.defineComponent({
    __name: "index",
    setup(__props) {
      const { getTeekConfig } = useTeekConfig();
      const imageViewer = Vue.computed(() => {
        const { imageViewer: imageViewer2 = {} } = getTeekConfig("articleAnalyze", {});
        return imageViewer2;
      });
      const previewImage = (e) => {
        const target = e.target;
        if (target.tagName.toLowerCase() === "img" && !target.className.includes("image-viewer__img") && // 处于预览状态，点击/拖拽图片时，不重新触发预览
        !target.className.includes("no-preview")) {
          const imgDoms = target.querySelectorAll(".content-container .main img");
          const imgs = Array.from(imgDoms);
          const urlList = imgs.map((el) => el.src);
          let initialIndex = imgs.findIndex((el) => el === target);
          const url = target.getAttribute("src");
          if (initialIndex === -1 && url) {
            urlList.push(url);
            initialIndex = urlList.length - 1;
          }
          createImageViewer({ infinite: false, ...imageViewer.value, urlList, initialIndex });
        }
      };
      useEventListener(() => document.querySelector("#VPContent"), "click", previewImage);
      return (_ctx, _cache) => {
        return null;
      };
    }
  });

  const _hoisted_1$F = { key: 0 };
  const _hoisted_2$v = ["href", "aria-label"];
  const _hoisted_3$n = ["id"];
  const _hoisted_4$l = ["href", "aria-label"];
  const _hoisted_5$d = ["href"];
  const _hoisted_6$9 = { "aria-describedby": `overview-title` };
  const _hoisted_7$5 = ["href", "aria-label"];
  var _sfc_main$Z = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ArticleOverviewPage" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("article-overview");
      const { t } = useLocale();
      const posts = usePosts();
      const { localeIndex, site, theme, frontmatter } = vitepress.useData();
      const { getTeekConfigRef } = useTeekConfig();
      const categoryConfig = getTeekConfigRef("category", {
        path: "/categories"
      });
      const categories = Vue.computed(() => posts.value.groupPosts.categories);
      const eachFileWords = Vue.computed(() => theme.value.docAnalysisInfo?.eachFileWords || []);
      const categoriesPageLink = Vue.computed(() => {
        const localeIndexConst = localeIndex.value;
        const localeName = localeIndexConst !== "root" ? `/${localeIndexConst}` : "";
        return `${localeName}${categoryConfig.value.path}${site.value.cleanUrls ? "" : ".html"}`;
      });
      const getFileWords = (url) => {
        return eachFileWords.value.filter((item) => {
          const path = "/" + item.fileInfo.relativePath.replace(".md", "");
          return [path, `${path}.html`].includes(url);
        })[0];
      };
      const enhancedCategories = Vue.computed(() => {
        return Object.entries(categories.value).map(([key, items]) => ({
          name: key,
          data: items.map((item) => {
            const wordsInfo = getFileWords(item.url);
            return {
              ...item,
              wordCount: wordsInfo?.wordCount || "-",
              readingTime: wordsInfo?.readingTime || "-"
            };
          }) || []
        })).sort(
          (a, b) => new Date(b.data[b.data.length - 1].date).getTime() - new Date(a.data[a.data.length - 1].date).getTime()
        );
      });
      const formatPublishDate = (date) => {
        const publishDateFormat = frontmatter.value.publishDateFormat;
        if (!publishDateFormat) return date;
        return formatDate(date || /* @__PURE__ */ new Date(), publishDateFormat);
      };
      return (_ctx, _cache) => {
        const _component_Content = Vue.resolveComponent("Content");
        return Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1y), {
          doc: "",
          aside: "",
          class: Vue.normalizeClass(Vue.unref(ns).b())
        }, {
          default: Vue.withCtx(() => [
            Vue.unref(frontmatter).title ? (Vue.openBlock(), Vue.createElementBlock("h1", _hoisted_1$F, [
              Vue.createTextVNode(
                Vue.toDisplayString(Vue.unref(frontmatter).title) + " ",
                1
                /* TEXT */
              ),
              Vue.createElementVNode("a", {
                class: "header-anchor",
                href: `#${Vue.unref(frontmatter).title}`,
                "aria-label": `Permalink to '${Vue.unref(frontmatter).title}'`
              }, null, 8, _hoisted_2$v)
            ])) : Vue.createCommentVNode("v-if", true),
            Vue.createVNode(_component_Content),
            (Vue.openBlock(true), Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(enhancedCategories.value, (item) => {
                return Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  {
                    key: item.name
                  },
                  [
                    Vue.createElementVNode("h2", {
                      id: `${item.name}-${Vue.unref(t)("tk.articleOverview.overview")}`
                    }, [
                      Vue.createTextVNode(
                        Vue.toDisplayString(item.name) + " " + Vue.toDisplayString(Vue.unref(t)("tk.articleOverview.overview")) + " ",
                        1
                        /* TEXT */
                      ),
                      Vue.createElementVNode("a", {
                        class: "header-anchor",
                        href: `#${item.name}-${Vue.unref(t)("tk.articleOverview.overview")}`,
                        "aria-label": `Permalink to '${item.name}-${Vue.unref(t)("tk.articleOverview.overview")}'`
                      }, null, 8, _hoisted_4$l)
                    ], 8, _hoisted_3$n),
                    Vue.createElementVNode("a", {
                      href: `${categoriesPageLink.value}?category=${item.name}`,
                      "aria-describedby": `overview-title`
                    }, Vue.toDisplayString(item.name) + " " + Vue.toDisplayString(Vue.unref(t)("tk.articleOverview.category")), 9, _hoisted_5$d),
                    Vue.createElementVNode("table", _hoisted_6$9, [
                      Vue.createElementVNode("thead", null, [
                        Vue.createElementVNode("tr", null, [
                          Vue.createElementVNode(
                            "th",
                            null,
                            Vue.toDisplayString(Vue.unref(t)("tk.articleOverview.name")),
                            1
                            /* TEXT */
                          ),
                          Vue.createElementVNode(
                            "th",
                            null,
                            Vue.toDisplayString(Vue.unref(t)("tk.articleOverview.title")),
                            1
                            /* TEXT */
                          ),
                          Vue.createElementVNode(
                            "th",
                            null,
                            Vue.toDisplayString(Vue.unref(t)("tk.articleOverview.date")),
                            1
                            /* TEXT */
                          ),
                          Vue.createElementVNode(
                            "th",
                            null,
                            Vue.toDisplayString(Vue.unref(t)("tk.articleOverview.wordCount")),
                            1
                            /* TEXT */
                          ),
                          Vue.createElementVNode(
                            "th",
                            null,
                            Vue.toDisplayString(Vue.unref(t)("tk.articleOverview.readingTime")),
                            1
                            /* TEXT */
                          )
                        ])
                      ]),
                      Vue.createElementVNode("tbody", null, [
                        (Vue.openBlock(true), Vue.createElementBlock(
                          Vue.Fragment,
                          null,
                          Vue.renderList(item.data, (data) => {
                            return Vue.openBlock(), Vue.createElementBlock("tr", {
                              key: data.url
                            }, [
                              Vue.createElementVNode(
                                "td",
                                null,
                                Vue.toDisplayString(item.name),
                                1
                                /* TEXT */
                              ),
                              Vue.createElementVNode("td", null, [
                                Vue.createElementVNode("a", {
                                  href: data.url && Vue.unref(vitepress.withBase)(data.url),
                                  "aria-label": data.title
                                }, [
                                  data.title ? (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(Vue.unref(createDynamicComponent)(data.title)), { key: 0 })) : Vue.createCommentVNode("v-if", true)
                                ], 8, _hoisted_7$5)
                              ]),
                              Vue.createElementVNode(
                                "td",
                                null,
                                Vue.toDisplayString(formatPublishDate(data.date)),
                                1
                                /* TEXT */
                              ),
                              Vue.createElementVNode(
                                "td",
                                null,
                                Vue.toDisplayString(data.wordCount),
                                1
                                /* TEXT */
                              ),
                              Vue.createElementVNode(
                                "td",
                                null,
                                Vue.toDisplayString(data.readingTime),
                                1
                                /* TEXT */
                              )
                            ]);
                          }),
                          128
                          /* KEYED_FRAGMENT */
                        ))
                      ])
                    ])
                  ],
                  64
                  /* STABLE_FRAGMENT */
                );
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["class"]);
      };
    }
  });

  var _sfc_main$Y = /* @__PURE__ */ Vue.defineComponent({
    __name: "index",
    setup(__props) {
      const ns = useNamespace();
      const { getTeekConfigRef } = useTeekConfig();
      const themeConfig = getTeekConfigRef(null, {
        vpHome: true,
        pageStyle: "default"
      });
      const initPageStyle = async () => {
        if (!isClient) return;
        await Vue.nextTick();
        const tkLayoutDom = document.querySelector(`.${ns.join("layout")}`);
        ["default", "card", "card-nav", "segment", "segment-nav"].forEach(
          (item) => tkLayoutDom?.classList.remove(ns.join(item))
        );
        tkLayoutDom?.classList.add(ns.join(themeConfig.value.pageStyle));
      };
      Vue.watch(() => themeConfig.value.pageStyle, initPageStyle, { immediate: true });
      Vue.watch(() => themeConfig.value.vpHome, initPageStyle);
      return (_ctx, _cache) => {
        return null;
      };
    }
  });

  const _hoisted_1$E = ["aria-label"];
  const _hoisted_2$u = {
    key: 0,
    class: "flx-center"
  };
  const _hoisted_3$m = {
    key: 1,
    class: "flx-center"
  };
  var _sfc_main$X = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ArticleShare" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("article-share");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const articleShareConfig = getTeekConfigRef("articleShare", {
        icon: shareIcon,
        text: t("tk.articleShare.text"),
        copiedIcon: thumbsIcon,
        copiedText: t("tk.articleShare.copiedText"),
        query: false,
        hash: false
      });
      const shareLink = Vue.computed(() => {
        const { hash, query } = articleShareConfig.value;
        const { origin, pathname, search } = location;
        return `${origin}${pathname}${query ? search : ""}${hash ? location.hash : ""}`;
      });
      const { copy, copied } = useClipboard(2e3);
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass(Vue.unref(ns).b())
          },
          [
            Vue.createElementVNode("button", {
              class: Vue.normalizeClass([Vue.unref(ns).e("button"), { copied: Vue.unref(copied) }, "flx-center"]),
              "aria-label": Vue.unref(copied) ? Vue.unref(articleShareConfig).copiedText : Vue.unref(articleShareConfig).text,
              "aria-live": "polite",
              onClick: _cache[0] || (_cache[0] = ($event) => Vue.unref(copy)(shareLink.value))
            }, [
              !Vue.unref(copied) ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$u, [
                Vue.createVNode(Vue.unref(_sfc_main$1t), {
                  icon: Vue.unref(shareIcon),
                  style: { "margin-right": "4px" }
                }, null, 8, ["icon"]),
                Vue.createTextVNode(
                  " " + Vue.toDisplayString(Vue.unref(articleShareConfig).text),
                  1
                  /* TEXT */
                )
              ])) : (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_3$m, [
                Vue.createVNode(Vue.unref(_sfc_main$1t), {
                  icon: Vue.unref(thumbsIcon),
                  style: { "margin-right": "4px" }
                }, null, 8, ["icon"]),
                Vue.createTextVNode(
                  " " + Vue.toDisplayString(Vue.unref(articleShareConfig).copiedText),
                  1
                  /* TEXT */
                )
              ]))
            ], 10, _hoisted_1$E)
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const _hoisted_1$D = ["href", "aria-label"];
  const _hoisted_2$t = { key: 1 };
  const _hoisted_3$l = ["href", "aria-label"];
  var _sfc_main$W = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ArticleUpdate" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("article-update");
      const { t } = useLocale();
      const posts = usePosts();
      const route = vitepress.useRoute();
      const { frontmatter } = vitepress.useData();
      const { getTeekConfigRef } = useTeekConfig();
      const { archivesPath } = usePagePath();
      const articleConfig = getTeekConfigRef("articleUpdate", {
        limit: 3
      });
      const updatePosts = Vue.computed(() => {
        const path = "/" + route.data.filePath.replace(".md", "");
        return [
          ...posts.value.sortPostsByDate.filter((item) => ![route.path, path, `${path}.html`].includes(item.url)).slice(0, articleConfig.value.limit),
          { title: "\u66F4\u591A\u6587\u7AE0 >", url: archivesPath.value, frontmatter: {}, date: "" }
        ];
      });
      return (_ctx, _cache) => {
        return Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass(Vue.unref(ns).b())
          },
          [
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass([Vue.unref(ns).e("title"), "flx-align-center"])
              },
              [
                Vue.createVNode(Vue.unref(_sfc_main$1t), {
                  icon: Vue.unref(editPenIcon),
                  class: "edit-icon",
                  "aria-hidden": "true"
                }, null, 8, ["icon"]),
                Vue.unref(archivesPath) ? (Vue.openBlock(), Vue.createElementBlock("a", {
                  key: 0,
                  href: Vue.unref(vitepress.withBase)(Vue.unref(archivesPath)),
                  class: "hover-color",
                  "aria-label": Vue.unref(t)("tk.articleUpdate.label")
                }, Vue.toDisplayString(Vue.unref(t)("tk.articleUpdate.label")), 9, _hoisted_1$D)) : (Vue.openBlock(), Vue.createElementBlock(
                  "span",
                  _hoisted_2$t,
                  Vue.toDisplayString(Vue.unref(t)("tk.articleUpdate.label")),
                  1
                  /* TEXT */
                ))
              ],
              2
              /* CLASS */
            ),
            Vue.createElementVNode("ul", null, [
              (Vue.openBlock(true), Vue.createElementBlock(
                Vue.Fragment,
                null,
                Vue.renderList(updatePosts.value, (item, index) => {
                  return Vue.openBlock(), Vue.createElementBlock("li", {
                    key: item.url,
                    class: "flx-center"
                  }, [
                    Vue.createElementVNode(
                      "span",
                      {
                        class: Vue.normalizeClass(Vue.unref(ns).m("num")),
                        "aria-hidden": "true"
                      },
                      Vue.toDisplayString(index !== updatePosts.value.length - 1 ? (index + 1).toString().padStart(2, "0") : ""),
                      3
                      /* TEXT, CLASS */
                    ),
                    Vue.createElementVNode(
                      "div",
                      {
                        class: Vue.normalizeClass(Vue.unref(ns).e("content"))
                      },
                      [
                        item.url ? (Vue.openBlock(), Vue.createElementBlock("a", {
                          key: 0,
                          href: Vue.unref(vitepress.withBase)(item.url),
                          class: "flx-1 hover-color sle",
                          "aria-label": item.title
                        }, [
                          Vue.createVNode(Vue.unref(_sfc_main$17), {
                            post: item,
                            "title-tag-props": { position: "right", size: "small" }
                          }, null, 8, ["post"])
                        ], 8, _hoisted_3$l)) : Vue.createCommentVNode("v-if", true),
                        item.date ? (Vue.openBlock(), Vue.createElementBlock(
                          "span",
                          {
                            key: 1,
                            class: Vue.normalizeClass(Vue.unref(ns).em("content", "date"))
                          },
                          Vue.toDisplayString(item.date),
                          3
                          /* TEXT, CLASS */
                        )) : Vue.createCommentVNode("v-if", true)
                      ],
                      2
                      /* CLASS */
                    )
                  ]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ])
          ],
          2
          /* CLASS */
        )), [
          [Vue.vShow, Vue.unref(frontmatter).article !== false]
        ]);
      };
    }
  });

  const _hoisted_1$C = {
    key: 0,
    class: "mask"
  };
  var _sfc_main$V = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "BodyBgImage" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("body-bg-image");
      const { getTeekConfigRef } = useTeekConfig();
      const bodyBgImgConfig = getTeekConfigRef("bodyBgImg", {
        imgSrc: void 0,
        imgOpacity: 1,
        imgInterval: 15e3,
        imgShuffle: false,
        mask: false,
        maskBg: "rgba(0, 0, 0, 0.2)"
      });
      const dataArray = Vue.computed(() => {
        const imgSrc = bodyBgImgConfig.value.imgSrc;
        return [isFunction(imgSrc) ? imgSrc() : imgSrc || []].flat().map((item) => item && vitepress.withBase(item));
      });
      const {
        data: imageSrc,
        start,
        index
      } = useSwitchData(dataArray, {
        timeout: bodyBgImgConfig.value.imgInterval,
        shuffle: bodyBgImgConfig.value.imgShuffle,
        onAfterUpdate: () => {
          const nextIndex = (index.value + 1) % dataArray.value.length;
          const newValue = dataArray.value[nextIndex];
          if (newValue) {
            const img = new Image();
            img.src = newValue;
          }
        }
      });
      Vue.onMounted(() => {
        start();
      });
      const getStyle = () => {
        const { imgSrc, imgOpacity, maskBg } = bodyBgImgConfig.value;
        const imgBgVar = ns.cssVarName("body-bg-img");
        const imgBgOpacityVar = ns.cssVarName("body-bg-img-opacity");
        const maskBgColorVar = ns.cssVarName("body-mask-bg-color");
        if (!imgSrc?.length) return { [imgBgVar]: ns.cssVar("bg-img-default") };
        return {
          [imgBgVar]: `url(${imageSrc.value}) center center / cover no-repeat`,
          [imgBgOpacityVar]: imgOpacity,
          [maskBgColorVar]: isString$1(maskBg) ? maskBg : `rgba(0, 0, 0, ${maskBg})`
        };
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass(Vue.unref(ns).b()),
            style: Vue.normalizeStyle(getStyle())
          },
          [
            Vue.unref(bodyBgImgConfig).mask ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$C)) : Vue.createCommentVNode("v-if", true)
          ],
          6
          /* CLASS, STYLE */
        );
      };
    }
  });

  const _hoisted_1$B = ["href", "aria-label"];
  const _hoisted_2$s = ["innerHTML"];
  const _hoisted_3$k = ["id", "aria-labelledby"];
  const _hoisted_4$k = ["href", "aria-label"];
  const _hoisted_5$c = ["id"];
  const _hoisted_6$8 = ["aria-label"];
  var _sfc_main$U = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "CatalogueItem" },
    __name: "CatalogueItem",
    props: {
      item: {},
      index: {}
    },
    setup(__props) {
      const nsSub = useNamespace("sub-catalogue");
      const nsItem = useNamespace("catalogue-item");
      return (_ctx, _cache) => {
        const _component_CatalogueItem = Vue.resolveComponent("CatalogueItem", true);
        return Vue.openBlock(), Vue.createElementBlock(
          "li",
          {
            class: Vue.normalizeClass(__props.item.children ? Vue.unref(nsSub).b() : Vue.unref(nsItem).b())
          },
          [
            !__props.item.children ? (Vue.openBlock(), Vue.createElementBlock("a", {
              key: 0,
              href: __props.item.url && Vue.unref(vitepress.withBase)(__props.item.url),
              "aria-label": `${__props.index}. ${__props.item.title}`
            }, [
              Vue.createTextVNode(
                Vue.toDisplayString(__props.index) + ". ",
                1
                /* TEXT */
              ),
              Vue.createElementVNode("span", {
                innerHTML: __props.item.title
              }, null, 8, _hoisted_2$s),
              __props.item.frontmatter?.titleTag ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1b), {
                key: 0,
                text: __props.item.frontmatter?.titleTag,
                position: "right",
                size: "small",
                "aria-label": __props.item.frontmatter?.titleTag
              }, null, 8, ["text", "aria-label"])) : Vue.createCommentVNode("v-if", true)
            ], 8, _hoisted_1$B)) : __props.item.children.length ? (Vue.openBlock(), Vue.createElementBlock(
              Vue.Fragment,
              { key: 1 },
              [
                Vue.createElementVNode("div", {
                  id: __props.item.title,
                  class: Vue.normalizeClass(Vue.unref(nsSub).e("title")),
                  role: "group",
                  "aria-labelledby": `${__props.item.title}-label`
                }, [
                  Vue.createElementVNode("a", {
                    href: `#${__props.item.title}`,
                    class: "anchor",
                    "aria-label": __props.item.title
                  }, "#", 8, _hoisted_4$k),
                  Vue.createElementVNode("span", {
                    id: `${__props.item.title}-label`
                  }, Vue.toDisplayString(`${__props.index}. ${__props.item.title}`), 9, _hoisted_5$c)
                ], 10, _hoisted_3$k),
                __props.item.children ? (Vue.openBlock(), Vue.createElementBlock("ul", {
                  key: 0,
                  class: Vue.normalizeClass(`${Vue.unref(nsSub).e("inline")} flx-wrap-between`),
                  "aria-label": __props.item.title
                }, [
                  Vue.createCommentVNode(" \u9012\u5F52\u81EA\u5DF1 "),
                  (Vue.openBlock(true), Vue.createElementBlock(
                    Vue.Fragment,
                    null,
                    Vue.renderList(__props.item.children, (item, i) => {
                      return Vue.openBlock(), Vue.createBlock(_component_CatalogueItem, {
                        key: i,
                        item,
                        index: `${__props.index}-${i + 1}`
                      }, null, 8, ["item", "index"]);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ], 10, _hoisted_6$8)) : Vue.createCommentVNode("v-if", true)
              ],
              64
              /* STABLE_FRAGMENT */
            )) : Vue.createCommentVNode("v-if", true)
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const _hoisted_1$A = { id: "catalogue-header-title" };
  const _hoisted_2$r = { class: "description" };
  const _hoisted_3$j = {
    id: "catalogue-list-title",
    class: "title"
  };
  const _hoisted_4$j = { class: "flx-wrap-between" };
  const _hoisted_5$b = { class: "vp-doc" };
  var _sfc_main$T = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "CataloguePage" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("catalogue");
      const { t } = useLocale();
      const { theme, frontmatter } = vitepress.useData();
      const catalogues = Vue.computed(() => theme.value.catalogues?.inv[frontmatter.value.path]?.catalogues);
      return (_ctx, _cache) => {
        const _component_Content = Vue.resolveComponent("Content");
        return Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1y), {
          class: Vue.normalizeClass(Vue.unref(ns).b()),
          "aria-label": Vue.unref(t)("tk.catalogue.label")
        }, {
          default: Vue.withCtx(() => [
            Vue.renderSlot(_ctx.$slots, "teek-catalogue-top-before"),
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass(Vue.unref(ns).e("header")),
                role: "group",
                "aria-labelledby": "catalogue-header-title"
              },
              [
                Vue.createElementVNode(
                  "h2",
                  _hoisted_1$A,
                  Vue.toDisplayString(Vue.unref(frontmatter).title),
                  1
                  /* TEXT */
                ),
                Vue.createElementVNode(
                  "div",
                  _hoisted_2$r,
                  Vue.toDisplayString(Vue.unref(frontmatter).desc || Vue.unref(frontmatter).description),
                  1
                  /* TEXT */
                )
              ],
              2
              /* CLASS */
            ),
            Vue.renderSlot(_ctx.$slots, "teek-catalogue-top-after"),
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass(Vue.unref(ns).e("wrapper")),
                "aria-labelledby": "catalogue-list-title"
              },
              [
                Vue.createElementVNode(
                  "div",
                  _hoisted_3$j,
                  Vue.toDisplayString(Vue.unref(frontmatter).pageTitle || Vue.unref(t)("tk.catalogue.title")),
                  1
                  /* TEXT */
                ),
                Vue.createElementVNode("ul", _hoisted_4$j, [
                  (Vue.openBlock(true), Vue.createElementBlock(
                    Vue.Fragment,
                    null,
                    Vue.renderList(catalogues.value, (item, index) => {
                      return Vue.openBlock(), Vue.createBlock(_sfc_main$U, {
                        key: index,
                        item,
                        index: index + 1
                      }, null, 8, ["item", "index"]);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ])
              ],
              2
              /* CLASS */
            ),
            Vue.createElementVNode("div", _hoisted_5$b, [
              Vue.createVNode(_component_Content)
            ])
          ]),
          _: 3
          /* FORWARDED */
        }, 8, ["class", "aria-label"]);
      };
    }
  });

  var _sfc_main$S = /* @__PURE__ */ Vue.defineComponent({
    __name: "Overlay",
    emits: ["click"],
    setup(__props, { emit: __emit }) {
      const emits = __emit;
      const onClick = () => emits("click");
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: "code-block-overlay",
          onClick
        }, [
          _cache[0] || (_cache[0] = Vue.createElementVNode(
            "span",
            null,
            "\u67E5\u770B\u66F4\u591A",
            -1
            /* CACHED */
          )),
          Vue.createVNode(Vue.unref(_sfc_main$1t), {
            class: "overlay-icon",
            icon: Vue.unref(arrowDownIcon)
          }, null, 8, ["icon"])
        ]);
      };
    }
  });

  const createOverlay = (onClick) => {
    const container = document.createDocumentFragment();
    const app = Vue.createApp(_sfc_main$S, { onClick }).mount(container);
    return app.$el;
  };

  const documentAttribute = "code-block";
  const foldClass = "fold";
  const arrowClass = "code-arrow";
  var _sfc_main$R = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "CodeBlockToggle" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace();
      const { getTeekConfigRef } = useTeekConfig();
      const codeBlockConfig = getTeekConfigRef("codeBlock", {
        enabled: true,
        collapseHeight: 700,
        copiedDone: void 0,
        overlay: false,
        overlayHeight: 400,
        langTextTransform: ""
      });
      Vue.watch(
        codeBlockConfig,
        (newVal) => {
          if (!isClient) return;
          const { enabled = true, langTextTransform } = newVal || {};
          if (!enabled) return document.documentElement.removeAttribute(documentAttribute);
          document.documentElement.setAttribute(documentAttribute, ns.namespace);
          if (langTextTransform) {
            document.documentElement.style.setProperty(ns.cssVarName("code-block-lang-transform"), langTextTransform);
          }
          Vue.nextTick(() => initCodeBlock());
        },
        { immediate: true }
      );
      const initCodeBlock = () => {
        const modes = document.querySelectorAll(".vp-doc div[class*='language-']");
        Array.from(modes).forEach((item) => {
          const copyDom = item.querySelector(`.copy`);
          copyDom?.addEventListener("click", () => {
            codeBlockConfig.value.copiedDone?.(message);
          });
          const className = item.parentElement?.className;
          if (className?.includes("details") || className?.includes(ns.join("vp-code"))) return;
          const arrowElement = item.querySelector(`.${arrowClass}`);
          if (arrowElement) return;
          const newArrowElement = document.createElement("div");
          newArrowElement.setAttribute("aria-hidden", "true");
          newArrowElement.classList.add(arrowClass);
          newArrowElement.innerHTML = arrowDownIcon;
          if (codeBlockConfig.value.overlay) {
            const overlay = createOverlay(() => newArrowElement.click());
            item.appendChild(overlay);
          }
          addClickEvent(newArrowElement, item);
          item.append(newArrowElement);
        });
      };
      const addClickEvent = (arrowDom, codeDom) => {
        const modeHeight = getElementHeight(codeDom);
        codeDom.style.height = addUnit(modeHeight);
        const preDom = codeDom.querySelector("pre");
        const lineNumbersWrapperDom = codeDom.querySelector(".line-numbers-wrapper");
        const codeBlockOverlayDom = codeDom.querySelector(".code-block-overlay");
        const codeBlockState = {
          expand: { height: addUnit(modeHeight), display: "block", overlayDisplay: "none", speed: 80 },
          fold: {
            height: codeBlockConfig.value.overlay ? addUnit(codeBlockConfig.value.overlayHeight) ?? "400px" : ns.cssVar("code-block-fold-height"),
            display: codeBlockConfig.value.overlay ? "block" : "none",
            overlayDisplay: "flex",
            speed: 400
          }
        };
        let timer;
        const clearTimer = () => {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        };
        const toggle = () => {
          const isFold = arrowDom.classList.contains(foldClass);
          const state = codeBlockState[isFold ? "expand" : "fold"];
          codeDom.style.height = state.height;
          clearTimer();
          if (preDom || lineNumbersWrapperDom) {
            timer = setTimeout(() => {
              if (preDom) preDom.style.display = state.display;
              if (lineNumbersWrapperDom) lineNumbersWrapperDom.style.display = state.display;
              if (codeBlockOverlayDom) codeBlockOverlayDom.style.display = state.overlayDisplay;
              clearTimer();
            }, state.speed);
          }
          arrowDom.classList.toggle(foldClass);
        };
        useEventListener(arrowDom, "click", toggle);
        const collapseHeight = codeBlockConfig.value.collapseHeight;
        if (isBoolean$1(collapseHeight)) {
          if (collapseHeight) toggle();
          else if (codeBlockOverlayDom) codeBlockOverlayDom.style.display = "none";
        } else if (collapseHeight && modeHeight > collapseHeight) toggle();
        else if (codeBlockOverlayDom) codeBlockOverlayDom.style.display = "none";
      };
      const getElementHeight = (item) => {
        const parentElementClass = item.parentElement?.className || "";
        if (!parentElementClass.includes("blocks")) return item.offsetHeight;
        if (parentElementClass.includes("blocks") && item.className.includes("active")) return item.offsetHeight;
        item.style.display = "block";
        const height = item.offsetHeight;
        item.style.display = "";
        return height;
      };
      return (_ctx, _cache) => {
        return null;
      };
    }
  });

  const artalkContext = Symbol("artalk");

  const _hoisted_1$z = ["href"];
  const artalkId = "artalk";
  var _sfc_main$Q = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "CommentArtalk" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace();
      const vpRouter = useVpRouter();
      const { getTeekConfig } = useTeekConfig();
      const { isDark, page } = vitepress.useData();
      const artalkOptions = getTeekConfig("comment", {}).options;
      const { server, site, ...options } = artalkOptions;
      const artalkRef = Vue.ref(null);
      const artalkJs = Vue.ref(null);
      const artalk = Vue.ref();
      const initArtalkByInject = () => {
        const getArtalkInstance = Vue.inject(artalkContext, () => null);
        const el = artalkRef.value || `#${artalkId}`;
        const artalkInstance = getArtalkInstance?.(el, artalkOptions);
        if (!artalkInstance) return false;
        artalk.value = artalkInstance;
        switchDark();
        return true;
      };
      const initArtalkByJs = () => {
        if (!isClient) return console.error("[Teek Error] Not in a client");
        const Artalk = window.Artalk;
        const el = artalkRef.value || `#${artalkId}`;
        if (!Artalk || !artalkRef.value) {
          return console.error("[Teek Error] Artalk initialization failed. Unable to load online js file from " + server);
        }
        artalk.value = Artalk.init({
          darkMode: isDark.value,
          ...options,
          el,
          pageKey: vpRouter.route.path,
          pageTitle: page.value.title,
          server,
          site
        });
        switchDark();
      };
      const initJs = () => {
        const t = artalkJs.value;
        if (t) t.onload = initArtalkByJs;
      };
      const reloadArtalk = () => {
        const a = artalk.value;
        a?.update({
          pageKey: vpRouter.route.path,
          pageTitle: page.value.title
        });
        a?.reload();
      };
      Vue.onMounted(() => {
        if (!initArtalkByInject() && server) {
          initJs();
          return artalk.value && vpRouter.bindAfterRouteChange(ns.join("artalk"), () => reloadArtalk());
        }
        console.error(
          "[Teek Error] Artalk initialization failed. Please configure the 'server' and 'site' or provide the artalk instance"
        );
      });
      Vue.onUnmounted(() => {
        const a = artalk.value;
        if (a) a.destroy();
      });
      const switchDark = () => {
        setTimeout(() => {
          const a = artalk.value;
          if (a) a.setDarkMode(isDark.value);
        }, 100);
      };
      Vue.watch(isDark, () => switchDark());
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass(Vue.unref(ns).b("artalk"))
          },
          [
            Vue.unref(server) ? (Vue.openBlock(), Vue.createElementBlock("link", {
              key: 0,
              rel: "stylesheet",
              href: `${Vue.unref(server)}/dist/Artalk.css`,
              crossorigin: "anonymous"
            }, null, 8, _hoisted_1$z)) : Vue.createCommentVNode("v-if", true),
            Vue.createElementVNode(
              "div",
              {
                id: artalkId,
                ref_key: "artalkRef",
                ref: artalkRef
              },
              null,
              512
              /* NEED_PATCH */
            ),
            Vue.unref(server) ? (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent("script"), {
              key: 1,
              src: `${Vue.unref(server)}/dist/Artalk.js`,
              crossorigin: "anonymous",
              ref_key: "artalkJs",
              ref: artalkJs
            }, null, 8, ["src"])) : Vue.createCommentVNode("v-if", true)
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const giscusContext = Symbol("giscus");

  var _sfc_main$P = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "CommentGiscus" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace();
      const vpRouter = useVpRouter();
      const { getTeekConfig } = useTeekConfig();
      const { isDark } = vitepress.useData();
      const giscusOptions = getTeekConfig("comment", {}).options;
      const {
        repo,
        repoId,
        category,
        categoryId,
        mapping = "pathname",
        strict = "0",
        reactionsEnabled = "1",
        emitMetadata = "0",
        inputPosition = "top",
        lang = "zh-CN",
        theme: giscusThemeConfig,
        loading = "eager",
        useOnline = true,
        link = "https://giscus.app/client.js",
        integrity,
        ...options
      } = giscusOptions;
      const giscusTheme = Vue.computed(() => {
        if (isFunction(giscusThemeConfig)) return giscusThemeConfig(isDark.value);
        return giscusThemeConfig || (isDark.value ? "dark" : "light");
      });
      const giscusComponentFn = Vue.inject(giscusContext, () => null);
      const giscusComponent = giscusComponentFn?.(giscusOptions);
      const isShow = Vue.ref(false);
      const reloadGiscus = () => {
        isShow.value = false;
        Vue.nextTick(() => {
          isShow.value = true;
        });
      };
      Vue.onMounted(() => {
        if (!useOnline && !giscusComponent) {
          return console.error(
            "[Teek Error] Giscus initialization failed. Please configure the 'useOnline' to 'true' or provide the giscus component"
          );
        }
        reloadGiscus();
        vpRouter.bindAfterRouteChange(ns.join("giscus"), () => {
          reloadGiscus();
        });
      });
      return (_ctx, _cache) => {
        return isShow.value ? (Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            key: 0,
            class: Vue.normalizeClass(Vue.unref(ns).b("giscus"))
          },
          [
            Vue.unref(giscusComponent) ? (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(Vue.unref(giscusComponent)), Vue.mergeProps({
              key: 0,
              repo: Vue.unref(repo),
              "repo-id": Vue.unref(repoId),
              category: Vue.unref(category),
              "category-id": Vue.unref(categoryId),
              mapping: Vue.unref(mapping),
              "reactions-enabled": Vue.unref(reactionsEnabled),
              "emit-metadata": Vue.unref(emitMetadata),
              "input-position": Vue.unref(inputPosition),
              lang: Vue.unref(lang),
              theme: giscusTheme.value,
              loading: Vue.unref(loading)
            }, options), null, 16, ["repo", "repo-id", "category", "category-id", "mapping", "reactions-enabled", "emit-metadata", "input-position", "lang", "theme", "loading"])) : Vue.unref(useOnline) ? (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent("script"), Vue.mergeProps({
              key: 1,
              defer: "",
              src: Vue.unref(link),
              integrity: Vue.unref(integrity),
              "data-repo": Vue.unref(repo),
              "data-repo-id": Vue.unref(repoId),
              "data-category": Vue.unref(category),
              "data-category-id": Vue.unref(categoryId),
              "data-mapping": Vue.unref(mapping),
              "data-strict": Vue.unref(strict),
              "data-reactions-enabled": Vue.unref(reactionsEnabled),
              "data-emit-metadata": Vue.unref(emitMetadata),
              "data-input-position": Vue.unref(inputPosition),
              "data-theme": giscusTheme.value,
              "data-lang": Vue.unref(lang)
            }, options, { crossorigin: "anonymous" }), null, 16, ["src", "integrity", "data-repo", "data-repo-id", "data-category", "data-category-id", "data-mapping", "data-strict", "data-reactions-enabled", "data-emit-metadata", "data-input-position", "data-theme", "data-lang"])) : Vue.createCommentVNode("v-if", true)
          ],
          2
          /* CLASS */
        )) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  const twikooContext = Symbol("twikoo");

  const _hoisted_1$y = ["href", "integrity"];
  var _sfc_main$O = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "CommentTwikoo" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace();
      const vpRouter = useVpRouter();
      const { getTeekConfig } = useTeekConfig();
      const twikooOptions = getTeekConfig("comment", {}).options;
      const {
        envId,
        jsLink = "https://cdn.jsdelivr.net/npm/twikoo@{version}/dist/twikoo.nocss.js",
        jsIntegrity,
        cssLink = "https://cdn.jsdelivr.net/npm/twikoo@{version}/dist/twikoo.css",
        version = "1.6.44",
        katex,
        timeout = 700,
        ...options
      } = twikooOptions;
      const initTwikoo = () => {
        if (!isClient) return console.error("[Teek Error] Not in a client");
        if (!envId) return console.error("[Teek Error] Twikoo initialization failed. Please configure the 'envId'");
        const getTwikooInstance = Vue.inject(twikooContext, () => null);
        const twikooOption = { ...options, envId };
        if (getTwikooInstance) getTwikooInstance("#twikoo", twikooOption);
        else if (window.twikoo) window.twikoo.init({ ...twikooOption, el: "#twikoo" });
      };
      const twikooJs = Vue.ref(null);
      const initJs = () => {
        const t = twikooJs.value;
        if (t) t.onload = initTwikoo;
      };
      const reloadTwikoo = (to) => {
        if (to) setTimeout(initTwikoo, timeout);
      };
      const initCss = () => {
        fetch(cssLink.replace("{version}", version)).then((response) => {
          if (!response.ok) throw new Error("[Teek Error] Twikoo Css Link Network response was not ok");
          return response.text();
        }).then((data) => {
          if (document.getElementById("twikoo-css")) return;
          const style = document.createElement("style");
          style.type = "text/css";
          style.id = "twikoo-css";
          style.textContent = `.${ns.b("twikoo")} {${data}}`;
          document.head.appendChild(style);
        });
      };
      Vue.onMounted(() => {
        initJs();
        initCss();
        twikooJs.value && vpRouter.bindAfterRouteChange(ns.join("twikoo"), (href) => reloadTwikoo(href));
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass(Vue.unref(ns).b("twikoo"))
          },
          [
            Vue.createCommentVNode(" KaTeX "),
            Vue.unref(katex) ? (Vue.openBlock(), Vue.createElementBlock(
              Vue.Fragment,
              { key: 0 },
              [
                Vue.createElementVNode("link", {
                  rel: "stylesheet",
                  href: Vue.unref(katex).cssLink,
                  integrity: Vue.unref(katex).cssIntegrity,
                  crossorigin: "anonymous"
                }, null, 8, _hoisted_1$y),
                (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent("script"), {
                  defer: "",
                  src: Vue.unref(katex).coreJsLink,
                  integrity: Vue.unref(katex).coreJsIntegrity,
                  crossorigin: "anonymous"
                }, null, 8, ["src", "integrity"])),
                (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent("script"), {
                  defer: "",
                  src: Vue.unref(katex).renderJsLink,
                  integrity: Vue.unref(katex).renderJsIntegrity,
                  crossorigin: "anonymous"
                }, null, 8, ["src", "integrity"]))
              ],
              64
              /* STABLE_FRAGMENT */
            )) : Vue.createCommentVNode("v-if", true),
            _cache[0] || (_cache[0] = Vue.createElementVNode(
              "div",
              { id: "twikoo" },
              null,
              -1
              /* CACHED */
            )),
            (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent("script"), {
              src: Vue.unref(jsLink).replace("{version}", Vue.unref(version)),
              integrity: Vue.unref(jsIntegrity),
              crossorigin: "anonymous",
              ref_key: "twikooJs",
              ref: twikooJs
            }, null, 8, ["src", "integrity"]))
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const walineContext = Symbol("waline");

  const _hoisted_1$x = ["href", "integrity"];
  const walineId = "waline";
  var _sfc_main$N = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "CommentWaline" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace();
      const vpRouter = useVpRouter();
      const { getTeekConfig } = useTeekConfig();
      const walineOptions = getTeekConfig("comment", {}).options;
      const { serverURL, jsLink, cssLink, dark = "html[class='dark']", cssIntegrity, ...options } = walineOptions;
      let waline = null;
      const initWalineByInject = () => {
        const getWalineInstance = Vue.inject(walineContext, () => null);
        if (getWalineInstance) waline = getWalineInstance?.(`#${walineId}`, walineOptions);
        return waline;
      };
      const initWalineByJs = async () => {
        if (!jsLink) return;
        const { init } = await import(
          /* @vite-ignore */
          jsLink
        );
        waline = init({ dark, ...options, serverURL, el: `#${walineId}` });
      };
      const preventJump = () => {
        if (!isClient) return;
        const loginNickLink = document.querySelector(".wl-login-nick");
        loginNickLink && loginNickLink.removeAttribute("href");
      };
      Vue.onMounted(async () => {
        if (!initWalineByInject() && serverURL && jsLink) {
          await initWalineByJs();
          preventJump();
          return vpRouter.bindAfterRouteChange(ns.join("waline"), () => waline?.update());
        }
        console.error(
          "[Teek Error] Waline initialization failed. Please configure the 'jsLink' and 'serverURL' or provide the waline instance"
        );
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass(Vue.unref(ns).b("waline"))
          },
          [
            Vue.unref(cssLink) ? (Vue.openBlock(), Vue.createElementBlock("link", {
              key: 0,
              rel: "stylesheet",
              href: Vue.unref(cssLink),
              integrity: Vue.unref(cssIntegrity),
              crossorigin: "anonymous"
            }, null, 8, _hoisted_1$x)) : Vue.createCommentVNode("v-if", true),
            Vue.createElementVNode("div", { id: walineId })
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const _hoisted_1$w = ["innerHTML"];
  const _hoisted_2$q = ["innerHTML"];
  var _sfc_main$M = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "DemoCode" },
    __name: "index",
    props: {
      source: {},
      rawSource: {},
      path: {},
      description: {},
      options: {},
      effect: {}
    },
    setup(__props) {
      const props = __props;
      const ns = useNamespace("demo-code");
      const { t } = useLocale();
      const { copy, copied, isSupported } = useClipboard();
      const { frontmatter, isDark } = vitepress.useData();
      const {
        playgroundUrl = "",
        playgroundMainFileName = "App.vue",
        githubUrl = "",
        playgroundButtonTip = t("tk.demoCode.playground"),
        githubButtonTip = t("tk.demoCode.github"),
        copyButtonTip = t("tk.demoCode.copy"),
        collapseSourceButtonTip = t("tk.demoCode.collapseSource"),
        expandSourceButtonTip = t("tk.demoCode.expandSource")
      } = { ...JSON.parse(decodeURIComponent(props.options)), ...frontmatter.value.demo };
      const decodeSource = Vue.computed(() => decodeURIComponent(props.source));
      const decodeRawSource = Vue.computed(() => decodeURIComponent(props.rawSource));
      const decodedDescription = Vue.computed(() => decodeURIComponent(props.description));
      const effect = Vue.computed(() => props.effect === "true");
      const moduleFiles = undefined("/examples/**/*.vue", { eager: true });
      const DemoComponent = Vue.defineAsyncComponent(async () => {
        try {
          const key = Object.keys(moduleFiles).find((i) => i.endsWith(`/${props.path}`));
          return moduleFiles[key];
        } catch (error) {
          console.error(`[Teek Error] Failed to load component: '/${props.path}'`, error);
        }
      });
      const sourceVisible = Vue.ref(false);
      const handleToggleSourceVisible = (bol) => {
        if (bol !== void 0) sourceVisible.value = bol;
        else sourceVisible.value = !sourceVisible.value;
      };
      const handleEditPlayground = () => {
        const encoded = getPlaygroundEncoded(props.source);
        const darkParam = isDark.value ? "?theme=dark" : "";
        const link = playgroundUrl.includes("?") ? `${playgroundUrl}${darkParam.replace("?", "&")}` : `${playgroundUrl}${darkParam}`;
        const url = `${link.replace(/\/$/, "")}/#${encoded}`;
        window.open(url, "_blank");
      };
      const getPlaygroundEncoded = (source) => {
        const code = decodeURIComponent(source);
        const originCode = {
          [playgroundMainFileName]: code
        };
        const encoded = btoa(JSON.stringify(originCode));
        return encoded;
      };
      const handleEditGithub = () => {
        const url = `${githubUrl}/${props.path}`;
        window.open(url, "_blank");
      };
      const copyCode = async () => {
        if (!isSupported) console.error(t("tk.demoCode.notSupport"));
        await copy(decodeRawSource.value);
        copied.value ? message.success({
          message: t("tk.demoCode.copySuccess"),
          plain: true
        }) : message.error({
          message: t("tk.demoCode.copyFail"),
          plain: true
        });
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          Vue.Fragment,
          null,
          [
            decodedDescription.value ? (Vue.openBlock(), Vue.createElementBlock("div", {
              key: 0,
              class: Vue.normalizeClass(Vue.unref(ns).b("description")),
              innerHTML: decodedDescription.value
            }, null, 10, _hoisted_1$w)) : Vue.createCommentVNode("v-if", true),
            effect.value ? (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(Vue.unref(DemoComponent)), { key: 1 })) : (Vue.openBlock(), Vue.createElementBlock(
              "div",
              {
                key: 2,
                class: Vue.normalizeClass(Vue.unref(ns).b())
              },
              [
                Vue.createElementVNode(
                  "div",
                  {
                    class: Vue.normalizeClass(Vue.unref(ns).e("effect"))
                  },
                  [
                    (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(Vue.unref(DemoComponent))))
                  ],
                  2
                  /* CLASS */
                ),
                Vue.createElementVNode(
                  "div",
                  {
                    class: Vue.normalizeClass(Vue.unref(ns).e("button-group"))
                  },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-demo-code-button-left"),
                    Vue.unref(playgroundUrl) ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                      key: 0,
                      title: Vue.unref(playgroundButtonTip),
                      onClick: handleEditPlayground,
                      icon: Vue.unref(playgroundIcon),
                      role: "link",
                      "aria-label": Vue.unref(playgroundButtonTip)
                    }, null, 8, ["title", "icon", "aria-label"])) : Vue.createCommentVNode("v-if", true),
                    Vue.unref(githubUrl) ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                      key: 1,
                      title: Vue.unref(githubButtonTip),
                      onClick: handleEditGithub,
                      icon: Vue.unref(githubIcon),
                      role: "link",
                      "aria-label": Vue.unref(githubUrl)
                    }, null, 8, ["title", "icon", "aria-label"])) : Vue.createCommentVNode("v-if", true),
                    Vue.createVNode(Vue.unref(_sfc_main$1t), {
                      title: Vue.unref(copyButtonTip),
                      icon: Vue.unref(copyIcon),
                      onClick: copyCode,
                      role: "button",
                      "aria-label": Vue.unref(copyButtonTip)
                    }, null, 8, ["title", "icon", "aria-label"]),
                    Vue.createVNode(Vue.unref(_sfc_main$1t), {
                      title: sourceVisible.value ? Vue.unref(expandSourceButtonTip) : Vue.unref(collapseSourceButtonTip),
                      onClick: _cache[0] || (_cache[0] = ($event) => handleToggleSourceVisible()),
                      icon: Vue.unref(codeIcon),
                      role: "button",
                      "aria-label": sourceVisible.value ? Vue.unref(expandSourceButtonTip) : Vue.unref(collapseSourceButtonTip)
                    }, null, 8, ["title", "icon", "aria-label"]),
                    Vue.renderSlot(_ctx.$slots, "teek-demo-code-button-right")
                  ],
                  2
                  /* CLASS */
                ),
                Vue.createVNode(Vue.unref(_sfc_main$1a), null, {
                  default: Vue.withCtx(() => [
                    Vue.withDirectives(Vue.createElementVNode("div", {
                      class: Vue.normalizeClass(Vue.unref(ns).join("vp-code")),
                      innerHTML: decodeSource.value
                    }, null, 10, _hoisted_2$q), [
                      [Vue.vShow, sourceVisible.value]
                    ])
                  ]),
                  _: 1
                  /* STABLE */
                }),
                Vue.createVNode(Vue.Transition, {
                  name: Vue.unref(ns).join("fade-linear"),
                  persisted: ""
                }, {
                  default: Vue.withCtx(() => [
                    Vue.withDirectives(Vue.createElementVNode(
                      "div",
                      {
                        class: Vue.normalizeClass(Vue.unref(ns).e("float-control")),
                        onClick: _cache[1] || (_cache[1] = ($event) => handleToggleSourceVisible(false)),
                        role: "button"
                      },
                      [
                        Vue.createVNode(Vue.unref(_sfc_main$1t), { icon: Vue.unref(caretTopIcon) }, null, 8, ["icon"]),
                        Vue.createElementVNode(
                          "span",
                          null,
                          Vue.toDisplayString(Vue.unref(expandSourceButtonTip)),
                          1
                          /* TEXT */
                        )
                      ],
                      2
                      /* CLASS */
                    ), [
                      [Vue.vShow, sourceVisible.value]
                    ])
                  ]),
                  _: 1
                  /* STABLE */
                }, 8, ["name"])
              ],
              2
              /* CLASS */
            ))
          ],
          64
          /* STABLE_FRAGMENT */
        );
      };
    }
  });

  const _hoisted_1$v = ["name", "href", "title", "target", "aria-label", "aria-describedby"];
  const _hoisted_2$p = { class: "sle" };
  var _sfc_main$L = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "FooterGroup" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("footer-group");
      const { getTeekConfigRef } = useTeekConfig();
      const footerGroupConfig = getTeekConfigRef("footerGroup", []);
      return (_ctx, _cache) => {
        return Vue.unref(footerGroupConfig).length ? (Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            key: 0,
            class: Vue.normalizeClass(Vue.unref(ns).b())
          },
          [
            (Vue.openBlock(true), Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(Vue.unref(footerGroupConfig), (group, index) => {
                return Vue.openBlock(), Vue.createElementBlock("div", {
                  key: (group.title || "") + index
                }, [
                  Vue.createElementVNode(
                    "div",
                    {
                      class: Vue.normalizeClass([Vue.unref(ns).e("title"), "flx-center"])
                    },
                    [
                      group.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                        key: 0,
                        icon: group.icon,
                        style: { "margin-right": "4px" },
                        "aria-hidden": "true"
                      }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true),
                      Vue.createTextVNode(
                        " " + Vue.toDisplayString(group.title),
                        1
                        /* TEXT */
                      )
                    ],
                    2
                    /* CLASS */
                  ),
                  Vue.createElementVNode("ul", null, [
                    (Vue.openBlock(true), Vue.createElementBlock(
                      Vue.Fragment,
                      null,
                      Vue.renderList(group.links || [], (link, idx) => {
                        return Vue.openBlock(), Vue.createElementBlock(
                          "li",
                          {
                            key: (link.name || "") + idx,
                            class: Vue.normalizeClass([Vue.unref(ns).e("link")])
                          },
                          [
                            link.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                              key: 0,
                              icon: link.icon,
                              style: { "margin-right": "4px" },
                              "aria-hidden": "true"
                            }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true),
                            Vue.createElementVNode("a", {
                              name: link.name,
                              href: link.link,
                              title: link.name,
                              target: Vue.unref(isExternal)(link.link || "") ? "_blank" : "_self",
                              class: "hover-color",
                              "aria-label": link.name,
                              rel: "noopener noreferrer",
                              "aria-describedby": link.name
                            }, [
                              Vue.createElementVNode(
                                "span",
                                _hoisted_2$p,
                                Vue.toDisplayString(link.name),
                                1
                                /* TEXT */
                              ),
                              Vue.unref(isExternal)(link.link || "") ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                                key: 0,
                                icon: Vue.unref(externalLinkIcon),
                                class: Vue.normalizeClass(Vue.unref(ns).e("link__external-icon")),
                                "aria-hidden": "true"
                              }, null, 8, ["icon", "class"])) : Vue.createCommentVNode("v-if", true)
                            ], 8, _hoisted_1$v)
                          ],
                          2
                          /* CLASS */
                        );
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    ))
                  ])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          2
          /* CLASS */
        )) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  var securityRecordImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAQjSURBVHjaVNNZbFRlGIDh95w525zpdGa6TVtbykBbyiICxQY0AhYTJUCiiYqGqEEiJhKQmBg0ESPeeCGRENEYb4jhBr0gNQrRlCBiSgyLaSlSaKEs3Wemy+xnzuqFYdD/6rt6ku/N9wue55EcPwWArCgIgkx5ZRuYVxsnJ801Z05f3jY1MRnb/HxHV+uSph9RKq4mhkdwbZVgdQ2SHkPTwgj/h1QUWWi8/tfg/hM/XN/Y2zfaZnkSnuRDtLMsXhBOvrJtya/LlrcdMs1Qb1lVRQmSAEDAsU1kxpgamXp3y+azu1esreK9dyRqs9PIjkW6OsLx7lTV1ld/237s8HRV57MbnvO8CA+e9GCQFTk6Mza+4/0P+t9a9VSEI3uyTH/eR27aB2Ed31Q/Hx1sI6BHOPT13c5Frd0HW9p3HPUQEwAigJW9RDp+bstrOy981nVGLN/7RpHUV70YfXnEAtjxFPasxPDBQXatjzNTdOQXtg983H/51AFFy1KCIg2bNIdC+8270NwmUmelsXqSqHkDK5PDl8iCW0QcnEW+lqCjvcjQuMZ4YnQRTkotQUZu4GkjcfZNv19G011kXw4vayNYNvqCCvSVTciOgABgeuhBGwhgz5zbkI2ff7HUqJiNR2QktbbSYnBYYqbMT/ilKI4SIbT/GcRylbnvLmJ2X8N7tJ7rR8OE/BbliqEYea81WIotmOs02WFpc55Lf0f5/mSI3dsamOgxSX7ZjaALuBmB6M6FnB+S+POCwmOLk1QFFAqZyQWl1YrpiRZJLvDkygyC5NJ1XCax7xYNiTQVEYVIuUulayIcGeLkpw6WK7GuPY/fb2CkhleXIFFe8XPGaKBj9QxLW1Ik0bg8EuT2zRCJYZvZIYepe0EGbvi4bQUJVZhs2phADFYj+df0lBqJUnaekS4SUHXe3jrOnoE2PhSewHfRpfZGgcryIvfHdQruQlLo7Ns6QizqkJ31CIUlqwQJXuWUpDXj6qOsW32HT3YNImll9FwJsb4jyaLmWQ4fa6a+2sQw0ry8YZSiHcPxxXBtMfCv4XkUCrfliWs/fTE31rtTVfv9vsIorvQIniMhqXM4popVcJFVMHMpfMEaLPdxR1Tnna1b1vl6tGntpAjgCTNWONZyIFBR8Ydtr6EgrCI3VySfzZPLBDHyIq5gkpmzcOUmTGMF+bh7M9LYulfWzMmHBzk7Fpq9deWEYxjrtaCMXjWfstp6BCGNXZzBdYqYhogWqkMum4+oBVD0YnP63u/fFqbv1D+M7VSlBbmmK5uYaLYLYwslfwFVAyXQiOfcx3XyyGIM8DDn0lgWyGokHogu/0UJxpL/+f2e569s/CZQZ53OpzJr0+NXludUfb5jVdf7VUGXJUPIZast1S9PeII6jFDT5xMjFwO1S4c8zwTgnwEAxufYSzA67PMAAAAASUVORK5CYII=";

  const _hoisted_1$u = ["aria-label"];
  const _hoisted_2$o = ["aria-label"];
  const _hoisted_3$i = ["href", "title", "aria-label"];
  const _hoisted_4$i = { key: 1 };
  const _hoisted_5$a = ["innerHTML"];
  const _hoisted_6$7 = ["aria-label"];
  const _hoisted_7$4 = ["href", "aria-label"];
  const _hoisted_8$4 = { key: 2 };
  const _hoisted_9$4 = ["innerHTML"];
  const _hoisted_10$2 = ["innerHTML"];
  var _sfc_main$K = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "FooterInfo" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("footer-info");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const footerInfo = getTeekConfigRef("footerInfo", {});
      const social = getTeekConfigRef("social", []);
      const footerData = Vue.computed(() => {
        const { theme = {}, copyright = {}, icpRecord, securityRecord } = footerInfo.value || {};
        const data = [];
        if (theme.show !== false) {
          data.push({
            name: "Theme By Teek",
            icon: themeIcon,
            link: "https://github.com/Kele-Bingtang/vitepress-theme-teek",
            // 可覆盖上面的配置项
            ...theme
          });
        }
        const { show = true, createYear = "", suffix = "" } = copyright;
        if (show) {
          data.push({
            name: `Copyright ${createYear ? `${createYear}-` : ""}${(/* @__PURE__ */ new Date()).getFullYear()} ${suffix}`,
            icon: copyrightIcon,
            ...copyright
          });
        }
        if (icpRecord) data.push({ icon: icpRecordIcon, ...icpRecord });
        if (securityRecord) {
          data.push({ icon: securityRecordImg, iconType: "img", imgAlt: "Security Record", ...securityRecord });
        }
        return data;
      });
      return (_ctx, _cache) => {
        return Vue.unref(footerInfo) || Vue.unref(social).length ? (Vue.openBlock(), Vue.createElementBlock("div", {
          key: 0,
          class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).join("wallpaper-outside")]),
          role: "contentinfo",
          "aria-label": Vue.unref(t)("tk.footerInfo.label")
        }, [
          Vue.unref(social).length ? (Vue.openBlock(), Vue.createElementBlock("div", {
            key: 0,
            class: Vue.normalizeClass(`${Vue.unref(ns).e("icons")} flx-center`),
            role: "group",
            "aria-label": Vue.unref(t)("tk.footerInfo.socialLabel")
          }, [
            (Vue.openBlock(true), Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(Vue.unref(social), (item, index) => {
                return Vue.openBlock(), Vue.createElementBlock("a", {
                  key: index,
                  href: item.link && Vue.unref(vitepress.withBase)(item.link),
                  title: item.name,
                  target: "_blank",
                  "aria-label": item.name
                }, [
                  item.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                    key: 0,
                    iconType: item.iconType,
                    icon: item.icon,
                    size: "20px",
                    color: "var(--vp-c-text-2)",
                    hover: "",
                    imgAlt: item.imgAlt,
                    "aria-hidden": "true"
                  }, null, 8, ["iconType", "icon", "imgAlt"])) : item.name ? (Vue.openBlock(), Vue.createElementBlock(
                    "span",
                    _hoisted_4$i,
                    Vue.toDisplayString(item.name),
                    1
                    /* TEXT */
                  )) : Vue.createCommentVNode("v-if", true)
                ], 8, _hoisted_3$i);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ], 10, _hoisted_2$o)) : Vue.createCommentVNode("v-if", true),
          Vue.unref(footerInfo) ? (Vue.openBlock(), Vue.createElementBlock(
            Vue.Fragment,
            { key: 1 },
            [
              (Vue.openBlock(true), Vue.createElementBlock(
                Vue.Fragment,
                null,
                Vue.renderList([Vue.unref(footerInfo).topMessage || []].flat(), (message, index) => {
                  return Vue.openBlock(), Vue.createElementBlock("p", {
                    key: index,
                    innerHTML: message,
                    class: "flx-wrap-justify-center"
                  }, null, 8, _hoisted_5$a);
                }),
                128
                /* KEYED_FRAGMENT */
              )),
              Vue.createElementVNode("div", {
                class: Vue.normalizeClass(`${Vue.unref(ns).e("list")} flx-wrap-justify-center`),
                role: "list",
                "aria-label": Vue.unref(t)("tk.footerInfo.infoLabel")
              }, [
                (Vue.openBlock(true), Vue.createElementBlock(
                  Vue.Fragment,
                  null,
                  Vue.renderList(footerData.value, (item) => {
                    return Vue.openBlock(), Vue.createElementBlock(
                      "div",
                      {
                        key: item.name,
                        class: Vue.normalizeClass(`${Vue.unref(ns).e("list__item")} flx-align-center`),
                        role: "listitem"
                      },
                      [
                        item.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                          key: 0,
                          iconType: item.iconType,
                          icon: item.icon,
                          size: "16px",
                          color: "var(--vp-c-text-2)",
                          imgAlt: item.imgAlt,
                          "aria-hidden": "true"
                        }, null, 8, ["iconType", "icon", "imgAlt"])) : Vue.createCommentVNode("v-if", true),
                        item.link ? (Vue.openBlock(), Vue.createElementBlock("a", {
                          key: 1,
                          href: Vue.unref(vitepress.withBase)(item.link),
                          target: "_blank",
                          "aria-label": item.name
                        }, Vue.toDisplayString(item.name), 9, _hoisted_7$4)) : (Vue.openBlock(), Vue.createElementBlock(
                          "span",
                          _hoisted_8$4,
                          Vue.toDisplayString(item.name),
                          1
                          /* TEXT */
                        ))
                      ],
                      2
                      /* CLASS */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                )),
                Vue.unref(footerInfo).customHtml ? (Vue.openBlock(), Vue.createElementBlock("span", {
                  key: 0,
                  innerHTML: Vue.unref(footerInfo).customHtml
                }, null, 8, _hoisted_9$4)) : Vue.createCommentVNode("v-if", true)
              ], 10, _hoisted_6$7),
              (Vue.openBlock(true), Vue.createElementBlock(
                Vue.Fragment,
                null,
                Vue.renderList([Vue.unref(footerInfo).bottomMessage || []].flat(), (message, index) => {
                  return Vue.openBlock(), Vue.createElementBlock("p", {
                    key: index,
                    innerHTML: message,
                    class: "flx-wrap-justify-center"
                  }, null, 8, _hoisted_10$2);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ],
            64
            /* STABLE_FRAGMENT */
          )) : Vue.createCommentVNode("v-if", true)
        ], 10, _hoisted_1$u)) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  var _sfc_main$J = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeFullscreenWallpaper" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("fullscreen-wallpaper");
      const { getTeekConfigRef } = useTeekConfig();
      const isFullscreen = Vue.ref(false);
      const wallpaperConfig = getTeekConfigRef("wallpaper", {
        hideBanner: false,
        hideMask: false
      });
      const handleKeyDown = (event) => {
        if (event.key === "F12" && isFullscreen.value) return event.preventDefault();
        if (event.key === "I" && event.ctrlKey && event.shiftKey && isFullscreen.value) return event.preventDefault();
        if (event.key === "F11") {
          event.preventDefault();
          if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen();
          } else if (document.documentElement.mozRequestFullScreen) {
            document.documentElement.mozRequestFullScreen();
          } else if (document.documentElement.webkitRequestFullscreen) {
            document.documentElement.webkitRequestFullscreen();
          } else if (document.documentElement.msRequestFullscreen) {
            document.documentElement.msRequestFullscreen();
          }
        }
      };
      const handleFullscreenChange = () => {
        const htmlDom = document.documentElement;
        if (htmlDom.scrollTop !== 0) return;
        const vpDocDom = document.querySelector(".vp-doc");
        const bannerContentDom = document.querySelector(`.${ns.join("banner__content")}`);
        const wavesDom = document.querySelector(`.${ns.join("banner-waves")}`);
        const bodyBgImageMaskDom = document.querySelector(`.${ns.join("body-bg-image")} .mask`);
        const bannerMaskDom = document.querySelector(`.${ns.join("banner-bg-image")} .mask`);
        isFullscreen.value = !!document.fullscreenElement;
        const { hideBanner, hideMask } = wallpaperConfig.value;
        const options = [
          { el: htmlDom, executeClass: ns.b() },
          { el: vpDocDom, executeClass: "display-none" },
          { el: bannerContentDom, executeClass: "no-feature" },
          {
            el: bannerContentDom,
            executeClass: "display-none",
            execute: hideBanner
          },
          { el: wavesDom, executeClass: "display-none", execute: hideBanner },
          { el: bodyBgImageMaskDom, executeClass: "display-none", execute: hideMask },
          { el: bannerMaskDom, executeClass: "display-none", execute: hideMask }
        ];
        addOrRemoveClass(!!document.fullscreenElement, options);
      };
      const addOrRemoveClass = (add, options) => {
        if (add) {
          options.forEach((item) => {
            if (item.execute !== false) item.executeClass && item.el?.classList.add(item.executeClass);
            else item.notExecuteClass && item.el?.classList.add(item.notExecuteClass);
          });
          return;
        }
        options.forEach((item) => {
          if (item.execute !== false) item.executeClass && item.el?.classList.remove(item.executeClass);
          else item.notExecuteClass && item.el?.classList.remove(item.notExecuteClass);
        });
      };
      const handleContextMenu = (event) => {
        if (isFullscreen.value) event.preventDefault();
      };
      const getDocument = () => document;
      useEventListener(getDocument, "keydown", handleKeyDown);
      useEventListener(getDocument, "fullscreenchange", handleFullscreenChange);
      useEventListener(getDocument, "contextmenu", handleContextMenu);
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass(Vue.unref(ns).b())
          },
          null,
          2
          /* CLASS */
        );
      };
    }
  });

  const pageNumKey = "pageNum";

  const _hoisted_1$t = ["title", "aria-label"];
  const _hoisted_2$n = { class: "list flx" };
  const _hoisted_3$h = ["href", "aria-label"];
  const _hoisted_4$h = ["aria-label"];
  const _hoisted_5$9 = ["innerHTML"];
  const _hoisted_6$6 = ["href", "aria-label"];
  const _hoisted_7$3 = ["aria-label"];
  const _hoisted_8$3 = ["aria-label"];
  const _hoisted_9$3 = ["innerHTML"];
  const _hoisted_10$1 = ["href", "aria-label"];
  const _hoisted_11$1 = ["href", "aria-label"];
  var _sfc_main$I = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomePostItem" },
    __name: "HomePostItem",
    props: {
      post: {},
      coverImgMode: {}
    },
    setup(__props) {
      const ns = useNamespace("post-item");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const postConfig = getTeekConfigRef("post", {
        excerptPosition: "bottom",
        showMore: true,
        moreLabel: t("tk.homePost.moreLabel"),
        showCapture: false,
        splitSeparator: false,
        listStyleTitleTagPosition: "right",
        defaultCoverImg: []
      });
      const articleConfig = getTeekConfigRef("articleAnalyze", {
        showInfo: true
      });
      const postUrl = __props.post.url && vitepress.withBase(__props.post.url);
      const excerpt = Vue.computed(
        () => __props.post.frontmatter.description || __props.post.excerpt || postConfig.value.showCapture && __props.post.capture
      );
      const imgSrcList = Vue.computed(() => [__props.post.frontmatter.coverImg || postConfig.value.defaultCoverImg || []].flat());
      const coverImgMap = Vue.computed(() => {
        const imgSrc = imgSrcList.value[Math.floor(Math.random() * imgSrcList.value.length)];
        return {
          default: {
            is: "div",
            props: {
              style: `background-image: url(${vitepress.withBase(imgSrc)});`
            }
          },
          full: {
            is: "img",
            props: {
              src: vitepress.withBase(imgSrc)
            }
          }
        };
      });
      const isShowInfo = Vue.computed(() => {
        const arr = [articleConfig.value.showInfo].flat();
        return arr.includes(true) || arr.includes("post");
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass(Vue.unref(ns).b())
          },
          [
            !!__props.post.frontmatter.sticky ? (Vue.openBlock(), Vue.createElementBlock("i", {
              key: 0,
              class: "pin",
              title: Vue.unref(t)("tk.homePost.pin", { sticky: __props.post.frontmatter.sticky }),
              "aria-label": Vue.unref(t)("tk.homePost.pinLabel")
            }, null, 8, _hoisted_1$t)) : Vue.createCommentVNode("v-if", true),
            Vue.createElementVNode("div", _hoisted_2$n, [
              Vue.createElementVNode(
                "div",
                {
                  class: Vue.normalizeClass(Vue.unref(ns).e("left"))
                },
                [
                  Vue.createCommentVNode(" \u6807\u9898 "),
                  Vue.createElementVNode("a", {
                    class: Vue.normalizeClass([Vue.unref(ns).e("left__title"), "hover-color", "sle"]),
                    href: Vue.unref(postUrl),
                    "aria-label": __props.post.title
                  }, [
                    Vue.createVNode(Vue.unref(_sfc_main$17), {
                      post: __props.post,
                      "title-tag-props": { position: Vue.unref(postConfig).listStyleTitleTagPosition }
                    }, null, 8, ["post", "title-tag-props"])
                  ], 10, _hoisted_3$h),
                  Vue.createCommentVNode(" \u6458\u8981 top "),
                  excerpt.value && Vue.unref(postConfig).excerptPosition === "top" ? (Vue.openBlock(), Vue.createElementBlock("div", {
                    key: 0,
                    class: Vue.normalizeClass(`${Vue.unref(ns).e("left__excerpt")} top`),
                    "aria-label": Vue.unref(t)("tk.homePost.excerptLabel")
                  }, [
                    Vue.createElementVNode("div", {
                      class: "excerpt",
                      innerHTML: excerpt.value
                    }, null, 8, _hoisted_5$9),
                    Vue.unref(postConfig).showMore ? (Vue.openBlock(), Vue.createElementBlock("a", {
                      key: 0,
                      class: "more",
                      href: Vue.unref(postUrl),
                      "aria-label": Vue.unref(postConfig).moreLabel
                    }, Vue.toDisplayString(Vue.unref(postConfig).moreLabel), 9, _hoisted_6$6)) : Vue.createCommentVNode("v-if", true)
                  ], 10, _hoisted_4$h)) : Vue.createCommentVNode("v-if", true),
                  Vue.createCommentVNode(" \u6587\u7AE0\u4FE1\u606F "),
                  Vue.createElementVNode("div", {
                    class: Vue.normalizeClass(Vue.unref(ns).e("left__footer")),
                    "aria-label": Vue.unref(t)("tk.homePost.infoLabel")
                  }, [
                    isShowInfo.value ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$14), {
                      key: 0,
                      post: __props.post,
                      scope: "post",
                      split: Vue.unref(postConfig).splitSeparator
                    }, null, 8, ["post", "split"])) : Vue.createCommentVNode("v-if", true)
                  ], 10, _hoisted_7$3),
                  Vue.createCommentVNode(" \u6458\u8981 bottom "),
                  excerpt.value && Vue.unref(postConfig).excerptPosition === "bottom" ? (Vue.openBlock(), Vue.createElementBlock("div", {
                    key: 1,
                    class: Vue.normalizeClass(`${Vue.unref(ns).e("left__excerpt")} bottom`),
                    "aria-label": Vue.unref(t)("tk.homePost.excerptLabel")
                  }, [
                    Vue.createElementVNode("div", {
                      class: "excerpt",
                      innerHTML: excerpt.value
                    }, null, 8, _hoisted_9$3),
                    Vue.unref(postConfig).showMore ? (Vue.openBlock(), Vue.createElementBlock("a", {
                      key: 0,
                      class: "more",
                      href: Vue.unref(postUrl),
                      "aria-label": Vue.unref(postConfig).moreLabel
                    }, Vue.toDisplayString(Vue.unref(postConfig).moreLabel), 9, _hoisted_10$1)) : Vue.createCommentVNode("v-if", true)
                  ], 10, _hoisted_8$3)) : Vue.createCommentVNode("v-if", true)
                ],
                2
                /* CLASS */
              ),
              Vue.createCommentVNode(" \u53F3\u4FA7\u5C01\u9762\u56FE "),
              Vue.createElementVNode(
                "div",
                {
                  class: Vue.normalizeClass(`${Vue.unref(ns).e("right")} flx-align-center`)
                },
                [
                  imgSrcList.value.length ? (Vue.openBlock(), Vue.createElementBlock("a", {
                    key: 0,
                    href: Vue.unref(postUrl),
                    class: Vue.normalizeClass(`${__props.coverImgMode} cover`),
                    "aria-label": Vue.unref(t)("tk.homePost.coverImgLabel")
                  }, [
                    (Vue.openBlock(), Vue.createBlock(
                      Vue.resolveDynamicComponent(coverImgMap.value[__props.coverImgMode].is),
                      Vue.mergeProps(coverImgMap.value[__props.coverImgMode].props, {
                        "aria-hidden": "true",
                        class: "cover-img"
                      }),
                      null,
                      16
                      /* FULL_PROPS */
                    ))
                  ], 10, _hoisted_11$1)) : Vue.createCommentVNode("v-if", true)
                ],
                2
                /* CLASS */
              )
            ])
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const _hoisted_1$s = ["href", "alt"];
  const _hoisted_2$m = ["src"];
  const _hoisted_3$g = ["href", "aria-label"];
  const _hoisted_4$g = ["innerHTML", "aria-label"];
  var _sfc_main$H = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomePostItemCard" },
    __name: "HomePostItemCard",
    props: {
      post: {}
    },
    setup(__props) {
      const ns = useNamespace("post-item-card");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const postConfig = getTeekConfigRef("post", {
        showCapture: false,
        splitSeparator: false,
        cardStyleTitleTagPosition: "left",
        defaultCoverImg: []
      });
      const articleConfig = getTeekConfigRef("articleAnalyze", { showInfo: true });
      const postUrl = __props.post.url && vitepress.withBase(__props.post.url);
      const imgSrcList = Vue.computed(() => [__props.post.frontmatter.coverImg || postConfig.value.defaultCoverImg || []].flat());
      const excerpt = Vue.computed(
        () => __props.post.frontmatter.description || __props.post.excerpt || postConfig.value.showCapture && __props.post.capture
      );
      const isShowInfo = Vue.computed(() => {
        const arr = [articleConfig.value.showInfo].flat();
        return arr.includes(true) || arr.includes("post");
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass(Vue.unref(ns).b())
          },
          [
            !!__props.post.frontmatter.sticky ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
              key: 0,
              icon: Vue.unref(topIcon),
              class: "top",
              size: 40,
              title: Vue.unref(t)("tk.homePost.pin", { sticky: __props.post.frontmatter.sticky }),
              "aria-label": Vue.unref(t)("tk.homePost.pinLabel")
            }, null, 8, ["icon", "title", "aria-label"])) : Vue.createCommentVNode("v-if", true),
            imgSrcList.value.length ? (Vue.openBlock(), Vue.createElementBlock(
              "div",
              {
                key: 1,
                class: Vue.normalizeClass(Vue.unref(ns).e("cover-img"))
              },
              [
                Vue.createElementVNode("a", {
                  href: Vue.unref(postUrl),
                  alt: __props.post.title
                }, [
                  Vue.createElementVNode("img", {
                    src: Vue.unref(vitepress.withBase)(imgSrcList.value[0]),
                    class: "cover-img"
                  }, null, 8, _hoisted_2$m)
                ], 8, _hoisted_1$s)
              ],
              2
              /* CLASS */
            )) : Vue.createCommentVNode("v-if", true),
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass([Vue.unref(ns).e("info")])
              },
              [
                Vue.createElementVNode("a", {
                  class: "title hover-color, sle",
                  href: Vue.unref(postUrl),
                  "aria-label": __props.post.title
                }, [
                  Vue.createVNode(Vue.unref(_sfc_main$17), {
                    post: __props.post,
                    "title-tag-props": { position: Vue.unref(postConfig).cardStyleTitleTagPosition }
                  }, null, 8, ["post", "title-tag-props"])
                ], 8, _hoisted_3$g),
                excerpt.value ? (Vue.openBlock(), Vue.createElementBlock("span", {
                  key: 0,
                  class: "excerpt mle",
                  innerHTML: excerpt.value,
                  "aria-label": Vue.unref(t)("tk.homePost.excerptLabel")
                }, null, 8, _hoisted_4$g)) : Vue.createCommentVNode("v-if", true),
                isShowInfo.value ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$14), {
                  key: 1,
                  post: __props.post,
                  scope: "post",
                  split: Vue.unref(postConfig).splitSeparator,
                  "aria-label": Vue.unref(t)("tk.homePost.infoLabel")
                }, null, 8, ["post", "split", "aria-label"])) : Vue.createCommentVNode("v-if", true)
              ],
              2
              /* CLASS */
            )
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const _hoisted_1$r = ["aria-label"];
  const _hoisted_2$l = ["aria-label"];
  const targetSize = "small";
  const targetLayout = "prev, pager, next";
  var _sfc_main$G = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomePostList" },
    __name: "index",
    props: {
      "modelValue": { default: false },
      "modelModifiers": {}
    },
    emits: ["update:modelValue"],
    setup(__props, { expose: __expose }) {
      const ns = useNamespace("post-list");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const posts = usePosts();
      const { frontmatter } = vitepress.useData();
      const postConfig = getTeekConfigRef("post", {
        postStyle: "list",
        coverImgMode: "default",
        emptyLabel: t("tk.homePost.emptyLabel"),
        transition: true,
        transitionName: ns.join("slide-fade")
      });
      const pageConfig = getTeekConfigRef("page", {});
      const pageNum = Vue.ref(1);
      const total = Vue.ref(0);
      const coverImgMode = Vue.ref(postConfig.value.coverImgMode);
      const isPaging = Vue.useModel(__props, "modelValue");
      const defaultPageSize = Vue.computed(() => postConfig.value.postStyle === "list" ? 10 : 15);
      const pageSize = Vue.computed(() => pageConfig.value.pageSize || defaultPageSize.value);
      const route = vitepress.useRoute();
      const currentPosts = Vue.ref([]);
      const totalPostsCount = Vue.ref(0);
      Vue.watchEffect(() => {
        coverImgMode.value = postConfig.value.coverImgMode;
      });
      const updateData = () => {
        if (!isClient) return;
        const { searchParams } = new URL(window.location.href);
        const p = Number(searchParams.get(pageNumKey)) || 1;
        if (p !== pageNum.value) pageNum.value = p;
        isPaging.value = p > 1;
        const postConst = posts.value;
        const frontmatterConst = frontmatter.value;
        let post = postConst.sortPostsByDateAndSticky;
        if (frontmatterConst.categoriesPage) {
          const c = searchParams.get("category");
          post = c ? postConst.groupPosts.categories[c] : post.filter((item) => item.frontmatter.categories);
        } else if (frontmatterConst.tagsPage) {
          const t2 = searchParams.get("tag");
          post = t2 ? postConst.groupPosts.tags[t2] : post.filter((item) => item.frontmatter.tags);
        }
        if (total.value !== post?.length) total.value = post?.length || 0;
        const inHomePosts = post.filter((item) => item.frontmatter.inHomePost !== false);
        totalPostsCount.value = inHomePosts.length;
        currentPosts.value = inHomePosts.slice((pageNum.value - 1) * pageSize.value, pageNum.value * pageSize.value);
      };
      Vue.watch(() => route.path, updateData, { immediate: true });
      const handlePagination = () => {
        const { searchParams } = new URL(window.location.href);
        searchParams.delete(pageNumKey);
        searchParams.append(pageNumKey, String(pageNum.value));
        window.history.pushState({}, "", `${window.location.pathname}?${searchParams.toString()}`);
        updateData();
        Vue.nextTick(() => {
          const rootStyles = getComputedStyle(document.documentElement);
          const navHeight = removeUnit(rootStyles.getPropertyValue("--vp-c-text-1"));
          document.querySelector("html")?.scrollTo({ top: window.innerHeight - navHeight, behavior: "smooth" });
        });
      };
      const pagePropsRef = Vue.reactive({ ...pageConfig.value });
      const { size = "default", layout = "prev, pager, next, jumper, ->, total" } = pageConfig.value;
      useWindowSize((width) => {
        if (width <= 768) {
          if (pagePropsRef.size !== targetSize) pagePropsRef.size = targetSize;
        } else if (pagePropsRef.size !== size) pagePropsRef.size = size;
        if (width <= 960) {
          if (pagePropsRef.layout !== targetLayout) pagePropsRef.layout = targetLayout;
        } else if (pagePropsRef.layout !== layout) pagePropsRef.layout = layout;
        if (width <= 960) {
          if (coverImgMode.value !== "default") coverImgMode.value = "default";
        } else if (coverImgMode.value !== postConfig.value.coverImgMode) coverImgMode.value = postConfig.value.coverImgMode;
      });
      const windowTransition = useWindowTransitionConfig((config) => config.post);
      const postItemListInstance = Vue.ref(null);
      const { start } = useWindowTransition(postItemListInstance, false);
      Vue.onMounted(() => {
        windowTransition.value && start();
      });
      __expose({ updateData });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("card", Vue.unref(postConfig).postStyle === "card")])
          },
          [
            currentPosts.value ? (Vue.openBlock(), Vue.createElementBlock(
              Vue.Fragment,
              { key: 0 },
              [
                Vue.renderSlot(_ctx.$slots, "teek-home-post-list", Vue.normalizeProps(Vue.guardReactiveProps({ currentPosts: currentPosts.value, transitionName: Vue.unref(postConfig).transitionName })), () => [
                  Vue.createVNode(Vue.TransitionGroup, {
                    tag: "ul",
                    name: Vue.unref(postConfig).transition ? Vue.unref(postConfig).transitionName : "",
                    "aria-label": Vue.unref(t)("tk.homePost.label")
                  }, {
                    default: Vue.withCtx(() => [
                      (Vue.openBlock(true), Vue.createElementBlock(
                        Vue.Fragment,
                        null,
                        Vue.renderList(currentPosts.value, (post) => {
                          return Vue.openBlock(), Vue.createElementBlock(
                            "li",
                            {
                              key: post.url,
                              class: Vue.normalizeClass({ "full-img": coverImgMode.value === "full" })
                            },
                            [
                              Vue.unref(windowTransition) ? (Vue.openBlock(), Vue.createElementBlock(
                                "div",
                                {
                                  key: 0,
                                  ref_for: true,
                                  ref_key: "postItemListInstance",
                                  ref: postItemListInstance,
                                  style: { "width": "100%", "height": "100%" }
                                },
                                [
                                  Vue.unref(postConfig).postStyle === "card" ? (Vue.openBlock(), Vue.createBlock(_sfc_main$H, {
                                    key: 0,
                                    post
                                  }, null, 8, ["post"])) : (Vue.openBlock(), Vue.createBlock(_sfc_main$I, {
                                    key: 1,
                                    post,
                                    coverImgMode: coverImgMode.value
                                  }, null, 8, ["post", "coverImgMode"]))
                                ],
                                512
                                /* NEED_PATCH */
                              )) : (Vue.openBlock(), Vue.createElementBlock(
                                Vue.Fragment,
                                { key: 1 },
                                [
                                  Vue.unref(postConfig).postStyle === "card" ? (Vue.openBlock(), Vue.createBlock(_sfc_main$H, {
                                    key: 0,
                                    post
                                  }, null, 8, ["post"])) : (Vue.openBlock(), Vue.createBlock(_sfc_main$I, {
                                    key: 1,
                                    post,
                                    coverImgMode: coverImgMode.value
                                  }, null, 8, ["post", "coverImgMode"]))
                                ],
                                64
                                /* STABLE_FRAGMENT */
                              ))
                            ],
                            2
                            /* CLASS */
                          );
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      ))
                    ]),
                    _: 1
                    /* STABLE */
                  }, 8, ["name", "aria-label"])
                ]),
                Vue.createElementVNode("div", {
                  class: Vue.normalizeClass(`${Vue.unref(ns).e("pagination")} flx-justify-center`),
                  "aria-label": Vue.unref(t)("tk.homePost.pageLabel")
                }, [
                  totalPostsCount.value >= pageSize.value ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1f), Vue.mergeProps({
                    key: 0,
                    "page-size": pageSize.value,
                    "onUpdate:pageSize": _cache[0] || (_cache[0] = ($event) => pageSize.value = $event),
                    "current-page": pageNum.value,
                    "onUpdate:currentPage": _cache[1] || (_cache[1] = ($event) => pageNum.value = $event),
                    total: total.value,
                    background: "",
                    onCurrentChange: handlePagination
                  }, { ...pagePropsRef }), null, 16, ["page-size", "current-page", "total"])) : Vue.createCommentVNode("v-if", true)
                ], 10, _hoisted_1$r)
              ],
              64
              /* STABLE_FRAGMENT */
            )) : (Vue.openBlock(), Vue.createElementBlock("div", {
              key: 1,
              class: Vue.normalizeClass([Vue.unref(ns).e("empty"), "flx-column-center"]),
              "aria-label": Vue.unref(postConfig).emptyLabel
            }, [
              Vue.createVNode(Vue.unref(_sfc_main$1t), {
                icon: Vue.unref(emptyIcon),
                size: 160,
                color: "var(--vp-c-text-3)",
                "aria-hidden": "true"
              }, null, 8, ["icon"]),
              Vue.createElementVNode(
                "span",
                {
                  class: Vue.normalizeClass(Vue.unref(ns).e("empty__title"))
                },
                Vue.toDisplayString(Vue.unref(postConfig).emptyLabel),
                3
                /* TEXT, CLASS */
              )
            ], 10, _hoisted_2$l))
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const _hoisted_1$q = ["aria-label"];
  var _sfc_main$F = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeBannerBgPure" },
    __name: "HomeBannerBgPure",
    setup(__props) {
      const ns = useNamespace("banner-bg-pure");
      const { t } = useLocale();
      const { getTeekConfig } = useTeekConfig();
      const getStyle = () => {
        const { pureBgColor = "#28282d" } = getTeekConfig("banner", {});
        return { backgroundColor: pureBgColor };
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(Vue.unref(ns).b()),
          style: Vue.normalizeStyle(getStyle()),
          "aria-label": Vue.unref(t)("tk.homeBanner.bgPureLabel")
        }, [
          Vue.renderSlot(_ctx.$slots, "default")
        ], 14, _hoisted_1$q);
      };
    }
  });

  const _hoisted_1$p = ["aria-label"];
  const _hoisted_2$k = ["aria-label"];
  var _sfc_main$E = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeBannerBgImage" },
    __name: "HomeBannerBgImage",
    setup(__props) {
      const ns = useNamespace("banner-bg-image");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const bannerConfig = getTeekConfigRef("banner", {
        bgStyle: void 0,
        imgSrc: void 0,
        imgInterval: 15e3,
        imgShuffle: false,
        mask: true,
        maskBg: "rgba(0, 0, 0, 0.4)"
      });
      const isPartImgBgStyle = Vue.computed(() => bannerConfig.value.bgStyle === "partImg");
      const isFullImgBgStyle = Vue.computed(() => bannerConfig.value.bgStyle === "fullImg");
      const dataArray = Vue.computed(() => {
        const imgSrc = bannerConfig.value.imgSrc;
        return [isFunction(imgSrc) ? imgSrc() : imgSrc || []].flat().map((item) => item && vitepress.withBase(item));
      });
      const {
        data: imageSrc,
        start,
        index
      } = useSwitchData(dataArray, {
        timeout: bannerConfig.value.imgInterval,
        shuffle: bannerConfig.value.imgShuffle,
        onAfterUpdate: () => {
          const nextIndex = (index.value + 1) % dataArray.value.length;
          const newValue = dataArray.value[nextIndex];
          if (newValue) {
            const img = new Image();
            img.src = newValue;
          }
        }
      });
      Vue.onMounted(() => {
        start();
      });
      const getStyle = () => {
        const { imgSrc, maskBg, imgInterval } = bannerConfig.value;
        const imgBgVar = ns.cssVarName("banner-img-bg");
        const maskBgColorVar = ns.cssVarName("banner-mask-bg-color");
        const imgSwitchIntervalVar = ns.cssVarName("banner-img-switch-interval-s");
        if (!imgSrc?.length) return { [imgBgVar]: ns.cssVar("bg-img-default") };
        return {
          [imgBgVar]: `url(${imageSrc.value}) center center / cover no-repeat`,
          [maskBgColorVar]: isString$1(maskBg) ? maskBg : `rgba(0, 0, 0, ${maskBg})`,
          [imgSwitchIntervalVar]: imgInterval / 1e3 + "s"
        };
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          Vue.Fragment,
          null,
          [
            Vue.createElementVNode("div", {
              class: Vue.normalizeClass([Vue.unref(ns).b(), { part: isPartImgBgStyle.value, full: isFullImgBgStyle.value }]),
              style: Vue.normalizeStyle(getStyle()),
              "aria-label": Vue.unref(t)("tk.homeBanner.bgImgLabel")
            }, [
              Vue.unref(bannerConfig).mask && Vue.unref(bannerConfig).imgSrc ? (Vue.openBlock(), Vue.createElementBlock("div", {
                key: 0,
                class: "mask",
                "aria-label": Vue.unref(t)("tk.homeBanner.maskLabel")
              }, null, 8, _hoisted_2$k)) : Vue.createCommentVNode("v-if", true),
              isPartImgBgStyle.value ? Vue.renderSlot(_ctx.$slots, "default", { key: 1 }) : Vue.createCommentVNode("v-if", true)
            ], 14, _hoisted_1$p),
            isFullImgBgStyle.value ? Vue.renderSlot(_ctx.$slots, "default", { key: 0 }) : Vue.createCommentVNode("v-if", true)
          ],
          64
          /* STABLE_FRAGMENT */
        );
      };
    }
  });

  const _hoisted_1$o = ["aria-label"];
  const _hoisted_2$j = ["aria-label"];
  const _hoisted_3$f = ["aria-label"];
  const _hoisted_4$f = { key: 0 };
  const _hoisted_5$8 = ["aria-label"];
  const _hoisted_6$5 = ["aria-label"];
  var _sfc_main$D = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeBannerContent" },
    __name: "HomeBannerContent",
    setup(__props) {
      const ns = useNamespace("banner-content");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const { site, frontmatter } = vitepress.useData();
      const bannerConfig = getTeekConfigRef("banner", {
        name: frontmatter.value.tk?.name || site.value.title || "",
        descStyle: "default",
        description: [],
        switchTime: 4e3,
        switchShuffle: false,
        typesInTime: 200,
        typesOutTime: 100,
        typesNextTime: 800,
        typesShuffle: false
      });
      const descArray = Vue.computed(() => [
        ...new Set(
          [frontmatter.value.tk?.description || bannerConfig.value.description || []].flat()?.filter((v) => !!v)
        )
      ]);
      const isDefaultDescStyle = Vue.computed(() => bannerConfig.value.descStyle === "default");
      const isTypesDescStyle = Vue.computed(() => bannerConfig.value.descStyle === "types");
      const isSwitchDescStyle = Vue.computed(() => bannerConfig.value.descStyle === "switch");
      const {
        text: typesText,
        isFinished,
        start: startTypes
      } = useTextTypes(descArray, {
        inputTime: bannerConfig.value.typesInTime,
        outputTime: bannerConfig.value.typesOutTime,
        nextTime: bannerConfig.value.typesNextTime,
        shuffle: bannerConfig.value.typesShuffle
      });
      const { data: text, start: startAutoSwitch } = useSwitchData(descArray, {
        timeout: bannerConfig.value.switchTime,
        shuffle: bannerConfig.value.switchShuffle,
        onUpdate: (data, newValue) => {
          data.value = "";
          setTimeout(() => {
            data.value = newValue;
          }, 20);
        }
      });
      Vue.onMounted(() => {
        if (isTypesDescStyle.value) startTypes();
        if (isSwitchDescStyle.value) startAutoSwitch();
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(Vue.unref(ns).b()),
          "aria-label": Vue.unref(t)("tk.homeBanner.contentLabel")
        }, [
          Vue.createCommentVNode(" \u9996\u9875 banner \u56FE\u6587\u5B57\u63D2\u69FD "),
          _ctx.$slots["teek-home-banner-name"] ? Vue.renderSlot(_ctx.$slots, "teek-home-banner-name", Vue.normalizeProps(Vue.mergeProps({ key: 0 }, { name: Vue.unref(bannerConfig).name }))) : (Vue.openBlock(), Vue.createElementBlock(
            Vue.Fragment,
            { key: 1 },
            [
              Vue.createCommentVNode(" \u5982\u679C\u6CA1\u6709\u4F20\u5165\u63D2\u69FD\uFF0C\u5219\u6E32\u67D3\u9ED8\u8BA4\u7684 h1 \u6807\u7B7E\u53CA\u5185\u5BB9 "),
              Vue.createElementVNode("h1", {
                class: Vue.normalizeClass(Vue.unref(ns).e("title")),
                "aria-label": Vue.unref(t)("tk.homeBanner.titleLabel")
              }, Vue.toDisplayString(Vue.unref(bannerConfig).name), 11, _hoisted_2$j)
            ],
            2112
            /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )),
          Vue.createElementVNode("p", {
            class: Vue.normalizeClass(Vue.unref(ns).e("desc")),
            "aria-label": Vue.unref(t)("tk.homeBanner.descLabel")
          }, [
            isDefaultDescStyle.value ? (Vue.openBlock(), Vue.createElementBlock(
              "span",
              _hoisted_4$f,
              Vue.toDisplayString(descArray.value[0]),
              1
              /* TEXT */
            )) : isSwitchDescStyle.value ? (Vue.openBlock(), Vue.createBlock(Vue.Transition, {
              key: 1,
              name: Vue.unref(ns).join("fade"),
              mode: "out-in"
            }, {
              default: Vue.withCtx(() => [
                (Vue.openBlock(), Vue.createElementBlock("span", {
                  key: Vue.unref(text) || descArray.value[0],
                  onClick: _cache[0] || (_cache[0] = //@ts-ignore
                  (...args) => Vue.unref(startAutoSwitch) && Vue.unref(startAutoSwitch)(...args)),
                  class: "switch",
                  "aria-label": Vue.unref(t)("tk.homeBanner.descSwitchLabel")
                }, Vue.toDisplayString(Vue.unref(text) || descArray.value[0]), 9, _hoisted_5$8))
              ]),
              _: 1
              /* STABLE */
            }, 8, ["name"])) : isTypesDescStyle.value && descArray.value.length ? (Vue.openBlock(), Vue.createElementBlock(
              Vue.Fragment,
              { key: 2 },
              [
                Vue.createElementVNode("span", {
                  "aria-label": Vue.unref(t)("tk.homeBanner.descTypedLabel")
                }, Vue.toDisplayString(Vue.unref(typesText)), 9, _hoisted_6$5),
                Vue.createElementVNode(
                  "span",
                  {
                    class: Vue.normalizeClass(["typed", { "is-animation": Vue.unref(isFinished) }])
                  },
                  "|",
                  2
                  /* CLASS */
                )
              ],
              64
              /* STABLE_FRAGMENT */
            )) : Vue.createCommentVNode("v-if", true)
          ], 10, _hoisted_3$f)
        ], 10, _hoisted_1$o);
      };
    }
  });

  const _hoisted_1$n = ["aria-labelledby"];
  const _hoisted_2$i = ["src", "alt", "aria-label"];
  const _hoisted_3$e = ["id"];
  const _hoisted_4$e = { class: "feature-details" };
  var _sfc_main$C = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeBannerFeature" },
    __name: "HomeBannerFeature",
    setup(__props) {
      const ns = useNamespace("banner-feature");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const { frontmatter } = vitepress.useData();
      const bannerConfig = getTeekConfigRef("banner", {
        features: frontmatter.value.tk?.features || [],
        featureCarousel: 4e3
      });
      const featuresConfig = getTeekConfigRef("features", []);
      const active = Vue.ref(0);
      const isMobile = Vue.ref(false);
      let timer;
      const features = Vue.computed(() => bannerConfig.value.features || featuresConfig.value || []);
      const clearTimer = () => {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      };
      useWindowSize((width) => {
        const { featureCarousel } = bannerConfig.value;
        if (width <= 719) {
          isMobile.value = true;
          clearTimer();
          timer = setInterval(() => {
            active.value = (active.value + 1) % features.value.length;
          }, featureCarousel);
        } else {
          isMobile.value = false;
          clearTimer();
        }
      });
      Vue.onBeforeUnmount(() => {
        clearTimer();
      });
      return (_ctx, _cache) => {
        return features.value.length ? (Vue.openBlock(), Vue.createBlock(Vue.TransitionGroup, {
          key: 0,
          name: Vue.unref(ns).join("slide-next"),
          tag: "div",
          class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).join("wallpaper-outside"), "flx-wrap-between"]),
          "aria-label": Vue.unref(t)("tk.homeBanner.featureLabel")
        }, {
          default: Vue.withCtx(() => [
            (Vue.openBlock(true), Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(Vue.unref(bannerConfig).features, (feature, index) => {
                return Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("div", {
                  class: Vue.normalizeClass(Vue.unref(ns).e("feature__item")),
                  key: index,
                  role: "group",
                  "aria-labelledby": `feature-title-${index}`
                }, [
                  (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(feature.link ? "a" : "div"), {
                    href: Vue.unref(vitepress.withBase)(feature.link ?? ""),
                    class: "flx-column-center hover-color",
                    "aria-label": feature.title
                  }, {
                    default: Vue.withCtx(() => [
                      feature.image ? (Vue.openBlock(), Vue.createElementBlock("img", {
                        key: 0,
                        class: "feature-img",
                        src: Vue.unref(vitepress.withBase)(feature.image),
                        alt: feature.title,
                        "aria-label": feature.title
                      }, null, 8, _hoisted_2$i)) : Vue.createCommentVNode("v-if", true),
                      Vue.createElementVNode("p", {
                        id: `feature-title-${index}`,
                        class: "feature-title"
                      }, Vue.toDisplayString(feature.title), 9, _hoisted_3$e),
                      Vue.createElementVNode(
                        "p",
                        _hoisted_4$e,
                        Vue.toDisplayString(feature.details),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, 1032, ["href", "aria-label"]))
                ], 10, _hoisted_1$n)), [
                  [Vue.vShow, !isMobile.value || active.value === index]
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["name", "class", "aria-label"])) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  var _sfc_main$B = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeBannerWaves" },
    __name: "HomeBannerWaves",
    setup(__props) {
      const ns = useNamespace("banner-waves");
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "svg",
          {
            class: Vue.normalizeClass(Vue.unref(ns).b()),
            xmlns: "http://www.w3.org/2000/svg",
            "xmlns:xlink": "http://www.w3.org/1999/xlink",
            viewBox: "0 24 150 28",
            preserveAspectRatio: "none",
            "shape-rendering": "auto"
          },
          [
            Vue.createCommentVNode("\u5F62\u72B6\u5BB9\u5668"),
            _cache[0] || (_cache[0] = Vue.createElementVNode(
              "defs",
              null,
              [
                Vue.createElementVNode("path", {
                  id: "gentle-wave",
                  d: "M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"
                })
              ],
              -1
              /* CACHED */
            )),
            Vue.createCommentVNode("\u7EC4\u5408\u6CE2\u6D6A"),
            _cache[1] || (_cache[1] = Vue.createStaticVNode('<g class="parallax"><use class="use" xlink:href="#gentle-wave" x="48" y="0"></use><use class="use dark:fill-black" xlink:href="#gentle-wave" x="48" y="3"></use><use class="use dark:fill-black" xlink:href="#gentle-wave" x="48" y="5"></use><use class="use dark:fill-black" xlink:href="#gentle-wave" x="48" y="7"></use></g>', 1))
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const _hoisted_1$m = ["aria-label"];
  const fullImgNavBarKey = "full-img-nav-bar";
  var _sfc_main$A = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeBanner" },
    __name: "index",
    props: {
      disabled: { type: Boolean, default: false }
    },
    setup(__props) {
      const ns = useNamespace("banner");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const { frontmatter } = vitepress.useData();
      const bannerConfig = getTeekConfigRef("banner", {
        bgStyle: "pure",
        imgWaves: true,
        textColor: "#ffffff",
        titleFontSize: "3.2rem",
        descFontSize: "1.4rem",
        features: frontmatter.value.tk?.features || []
      });
      const bodyBgImgConfig = getTeekConfigRef("bodyBgImg", {
        imgSrc: "",
        bannerStyle: "full"
      });
      const currentBgStyle = Vue.computed(() => {
        const { bgStyle } = bannerConfig.value;
        const { imgSrc, bannerStyle } = bodyBgImgConfig.value;
        const isBannerPureBgStyle = bgStyle === "pure";
        const isBannerPartImgBgStyle = bgStyle === "partImg";
        const isBannerFullImgBgStyle = bgStyle === "fullImg";
        const isBodyImgBgStyle = !!imgSrc;
        const isBodyPartImgBgStyle = isBodyImgBgStyle && bannerStyle === "part";
        const isBodyFullImgBgStyle = isBodyImgBgStyle && bannerStyle === "full";
        return {
          isBannerPureBgStyle,
          isBannerPartImgBgStyle,
          isBannerFullImgBgStyle,
          isBodyImgBgStyle,
          isBodyPartImgBgStyle,
          isBodyFullImgBgStyle
        };
      });
      const getStyle = () => {
        const titleTextVar = ns.cssVarName("banner-title-text");
        const descTextVar = ns.cssVarName("banner-desc-text");
        const textColorVar = ns.cssVarName("banner-text-color");
        const { titleFontSize, descFontSize, textColor } = bannerConfig.value;
        return { [titleTextVar]: titleFontSize, [descTextVar]: descFontSize, [textColorVar]: textColor };
      };
      const bannerRef = Vue.ref(null);
      const toggleFullImgNavBarClass = (add = true) => {
        const vPNavDom = document.querySelector(".VPNavBar");
        if (add) vPNavDom?.classList.add(fullImgNavBarKey);
        else vPNavDom?.classList.remove(fullImgNavBarKey);
      };
      const toggleClass = async () => {
        if (!bannerRef.value || __props.disabled) return;
        const current = currentBgStyle.value;
        if (!current.isBannerFullImgBgStyle && !current.isBodyFullImgBgStyle) return;
        await Vue.nextTick();
        const offset = current.isBodyImgBgStyle ? 0 : 100;
        const windowInBanner = document.documentElement.scrollTop + offset < document.documentElement.clientHeight;
        toggleFullImgNavBarClass(windowInBanner);
      };
      Vue.watch(
        () => __props.disabled,
        () => toggleFullImgNavBarClass(!__props.disabled)
      );
      Vue.onMounted(() => {
        if (!__props.disabled && currentBgStyle.value.isBannerFullImgBgStyle || currentBgStyle.value.isBodyFullImgBgStyle) {
          toggleClass();
          useEventListener(window, "scroll", toggleClass);
        }
      });
      Vue.onUnmounted(() => {
        toggleFullImgNavBarClass(false);
      });
      const className = Vue.computed(() => {
        const {
          isBannerPureBgStyle,
          isBannerPartImgBgStyle,
          isBannerFullImgBgStyle,
          isBodyPartImgBgStyle,
          isBodyFullImgBgStyle
        } = currentBgStyle.value;
        if (isBodyPartImgBgStyle) return ns.is("part-img");
        if (isBodyFullImgBgStyle) return ns.is("full-img");
        if (isBannerPureBgStyle) return ns.is("pure");
        if (isBannerPartImgBgStyle) return ns.is("part-img");
        if (isBannerFullImgBgStyle) return ns.is("full-img");
        return "";
      });
      const styleComponentMap = {
        bodyPart: { el: "div", props: { class: `body-pure` } },
        bodyFull: { el: "div", props: { class: `body-full` } },
        bannerPure: { el: _sfc_main$F },
        bannerPartImg: { el: _sfc_main$E },
        bannerFullImg: { el: _sfc_main$E }
      };
      const styleComponent = Vue.computed(() => {
        const { isBodyImgBgStyle } = currentBgStyle.value;
        const { bgStyle } = bannerConfig.value;
        const { bannerStyle } = bodyBgImgConfig.value;
        const currentStyle = isBodyImgBgStyle ? `body${upperFirst(bannerStyle)}` : `banner${upperFirst(bgStyle)}`;
        return styleComponentMap[currentStyle];
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          Vue.Fragment,
          null,
          [
            Vue.renderSlot(_ctx.$slots, "teek-home-banner-before"),
            Vue.createElementVNode("div", {
              ref_key: "bannerRef",
              ref: bannerRef,
              class: Vue.normalizeClass([Vue.unref(ns).b(), className.value]),
              style: Vue.normalizeStyle(getStyle()),
              "aria-label": Vue.unref(t)("tk.homeBanner.label")
            }, [
              (Vue.openBlock(), Vue.createBlock(
                Vue.resolveDynamicComponent(styleComponent.value.el),
                Vue.normalizeProps(Vue.guardReactiveProps(styleComponent.value.props)),
                {
                  default: Vue.withCtx(() => [
                    Vue.createElementVNode(
                      "div",
                      {
                        class: Vue.normalizeClass([Vue.unref(ns).e("content"), { "no-feature": !Vue.unref(bannerConfig).features.length }])
                      },
                      [
                        Vue.renderSlot(_ctx.$slots, "teek-home-banner-content-before"),
                        Vue.createVNode(
                          _sfc_main$D,
                          null,
                          Vue.createSlots({
                            _: 2
                            /* DYNAMIC */
                          }, [
                            Vue.renderList(_ctx.$slots, (_, name) => {
                              return {
                                name,
                                fn: Vue.withCtx((scope) => [
                                  Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(scope)))
                                ])
                              };
                            })
                          ]),
                          1024
                          /* DYNAMIC_SLOTS */
                        ),
                        Vue.renderSlot(_ctx.$slots, "teek-home-banner-content-after"),
                        Vue.renderSlot(_ctx.$slots, "teek-home-banner-feature-before"),
                        Vue.createVNode(_sfc_main$C),
                        Vue.renderSlot(_ctx.$slots, "teek-home-banner-feature-after")
                      ],
                      2
                      /* CLASS */
                    )
                  ]),
                  _: 3
                  /* FORWARDED */
                },
                16
                /* FULL_PROPS */
              )),
              Vue.unref(bannerConfig).imgWaves && currentBgStyle.value.isBannerFullImgBgStyle && !currentBgStyle.value.isBodyImgBgStyle ? (Vue.openBlock(), Vue.createBlock(_sfc_main$B, {
                key: 0,
                "aria-label": Vue.unref(t)("tk.homeBanner.wavesLabel")
              }, null, 8, ["aria-label"])) : Vue.createCommentVNode("v-if", true)
            ], 14, _hoisted_1$m),
            Vue.renderSlot(_ctx.$slots, "teek-home-banner-after")
          ],
          64
          /* STABLE_FRAGMENT */
        );
      };
    }
  });

  const _hoisted_1$l = ["aria-label"];
  const _hoisted_2$h = ["href", "target", "aria-label"];
  const _hoisted_3$d = ["innerHTML"];
  const _hoisted_4$d = ["aria-label"];
  const _hoisted_5$7 = ["innerHTML"];
  const _hoisted_6$4 = ["innerHTML"];
  const _hoisted_7$2 = { key: 0 };
  const _hoisted_8$2 = ["aria-label", "aria-disabled"];
  const _hoisted_9$2 = ["aria-label", "aria-disabled"];
  var _sfc_main$z = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "PageCard" },
    __name: "index",
    props: /* @__PURE__ */ Vue.mergeModels({
      title: { default: "" },
      titleLink: {},
      titleClick: { type: Function },
      page: { type: Boolean, default: false },
      pageSize: { default: 4 },
      total: { default: 0 },
      autoPage: { type: Boolean, default: false },
      pageSpeed: { default: 4e3 }
    }, {
      "modelValue": { default: 1 },
      "modelModifiers": {}
    }),
    emits: /* @__PURE__ */ Vue.mergeModels(["pagination"], ["update:modelValue"]),
    setup(__props, { emit: __emit }) {
      const ns = useNamespace("page-card");
      const pointClass = ns.join("pointer");
      const { t } = useLocale();
      const emit = __emit;
      const pageNum = Vue.useModel(__props, "modelValue");
      const pageTotalNum = Math.ceil(__props.total / __props.pageSize);
      const hasNextData = __props.total !== 0 && pageTotalNum !== 1;
      const transitionName = Vue.ref(ns.join("scroll"));
      const pagination = (to, type) => {
        emit("pagination", to, type);
        transitionName.value = ns.join(`slide-${type}`);
        if (__props.page && __props.autoPage) startAutoPage();
        const index = pageNum.value % pageTotalNum;
        const res = (index + to) % pageTotalNum;
        if (res < 1) pageNum.value = pageTotalNum + res;
        else if (res > pageTotalNum) pageNum.value = 1;
        else pageNum.value = res;
      };
      let timer;
      const startAutoPage = () => {
        closeAutoPage();
        if (__props.pageSpeed > 0) {
          timer = setTimeout(() => {
            pagination(1, "next");
          }, __props.pageSpeed);
        }
      };
      const closeAutoPage = () => {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      };
      Vue.onMounted(() => {
        if (__props.page && __props.autoPage) startAutoPage();
      });
      Vue.onUnmounted(() => {
        if (__props.page && __props.autoPage) closeAutoPage();
      });
      const removeHtmlTag = (str) => {
        return str.replace(/<[^>]*>/g, "").trim();
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(`${Vue.unref(ns).b()} card`),
          "aria-label": Vue.unref(t)("tk.pageCard.label")
        }, [
          __props.title ? (Vue.openBlock(), Vue.createElementBlock(
            "div",
            {
              key: 0,
              class: Vue.normalizeClass(`${Vue.unref(ns).e("header")} flx-justify-between`)
            },
            [
              Vue.renderSlot(_ctx.$slots, "title", {}, () => [
                __props.titleLink ? (Vue.openBlock(), Vue.createElementBlock("a", {
                  key: 0,
                  href: Vue.unref(vitepress.withBase)(__props.titleLink),
                  target: Vue.unref(isValidURL)(__props.titleLink) ? "_blank" : "_self",
                  "aria-label": removeHtmlTag(__props.title)
                }, [
                  Vue.createElementVNode("span", {
                    class: "title flx-align-center",
                    innerHTML: __props.title
                  }, null, 8, _hoisted_3$d)
                ], 8, _hoisted_2$h)) : __props.titleClick ? (Vue.openBlock(), Vue.createElementBlock("a", {
                  key: 1,
                  onClick: _cache[0] || (_cache[0] = () => __props.titleClick()),
                  class: Vue.normalizeClass(Vue.unref(pointClass)),
                  "aria-label": removeHtmlTag(__props.title)
                }, [
                  Vue.createElementVNode("span", {
                    class: "title flx-align-center",
                    innerHTML: __props.title
                  }, null, 8, _hoisted_5$7)
                ], 10, _hoisted_4$d)) : (Vue.openBlock(), Vue.createElementBlock("span", {
                  key: 2,
                  class: "title flx-align-center",
                  innerHTML: __props.title
                }, null, 8, _hoisted_6$4))
              ]),
              Vue.renderSlot(_ctx.$slots, "page", Vue.normalizeProps(Vue.guardReactiveProps({ pagination })), () => [
                __props.page ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_7$2, [
                  Vue.renderSlot(_ctx.$slots, "page-left", Vue.normalizeProps(Vue.guardReactiveProps({ pagination })), () => [
                    Vue.createElementVNode("span", {
                      class: Vue.normalizeClass(["page-button", Vue.unref(hasNextData) ? Vue.unref(pointClass) : "disabled"]),
                      onClick: _cache[1] || (_cache[1] = ($event) => pagination(-1, "prev")),
                      role: "button",
                      "aria-label": Vue.unref(t)("tk.pageCard.prev"),
                      "aria-disabled": !Vue.unref(hasNextData)
                    }, [
                      Vue.createVNode(Vue.unref(_sfc_main$1t), {
                        icon: Vue.unref(arrowLeftIcon),
                        size: 14,
                        "aria-hidden": "true"
                      }, null, 8, ["icon"])
                    ], 10, _hoisted_8$2)
                  ]),
                  Vue.renderSlot(_ctx.$slots, "page-right", Vue.normalizeProps(Vue.guardReactiveProps({ pagination })), () => [
                    Vue.createElementVNode("span", {
                      class: Vue.normalizeClass(["page-button", Vue.unref(hasNextData) ? Vue.unref(pointClass) : "disabled"]),
                      onClick: _cache[2] || (_cache[2] = ($event) => pagination(1, "next")),
                      role: "button",
                      "aria-label": Vue.unref(t)("tk.pageCard.next"),
                      "aria-disabled": !Vue.unref(hasNextData)
                    }, [
                      Vue.createVNode(Vue.unref(_sfc_main$1t), {
                        icon: Vue.unref(arrowRightIcon),
                        size: 14,
                        "aria-hidden": "true"
                      }, null, 8, ["icon"])
                    ], 10, _hoisted_9$2)
                  ])
                ])) : Vue.createCommentVNode("v-if", true)
              ])
            ],
            2
            /* CLASS */
          )) : Vue.createCommentVNode("v-if", true),
          Vue.renderSlot(_ctx.$slots, "default", Vue.normalizeProps(Vue.guardReactiveProps({ transitionName: transitionName.value, startAutoPage, closeAutoPage })))
        ], 10, _hoisted_1$l);
      };
    }
  });

  const _hoisted_1$k = ["aria-label"];
  const _hoisted_2$g = ["href", "title", "aria-label"];
  const _hoisted_3$c = ["aria-label"];
  const _hoisted_4$c = { class: "name" };
  const _hoisted_5$6 = { class: "slogan" };
  var _sfc_main$y = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeMyCard" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("my");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const bloggerConfig = getTeekConfigRef("blogger", { shape: "square", circleBgMask: true });
      const socialConfig = getTeekConfigRef("social", []);
      const shape = Vue.computed(() => bloggerConfig.value.shape.replace(/-.*$/, ""));
      const isCircleBgImg = Vue.computed(() => shape.value === "circle" && !!bloggerConfig.value.circleBgImg);
      const avatarBgStyle = Vue.computed(() => ({ backgroundImage: `url(${vitepress.withBase(bloggerConfig.value.circleBgImg)})` }));
      const myCardColorStyle = Vue.computed(() => ({ color: bloggerConfig.value.color }));
      const isSrc = Vue.computed(() => {
        const icon = bloggerConfig.value.status?.icon;
        if (!icon) return false;
        return isValidURL(icon) || icon.startsWith("/");
      });
      return (_ctx, _cache) => {
        return Vue.unref(bloggerConfig).name ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$z), {
          key: 0,
          class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("circle-bg", isCircleBgImg.value)]),
          style: Vue.normalizeStyle(myCardColorStyle.value),
          "aria-label": Vue.unref(t)("tk.myCard.label")
        }, {
          default: Vue.withCtx(() => [
            isCircleBgImg.value ? (Vue.openBlock(), Vue.createElementBlock(
              "div",
              {
                key: 0,
                class: Vue.normalizeClass([Vue.unref(ns).em("avatar__circle", "bg"), Vue.unref(ns).is("mask", Vue.unref(bloggerConfig).circleBgMask)]),
                style: Vue.normalizeStyle(avatarBgStyle.value)
              },
              null,
              6
              /* CLASS, STYLE */
            )) : Vue.createCommentVNode("v-if", true),
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass(`${Vue.unref(ns).e("avatar")} ${Vue.unref(bloggerConfig).shape} flx-center`)
              },
              [
                Vue.createElementVNode("div", null, [
                  Vue.unref(bloggerConfig).avatar ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1s), {
                    key: 0,
                    src: Vue.unref(vitepress.withBase)(Vue.unref(bloggerConfig).avatar),
                    size: Vue.unref(bloggerConfig).shape === "square" ? "100%" : Vue.unref(bloggerConfig).circleSize ?? 100,
                    shape: shape.value,
                    "bg-color": "transparent",
                    alt: Vue.unref(t)("tk.myCard.avatarAlt"),
                    title: Vue.unref(t)("tk.myCard.avatarTitle"),
                    "aria-hidden": "true"
                  }, null, 8, ["src", "size", "shape", "alt", "title"])) : (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1s), {
                    key: 1,
                    size: Vue.unref(bloggerConfig).circleSize ?? 100,
                    shape: shape.value,
                    text: Vue.unref(bloggerConfig).name,
                    "text-size": 50,
                    "bg-color": Vue.unref(ns).cssVar("theme-color"),
                    "aria-hidden": "true"
                  }, null, 8, ["size", "shape", "text", "bg-color"])),
                  Vue.unref(bloggerConfig).status?.icon && shape.value?.startsWith("circle") ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1s), {
                    key: 2,
                    src: isSrc.value ? Vue.unref(bloggerConfig).status.icon : "",
                    text: Vue.unref(bloggerConfig).status.icon,
                    size: Vue.unref(bloggerConfig).status.size ?? 26,
                    "icon-size": Vue.unref(bloggerConfig).status.size ?? 26,
                    "text-size": Vue.unref(bloggerConfig).status.size ?? 26,
                    title: Vue.unref(bloggerConfig).status.title,
                    circle: "",
                    "bg-color": "transparent",
                    class: "avatar-sticker",
                    "aria-hidden": "true"
                  }, null, 8, ["src", "text", "size", "icon-size", "text-size", "title"])) : Vue.createCommentVNode("v-if", true)
                ])
              ],
              2
              /* CLASS */
            ),
            Vue.unref(socialConfig).length ? (Vue.openBlock(), Vue.createElementBlock("div", {
              key: 1,
              class: Vue.normalizeClass(`${Vue.unref(ns).e("icons")} flx-justify-around`),
              "aria-label": Vue.unref(t)("tk.myCard.socialLabel")
            }, [
              (Vue.openBlock(true), Vue.createElementBlock(
                Vue.Fragment,
                null,
                Vue.renderList(Vue.unref(socialConfig), (item, index) => {
                  return Vue.openBlock(), Vue.createElementBlock("a", {
                    key: index,
                    href: item.link && Vue.unref(vitepress.withBase)(item.link),
                    title: item.name,
                    target: "_blank",
                    "aria-label": item.name
                  }, [
                    item.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                      key: 0,
                      iconType: item.iconType,
                      icon: item.icon,
                      size: "20px",
                      hover: "",
                      imgAlt: item.imgAlt,
                      "aria-hidden": "true"
                    }, null, 8, ["iconType", "icon", "imgAlt"])) : Vue.createCommentVNode("v-if", true)
                  ], 8, _hoisted_2$g);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ], 10, _hoisted_1$k)) : Vue.createCommentVNode("v-if", true),
            Vue.createElementVNode("div", {
              class: Vue.normalizeClass(Vue.unref(ns).e("blogger")),
              "aria-label": Vue.unref(t)("tk.myCard.bloggerLabel")
            }, [
              Vue.createElementVNode(
                "h3",
                _hoisted_4$c,
                Vue.toDisplayString(Vue.unref(bloggerConfig).name),
                1
                /* TEXT */
              ),
              Vue.createElementVNode(
                "span",
                _hoisted_5$6,
                Vue.toDisplayString(Vue.unref(bloggerConfig).slogan),
                1
                /* TEXT */
              )
            ], 10, _hoisted_3$c)
          ]),
          _: 1
          /* STABLE */
        }, 8, ["class", "style", "aria-label"])) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  const _hoisted_1$j = ["src", "alt"];
  const _hoisted_2$f = ["aria-label"];
  const _hoisted_3$b = { class: "name" };
  const _hoisted_4$b = { class: "slogan" };
  var _sfc_main$x = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeMyCardScreen" },
    __name: "HomeMyCardScreen",
    setup(__props) {
      const ns = useNamespace("my-screen");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const blogger = getTeekConfigRef("blogger", {});
      const isShow = useMediaQuery("(max-width: 960px)");
      return (_ctx, _cache) => {
        return Vue.unref(isShow) && Vue.unref(blogger).name && Vue.unref(blogger).avatar && Vue.unref(blogger).slogan ? (Vue.openBlock(), Vue.createElementBlock(
          Vue.Fragment,
          { key: 0 },
          [
            Vue.renderSlot(_ctx.$slots, "teek-home-card-my-screen-before"),
            Vue.renderSlot(_ctx.$slots, "teek-home-card-my-screen", {}, () => [
              Vue.createElementVNode(
                "div",
                {
                  class: Vue.normalizeClass(Vue.unref(ns).b())
                },
                [
                  Vue.createElementVNode(
                    "div",
                    {
                      class: Vue.normalizeClass(Vue.unref(ns).e("avatar"))
                    },
                    [
                      Vue.unref(blogger).avatar ? (Vue.openBlock(), Vue.createElementBlock("img", {
                        key: 0,
                        src: Vue.unref(vitepress.withBase)(Vue.unref(blogger).avatar),
                        alt: Vue.unref(t)("tk.myCard.avatarAlt")
                      }, null, 8, _hoisted_1$j)) : Vue.createCommentVNode("v-if", true)
                    ],
                    2
                    /* CLASS */
                  ),
                  Vue.createElementVNode("div", {
                    class: Vue.normalizeClass(Vue.unref(ns).e("blogger")),
                    "aria-label": Vue.unref(t)("tk.myCard.bloggerLabel")
                  }, [
                    Vue.createElementVNode(
                      "h3",
                      _hoisted_3$b,
                      Vue.toDisplayString(Vue.unref(blogger).name),
                      1
                      /* TEXT */
                    ),
                    Vue.createElementVNode(
                      "span",
                      _hoisted_4$b,
                      Vue.toDisplayString(Vue.unref(blogger).slogan),
                      1
                      /* TEXT */
                    )
                  ], 10, _hoisted_2$f)
                ],
                2
                /* CLASS */
              )
            ]),
            Vue.renderSlot(_ctx.$slots, "teek-home-card-my-screen-after")
          ],
          64
          /* STABLE_FRAGMENT */
        )) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  const _hoisted_1$i = ["aria-label"];
  const _hoisted_2$e = ["href"];
  const _hoisted_3$a = { class: "date" };
  const _hoisted_4$a = ["aria-label"];
  var _sfc_main$w = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeTopArticleCard" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("top-article");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const posts = usePosts();
      const topArticleConfig = getTeekConfigRef("topArticle", {
        limit: 4,
        title: t("tk.topArticleCard.title", { icon: topArticleIcon }),
        emptyLabel: t("tk.topArticleCard.emptyLabel"),
        autoPage: false,
        pageSpeed: 4e3,
        dateFormat: "yyyy-MM-dd hh:mm:ss"
      });
      const topArticleList = Vue.computed(() => {
        const sortPostsByDateAndSticky = posts.value.sortPostsByDateAndSticky;
        return sortPostsByDateAndSticky.filter((p) => p.frontmatter.top)?.map((p, index) => ({ ...p, num: index + 1 }));
      });
      const pageNum = Vue.ref(1);
      const currentTopArticleList = Vue.computed(() => {
        const { limit } = topArticleConfig.value;
        const p = pageNum.value;
        return topArticleList.value.slice((p - 1) * limit, p * limit);
      });
      const formatPostDate = (date) => {
        const dateFormatConst = topArticleConfig.value.dateFormat;
        if (isFunction(dateFormatConst)) return dateFormatConst(date || "");
        return formatDate(date || /* @__PURE__ */ new Date(), dateFormatConst);
      };
      const finalTitle = Vue.computed(() => {
        const { title } = topArticleConfig.value;
        if (isFunction(title)) return title(topArticleIcon);
        return title;
      });
      const tagColor = useTagColor();
      const itemRefs = Vue.ref([]);
      const getStyle = (num, index) => {
        return {
          [ns.cssVarName("num-bg-color")]: tagColor.value[num % tagColor.value.length].text,
          top: `calc(${index} * (calc(${ns.cssVar("home-top-article-gap")} + ${itemRefs.value?.[index]?.getBoundingClientRect().height || 0}px)))`
        };
      };
      const router = vitepress.useRouter();
      const handleTitleClick = () => {
        topArticleConfig.value.titleClick?.(router);
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$z), {
          page: "",
          modelValue: pageNum.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => pageNum.value = $event),
          pageSize: Vue.unref(topArticleConfig).limit,
          total: topArticleList.value.length,
          title: finalTitle.value,
          titleClick: Vue.unref(topArticleConfig).titleClick ? handleTitleClick : void 0,
          autoPage: Vue.unref(topArticleConfig).autoPage,
          pageSpeed: Vue.unref(topArticleConfig).pageSpeed,
          class: Vue.normalizeClass(Vue.unref(ns).b()),
          "aria-label": Vue.unref(t)("tk.topArticleCard.label")
        }, {
          default: Vue.withCtx(({ transitionName }) => [
            topArticleList.value.length ? (Vue.openBlock(), Vue.createBlock(Vue.TransitionGroup, {
              key: 0,
              name: transitionName,
              tag: "ul",
              mode: "out-in",
              class: Vue.normalizeClass(`${Vue.unref(ns).e("list")} flx-column`),
              "aria-label": Vue.unref(t)("tk.topArticleCard.listLabel")
            }, {
              default: Vue.withCtx(() => [
                (Vue.openBlock(true), Vue.createElementBlock(
                  Vue.Fragment,
                  null,
                  Vue.renderList(currentTopArticleList.value, (item, index) => {
                    return Vue.openBlock(), Vue.createElementBlock("li", {
                      ref_for: true,
                      ref_key: "itemRefs",
                      ref: itemRefs,
                      key: item.num,
                      class: Vue.normalizeClass(Vue.unref(ns).e("list__item")),
                      style: Vue.normalizeStyle(getStyle(item.num - 1, index)),
                      "aria-label": item.title
                    }, [
                      Vue.createElementVNode(
                        "span",
                        {
                          class: Vue.normalizeClass(["num", { sticky: item.frontmatter.sticky }])
                        },
                        Vue.toDisplayString(item.num),
                        3
                        /* TEXT, CLASS */
                      ),
                      Vue.createElementVNode(
                        "div",
                        {
                          class: Vue.normalizeClass(Vue.unref(ns).e("list__item__info"))
                        },
                        [
                          Vue.createElementVNode("a", {
                            href: item.url && Vue.unref(vitepress.withBase)(item.url),
                            class: "hover-color flx-align-center"
                          }, [
                            Vue.createVNode(Vue.unref(_sfc_main$17), {
                              post: item,
                              "title-tag-props": { position: "right", size: "mini" }
                            }, null, 8, ["post"])
                          ], 8, _hoisted_2$e),
                          Vue.createElementVNode(
                            "div",
                            _hoisted_3$a,
                            Vue.toDisplayString(formatPostDate(item.date)),
                            1
                            /* TEXT */
                          )
                        ],
                        2
                        /* CLASS */
                      )
                    ], 14, _hoisted_1$i);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ]),
              _: 1
              /* STABLE */
            }, 8, ["name", "class", "aria-label"])) : (Vue.openBlock(), Vue.createElementBlock("div", {
              key: 1,
              class: Vue.normalizeClass(Vue.unref(ns).m("empty")),
              "aria-label": Vue.unref(topArticleConfig).emptyLabel
            }, Vue.toDisplayString(Vue.unref(topArticleConfig).emptyLabel), 11, _hoisted_4$a))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["modelValue", "pageSize", "total", "title", "titleClick", "autoPage", "pageSpeed", "class", "aria-label"]);
      };
    }
  });

  const postDataUpdateSymbol = Symbol("postDataUpdate");

  const _hoisted_1$h = ["onClick", "aria-label"];
  const _hoisted_2$d = { class: "sle" };
  const _hoisted_3$9 = ["href", "aria-label"];
  const _hoisted_4$9 = ["aria-label"];
  const categoryKey = "category";
  var _sfc_main$v = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeCategoryCard" },
    __name: "index",
    props: {
      categoriesPage: { type: Boolean, default: false }
    },
    setup(__props) {
      const ns = useNamespace("category");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const { categoryPath } = usePagePath();
      const categoryConfig = getTeekConfigRef("category", {
        path: "/categories",
        pageTitle: t("tk.categoryCard.pageTitle", { icon: categoryIcon }),
        homeTitle: t("tk.categoryCard.homeTitle", { icon: categoryIcon }),
        emptyLabel: t("tk.categoryCard.emptyLabel"),
        moreLabel: t("tk.categoryCard.moreLabel"),
        limit: 5,
        autoPage: false,
        pageSpeed: 4e3
      });
      const posts = usePosts();
      const pageNum = Vue.ref(1);
      const categories = Vue.computed(() => posts.value.groupCards.categories);
      const currentCategories = Vue.computed(() => {
        const { limit } = categoryConfig.value;
        const c = categories.value;
        const p = pageNum.value;
        return __props.categoriesPage ? c : c.slice((p - 1) * limit, p * limit);
      });
      const finalTitle = Vue.computed(() => {
        const { pageTitle, homeTitle } = categoryConfig.value;
        const pt = isFunction(pageTitle) ? pageTitle(categoryIcon) : pageTitle;
        const ht = isFunction(homeTitle) ? homeTitle(categoryIcon) : homeTitle;
        return { pt, ht };
      });
      const updatePostListData = Vue.inject(postDataUpdateSymbol, () => {
      });
      const router = vitepress.useRouter();
      const selectedCategory = Vue.ref("");
      const handleSwitchCategory = (category = "") => {
        const { pathname, searchParams } = new URL(window.location.href);
        const categoriesPathConst = vitepress.withBase(categoryPath.value);
        const inCategoriesPage = categoriesPathConst === pathname;
        searchParams.delete(pageNumKey);
        searchParams.append(pageNumKey, "1");
        searchParams.delete(categoryKey);
        if (category) searchParams.append(categoryKey, category);
        const searchParamsStr = category ? `?${searchParams.toString()}` : "";
        if (inCategoriesPage && selectedCategory.value === category) return;
        selectedCategory.value = category;
        if (!inCategoriesPage) return router.go(categoriesPathConst + searchParamsStr);
        window.history.pushState({}, "", pathname + searchParamsStr);
        updatePostListData();
      };
      Vue.onMounted(() => {
        const { searchParams } = new URL(window.location.href);
        const category = searchParams.get(categoryKey);
        if (category) selectedCategory.value = category;
      });
      Vue.watch(
        () => __props.categoriesPage,
        () => {
          if (!__props.categoriesPage) {
            selectedCategory.value = "";
            return;
          }
          const { searchParams } = new URL(window.location.href);
          const category = searchParams.get(categoryKey);
          if (category && selectedCategory.value !== category) selectedCategory.value = category;
        }
      );
      const itemRefs = Vue.ref([]);
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$z), {
          page: !__props.categoriesPage,
          modelValue: pageNum.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => pageNum.value = $event),
          pageSize: Vue.unref(categoryConfig).limit,
          total: categories.value.length,
          title: finalTitle.value[__props.categoriesPage ? "pt" : "ht"],
          titleClick: handleSwitchCategory,
          autoPage: Vue.unref(categoryConfig).autoPage,
          pageSpeed: Vue.unref(categoryConfig).pageSpeed,
          class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("page", __props.categoriesPage)]),
          "aria-label": Vue.unref(t)("tk.categoryCard.label")
        }, {
          default: Vue.withCtx(({ transitionName }) => [
            categories.value.length ? (Vue.openBlock(), Vue.createBlock(Vue.TransitionGroup, {
              key: 0,
              name: transitionName,
              tag: "div",
              mode: "out-in",
              class: Vue.normalizeClass(`${Vue.unref(ns).e("list")} flx-column`),
              "aria-label": Vue.unref(t)("tk.categoryCard.listLabel")
            }, {
              default: Vue.withCtx(() => [
                (Vue.openBlock(true), Vue.createElementBlock(
                  Vue.Fragment,
                  null,
                  Vue.renderList(currentCategories.value, (item, index) => {
                    return Vue.openBlock(), Vue.createElementBlock("a", {
                      ref_for: true,
                      ref_key: "itemRefs",
                      ref: itemRefs,
                      key: item.name,
                      onClick: ($event) => handleSwitchCategory(item.name),
                      class: Vue.normalizeClass([{ active: item.name === selectedCategory.value }, "hover-color"]),
                      style: Vue.normalizeStyle(`top: ${index * itemRefs.value?.[index]?.getBoundingClientRect().height || 0}px`),
                      "aria-label": item.name
                    }, [
                      Vue.createElementVNode(
                        "span",
                        _hoisted_2$d,
                        Vue.toDisplayString(item.name),
                        1
                        /* TEXT */
                      ),
                      Vue.createElementVNode(
                        "span",
                        null,
                        Vue.toDisplayString(item.length),
                        1
                        /* TEXT */
                      )
                    ], 14, _hoisted_1$h);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                )),
                !__props.categoriesPage && Vue.unref(categoryConfig).limit < categories.value.length ? (Vue.openBlock(), Vue.createElementBlock("a", {
                  key: 0,
                  href: Vue.unref(vitepress.withBase)(Vue.unref(categoryPath)),
                  "aria-label": Vue.unref(categoryConfig).moreLabel
                }, Vue.toDisplayString(Vue.unref(categoryConfig).moreLabel), 9, _hoisted_3$9)) : Vue.createCommentVNode("v-if", true)
              ]),
              _: 1
              /* STABLE */
            }, 8, ["name", "class", "aria-label"])) : (Vue.openBlock(), Vue.createElementBlock("div", {
              key: 1,
              class: Vue.normalizeClass(Vue.unref(ns).m("empty")),
              "aria-label": Vue.unref(categoryConfig).emptyLabel
            }, Vue.toDisplayString(Vue.unref(categoryConfig).emptyLabel), 11, _hoisted_4$9))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["page", "modelValue", "pageSize", "total", "title", "autoPage", "pageSpeed", "class", "aria-label"]);
      };
    }
  });

  const _hoisted_1$g = ["onClick", "aria-label"];
  const _hoisted_2$c = { class: "num" };
  const _hoisted_3$8 = ["href", "aria-label"];
  const _hoisted_4$8 = ["aria-label"];
  const tagKey = "tag";
  var _sfc_main$u = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeTagCard" },
    __name: "index",
    props: {
      tagsPage: { type: Boolean, default: false }
    },
    setup(__props) {
      const ns = useNamespace("tag");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const pageNum = Vue.ref(1);
      const tagConfig = getTeekConfigRef("tag", {
        pageTitle: t("tk.tagCard.pageTitle", { icon: tagIcon }),
        homeTitle: t("tk.tagCard.homeTitle", { icon: tagIcon }),
        emptyLabel: t("tk.tagCard.emptyLabel"),
        moreLabel: t("tk.tagCard.moreLabel"),
        limit: 21,
        autoPage: false,
        pageSpeed: 4e3,
        bgColor: ""
      });
      const { tagPath } = usePagePath();
      const posts = usePosts();
      const tagColor = useTagColor();
      const tags = Vue.computed(() => posts.value.groupCards.tags);
      const currentTags = Vue.computed(() => {
        const { limit } = tagConfig.value;
        const t2 = tags.value;
        const p = pageNum.value;
        return __props.tagsPage ? t2 : t2.slice((p - 1) * limit, p * limit);
      });
      const finalTitle = Vue.computed(() => {
        const { pageTitle, homeTitle } = tagConfig.value;
        const pt = isFunction(pageTitle) ? pageTitle(tagIcon) : pageTitle;
        const ht = isFunction(homeTitle) ? homeTitle(tagIcon) : homeTitle;
        return { pt, ht };
      });
      const getTagStyle = (index) => {
        const tagColorConst = tagColor.value;
        const color = tagColorConst[index % tagColorConst.length];
        return {
          [ns.cssVarName("home-tag-bg-color")]: color.bg,
          backgroundColor: color.bg,
          color: color.text,
          borderColor: color.border
        };
      };
      const updatePostListData = Vue.inject(postDataUpdateSymbol, () => {
      });
      const router = vitepress.useRouter();
      const selectedTag = Vue.ref("");
      const handleSwitchTag = (tag = "") => {
        const { pathname, searchParams } = new URL(window.location.href);
        const categoriesPageLinkConst = vitepress.withBase(tagPath.value);
        const inCategoriesPage = categoriesPageLinkConst === pathname;
        searchParams.delete(pageNumKey);
        searchParams.append(pageNumKey, "1");
        searchParams.delete(tagKey);
        if (tag) searchParams.append(tagKey, tag);
        const searchParamsStr = tag ? `?${searchParams.toString()}` : "";
        if (inCategoriesPage && selectedTag.value === tag) return;
        selectedTag.value = tag;
        if (!inCategoriesPage) return router.go(categoriesPageLinkConst + searchParamsStr);
        window.history.pushState({}, "", pathname + searchParamsStr);
        updatePostListData();
      };
      Vue.onMounted(() => {
        const { searchParams } = new URL(window.location.href);
        const tag = searchParams.get(tagKey);
        if (tag) selectedTag.value = tag;
      });
      Vue.watch(
        () => __props.tagsPage,
        () => {
          if (!__props.tagsPage) {
            selectedTag.value = "";
            return;
          }
          const { searchParams } = new URL(window.location.href);
          const tag = searchParams.get(tagKey);
          if (tag && selectedTag.value !== tag) selectedTag.value = tag;
        }
      );
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$z), {
          page: !__props.tagsPage,
          modelValue: pageNum.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => pageNum.value = $event),
          pageSize: Vue.unref(tagConfig).limit,
          total: tags.value.length,
          title: finalTitle.value[__props.tagsPage ? "pt" : "ht"],
          titleClick: handleSwitchTag,
          autoPage: Vue.unref(tagConfig).autoPage,
          pageSpeed: Vue.unref(tagConfig).pageSpeed,
          class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("page", __props.tagsPage)]),
          "aria-label": Vue.unref(t)("tk.tagCard.label")
        }, {
          default: Vue.withCtx(({ transitionName }) => [
            tags.value.length ? (Vue.openBlock(), Vue.createBlock(Vue.TransitionGroup, {
              key: 0,
              name: transitionName,
              tag: "div",
              mode: "out-in",
              class: Vue.normalizeClass(Vue.unref(ns).e("list")),
              "aria-label": Vue.unref(t)("tk.tagCard.listLabel")
            }, {
              default: Vue.withCtx(() => [
                (Vue.openBlock(true), Vue.createElementBlock(
                  Vue.Fragment,
                  null,
                  Vue.renderList(currentTags.value, (item, index) => {
                    return Vue.openBlock(), Vue.createElementBlock("a", {
                      key: item.name,
                      style: Vue.normalizeStyle(getTagStyle(index)),
                      onClick: ($event) => handleSwitchTag(item.name),
                      class: Vue.normalizeClass([{ active: item.name === selectedTag.value }, Vue.unref(ns).join("pointer")]),
                      "aria-label": item.name
                    }, [
                      Vue.createElementVNode(
                        "span",
                        null,
                        Vue.toDisplayString(item.name),
                        1
                        /* TEXT */
                      ),
                      Vue.createElementVNode(
                        "span",
                        _hoisted_2$c,
                        Vue.toDisplayString(item.length),
                        1
                        /* TEXT */
                      )
                    ], 14, _hoisted_1$g);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                )),
                !__props.tagsPage && Vue.unref(tagConfig).limit < tags.value.length ? (Vue.openBlock(), Vue.createElementBlock("a", {
                  key: 0,
                  href: Vue.unref(vitepress.withBase)(Vue.unref(tagPath)),
                  class: "more",
                  "aria-label": Vue.unref(tagConfig).moreLabel
                }, Vue.toDisplayString(Vue.unref(tagConfig).moreLabel), 9, _hoisted_3$8)) : Vue.createCommentVNode("v-if", true)
              ]),
              _: 1
              /* STABLE */
            }, 8, ["name", "class", "aria-label"])) : (Vue.openBlock(), Vue.createElementBlock("div", {
              key: 1,
              class: Vue.normalizeClass(Vue.unref(ns).m("empty")),
              "aria-label": Vue.unref(tagConfig).emptyLabel
            }, Vue.toDisplayString(Vue.unref(tagConfig).emptyLabel), 11, _hoisted_4$8))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["page", "modelValue", "pageSize", "total", "title", "autoPage", "pageSpeed", "class", "aria-label"]);
      };
    }
  });

  const _hoisted_1$f = ["href", "aria-label"];
  const _hoisted_2$b = { class: "friend-avatar skeleton-image" };
  const _hoisted_3$7 = ["src", "alt"];
  const _hoisted_4$7 = ["title"];
  const _hoisted_5$5 = ["title"];
  var _sfc_main$t = /* @__PURE__ */ Vue.defineComponent({
    __name: "ItemInfo",
    props: {
      item: {},
      ns: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("a", {
          href: __props.item.link && Vue.unref(vitepress.withBase)(__props.item.link),
          target: "_blank",
          class: "hover-color flx-align-center",
          "aria-label": __props.item.name
        }, [
          Vue.createElementVNode("div", _hoisted_2$b, [
            Vue.createElementVNode("img", {
              src: __props.item.avatar && Vue.unref(vitepress.withBase)(__props.item.avatar),
              class: "avatar",
              alt: __props.item.alt || __props.item.name,
              "aria-hidden": "true",
              onLoad: _cache[0] || (_cache[0] = (e) => e.target?.classList.add("loaded")),
              onError: _cache[1] || (_cache[1] = (e) => e.target?.classList.add("loaded"))
            }, null, 40, _hoisted_3$7)
          ]),
          Vue.createElementVNode(
            "div",
            {
              class: Vue.normalizeClass(__props.ns.e("list__item__info"))
            },
            [
              Vue.createElementVNode("div", {
                class: "friend-name sle",
                title: __props.item.name
              }, Vue.toDisplayString(__props.item.name), 9, _hoisted_4$7),
              Vue.createElementVNode("div", {
                class: "friend-desc sle",
                title: __props.item.desc
              }, Vue.toDisplayString(__props.item.desc), 9, _hoisted_5$5)
            ],
            2
            /* CLASS */
          )
        ], 8, _hoisted_1$f);
      };
    }
  });

  const _hoisted_1$e = ["aria-label"];
  var _sfc_main$s = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeFriendLinkCard" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("friend-link");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const friendLinkConfig = getTeekConfigRef("friendLink", {
        list: [],
        limit: 4,
        title: t("tk.friendLinkCard.title", { icon: friendLinkIcon }),
        emptyLabel: t("tk.friendLinkCard.emptyLabel"),
        autoScroll: false,
        scrollSpeed: 2500,
        autoPage: false,
        pageSpeed: 4e3,
        titleClick: void 0
      });
      const { data, start, stop } = useScrollData(friendLinkConfig.value.list, 5, {
        intervalTime: friendLinkConfig.value.scrollSpeed
      });
      const pageNum = Vue.ref(1);
      const currentFriendLinkList = Vue.computed(() => {
        const { list, limit, autoScroll } = friendLinkConfig.value;
        if (autoScroll) return data.value;
        const p = pageNum.value;
        return list.slice((p - 1) * limit, p * limit);
      });
      const finalTitle = Vue.computed(() => {
        const { title } = friendLinkConfig.value;
        if (isFunction(title)) return title(friendLinkIcon);
        return title;
      });
      Vue.onMounted(() => {
        if (friendLinkConfig.value.autoScroll) start();
      });
      const itemRefs = Vue.ref([]);
      const getLiStyle = (index) => {
        if (friendLinkConfig.value.autoScroll) return {};
        const clientRect = itemRefs.value?.[index]?.getBoundingClientRect();
        return {
          top: `calc(${index} * (calc(${ns.cssVar("home-friend-link-gap")} + ${clientRect?.height || 0}px)))`
        };
      };
      const router = vitepress.useRouter();
      const handleTitleClick = () => {
        friendLinkConfig.value.titleClick?.(router);
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$z), {
          page: !Vue.unref(friendLinkConfig).autoScroll,
          modelValue: pageNum.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => pageNum.value = $event),
          pageSize: Vue.unref(friendLinkConfig).limit,
          total: Vue.unref(friendLinkConfig).list.length,
          title: finalTitle.value,
          titleClick: Vue.unref(friendLinkConfig).titleClick ? handleTitleClick : void 0,
          autoPage: Vue.unref(friendLinkConfig).autoPage,
          pageSpeed: Vue.unref(friendLinkConfig).pageSpeed,
          class: Vue.normalizeClass(Vue.unref(ns).b()),
          "aria-label": Vue.unref(t)("tk.friendLinkCard.label")
        }, {
          default: Vue.withCtx(({ transitionName, startAutoPage, closeAutoPage }) => [
            Vue.unref(friendLinkConfig).list.length ? (Vue.openBlock(), Vue.createBlock(Vue.TransitionGroup, {
              key: 0,
              name: transitionName,
              tag: "ul",
              mode: "out-in",
              class: Vue.normalizeClass(`${Vue.unref(ns).e("list")} flx-column`),
              onMouseenter: ($event) => Vue.unref(friendLinkConfig).autoScroll ? Vue.unref(stop)() : Vue.unref(friendLinkConfig).autoPage ? closeAutoPage() : () => {
              },
              onMouseleave: ($event) => Vue.unref(friendLinkConfig).autoScroll ? Vue.unref(start)() : Vue.unref(friendLinkConfig).autoPage ? startAutoPage() : () => {
              },
              "aria-label": Vue.unref(t)("tk.friendLinkCard.listLabel")
            }, {
              default: Vue.withCtx(() => [
                Vue.unref(friendLinkConfig).autoScroll ? (Vue.openBlock(true), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 0 },
                  Vue.renderList(currentFriendLinkList.value, (item, index) => {
                    return Vue.openBlock(), Vue.createElementBlock(
                      "li",
                      {
                        key: item.name,
                        class: Vue.normalizeClass(Vue.unref(ns).e("list__item")),
                        style: Vue.normalizeStyle(getLiStyle(index))
                      },
                      [
                        Vue.createVNode(_sfc_main$t, {
                          item,
                          ns: Vue.unref(ns)
                        }, null, 8, ["item", "ns"])
                      ],
                      6
                      /* CLASS, STYLE */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                )) : (Vue.openBlock(true), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 1 },
                  Vue.renderList(currentFriendLinkList.value, (item, index) => {
                    return Vue.openBlock(), Vue.createElementBlock(
                      "li",
                      {
                        ref_for: true,
                        ref_key: "itemRefs",
                        ref: itemRefs,
                        key: item.name,
                        class: Vue.normalizeClass(Vue.unref(ns).e("list__item")),
                        style: Vue.normalizeStyle(getLiStyle(index))
                      },
                      [
                        Vue.createVNode(_sfc_main$t, {
                          item,
                          ns: Vue.unref(ns)
                        }, null, 8, ["item", "ns"])
                      ],
                      6
                      /* CLASS, STYLE */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ]),
              _: 1
              /* STABLE */
            }, 8, ["name", "class", "onMouseenter", "onMouseleave", "aria-label"])) : (Vue.openBlock(), Vue.createElementBlock("div", {
              key: 1,
              class: Vue.normalizeClass(Vue.unref(ns).m("empty")),
              "aria-label": Vue.unref(friendLinkConfig).emptyLabel
            }, Vue.toDisplayString(Vue.unref(friendLinkConfig).emptyLabel), 11, _hoisted_1$e))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["page", "modelValue", "pageSize", "total", "title", "titleClick", "autoPage", "pageSpeed", "class", "aria-label"]);
      };
    }
  });

  const _hoisted_1$d = ["innerHTML"];
  const _hoisted_2$a = ["innerHTML"];
  var _sfc_main$r = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeDocAnalysisCard" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("doc-analysis");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const { theme } = vitepress.useData();
      const vpRouter = useVpRouter();
      const docAnalysisConfig = getTeekConfigRef("docAnalysis", {
        createTime: void 0,
        title: t("tk.docAnalysisCard.title", { icon: docAnalysisIcon }),
        statistics: {},
        overrideInfo: [],
        appendInfo: []
      });
      const docAnalysisInfo = Vue.computed(() => theme.value.docAnalysisInfo || {});
      const finalTitle = Vue.computed(() => {
        const { title } = docAnalysisConfig.value;
        if (isFunction(title)) return title(docAnalysisIcon);
        return title;
      });
      const createToNowDay = Vue.computed(() => formatDiffDateToDay(docAnalysisConfig.value.createTime || getNowDate()));
      const posts = usePosts();
      const postAddNum = Vue.computed(() => {
        const sortPostsByDate = posts.value.sortPostsByDate;
        let weekAddNum = 0;
        let monthAddNum = 0;
        const currentDate = new Date(getNowDate());
        for (const item of sortPostsByDate) {
          if (!item.date) continue;
          const postDate = new Date(item.date);
          if (postDate.getTime() > currentDate.getTime() - 7 * 24 * 60 * 60 * 1e3) weekAddNum++;
          if (postDate.getTime() > currentDate.getTime() - 30 * 24 * 60 * 60 * 1e3) monthAddNum++;
          else return { weekAddNum, monthAddNum };
        }
        return { weekAddNum, monthAddNum };
      });
      const formatWordCount = (wordCount) => {
        if (wordCount < 1e3) return wordCount + "";
        if (wordCount < 1e6) return Math.round(wordCount / 100) / 10 + "k";
        return Math.round(wordCount / 1e4) / 10 + "w";
      };
      const statisticsConfig = Vue.computed(() => ({
        url: "",
        provider: "",
        siteView: true,
        iteration: false,
        pageIteration: 2e3,
        permalink: true,
        ...docAnalysisConfig.value.statistics
      }));
      const useSiteView = Vue.computed(() => !!statisticsConfig.value.provider && statisticsConfig.value.siteView);
      const { router } = vpRouter;
      const { sitePv, siteUv, isGet, request } = useUvPv(false, statisticsConfig.value);
      Vue.watch(useSiteView, (newVal) => {
        if (newVal) request();
      });
      Vue.watch(
        router.route,
        () => {
          if (useSiteView.value) {
            if (statisticsConfig.value.permalink && router.state?.permalinkPlugin) {
              Vue.nextTick(request);
            } else request();
          }
        },
        { immediate: true }
      );
      const appendInfo = Vue.computed(() => {
        const { appendInfo: appendInfo2 } = docAnalysisConfig.value;
        return isFunction(appendInfo2) ? appendInfo2() : appendInfo2;
      });
      const docAnalysisList = Vue.computed(() => {
        const { createTime, overrideInfo } = docAnalysisConfig.value;
        const { fileList = [], totalFileWords, lastCommitTime } = docAnalysisInfo.value;
        const list = [
          {
            key: "totalPosts",
            label: t("tk.docAnalysisCard.totalPosts"),
            originValue: fileList.length,
            value: `${fileList.length} ${t("tk.docAnalysisCard.fileUnit")}`
          },
          {
            key: "weekAddNum",
            label: t("tk.docAnalysisCard.weekAddNum"),
            originValue: postAddNum.value?.weekAddNum,
            value: `${postAddNum.value?.weekAddNum} ${t("tk.docAnalysisCard.fileUnit")}`
          },
          {
            key: "monthAddNum",
            label: t("tk.docAnalysisCard.monthAddNum"),
            originValue: postAddNum.value?.monthAddNum,
            value: `${postAddNum.value?.monthAddNum} ${t("tk.docAnalysisCard.fileUnit")}`
          },
          {
            key: "runtime",
            label: t("tk.docAnalysisCard.runtime"),
            originValue: createTime,
            value: `${createToNowDay.value === 0 ? t("tk.docAnalysisCard.runtimeLess") : `${createToNowDay.value} ${t("tk.docAnalysisCard.runtimeUnit")}`}`
          },
          {
            key: "totalWordCount",
            label: t("tk.docAnalysisCard.totalWordCount"),
            originValue: totalFileWords,
            value: `${formatWordCount(totalFileWords)} ${t("tk.docAnalysisCard.wordCountUnit")}`
          },
          {
            key: "lastActiveTime",
            label: t("tk.docAnalysisCard.lastActiveTime"),
            originValue: lastCommitTime,
            value: formatDiffDate(lastCommitTime)
          },
          {
            key: "viewCount",
            label: t("tk.docAnalysisCard.viewCount"),
            originValue: sitePv.value,
            value: isGet.value ? `${sitePv.value} ${t("tk.docAnalysisCard.viewCountUnit")}` : "Get...",
            show: useSiteView.value
          },
          {
            key: "visitCount",
            label: t("tk.docAnalysisCard.visitCount"),
            originValue: siteUv.value,
            value: isGet.value ? `${siteUv.value} ${t("tk.docAnalysisCard.visitCountUnit")}` : "Get...",
            show: useSiteView.value
          },
          ...appendInfo.value
        ];
        if (overrideInfo.length) {
          list.forEach((item) => {
            const override = overrideInfo.find((overrideItem) => overrideItem.key === item.key);
            if (override) {
              item.label = override.label || item.label;
              item.value = override.value ? override.value(item.originValue || "", item.value) : item.value;
              item.show = override.show !== false;
            }
          });
        }
        return list;
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$z), {
          title: finalTitle.value,
          class: Vue.normalizeClass(Vue.unref(ns).b()),
          "aria-label": Vue.unref(t)("tk.docAnalysisCard.label")
        }, {
          default: Vue.withCtx(() => [
            (Vue.openBlock(true), Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(docAnalysisList.value, (item) => {
                return Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  {
                    key: item.key
                  },
                  [
                    item.show !== false ? (Vue.openBlock(), Vue.createElementBlock(
                      "div",
                      {
                        key: 0,
                        class: Vue.normalizeClass(Vue.unref(ns).e("item"))
                      },
                      [
                        Vue.createElementVNode("span", {
                          innerHTML: item.label
                        }, null, 8, _hoisted_1$d),
                        Vue.createElementVNode("span", {
                          innerHTML: item.value
                        }, null, 8, _hoisted_2$a)
                      ],
                      2
                      /* CLASS */
                    )) : Vue.createCommentVNode("v-if", true)
                  ],
                  64
                  /* STABLE_FRAGMENT */
                );
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["title", "class", "aria-label"]);
      };
    }
  });

  var _sfc_main$q = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "HomeCardList" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("home-card-list");
      const { getTeekConfigRef } = useTeekConfig();
      const teekConfig = getTeekConfigRef(null, {});
      const finalHomeCardSort = Vue.computed(() => {
        const configCardSort = teekConfig.value.homeCardSort || [];
        return ["my", .../* @__PURE__ */ new Set([...configCardSort, ...["topArticle", "category", "tag", "friendLink", "docAnalysis"]])];
      });
      const { isHomePage, isCategoriesPage, isTagsPage } = usePageState();
      const componentMap = Vue.computed(() => {
        const { topArticle, category, tag, docAnalysis, friendLink } = teekConfig.value;
        const homePage = isHomePage.value;
        const categoriesPage = isCategoriesPage.value;
        const tagsPage = isTagsPage.value;
        return {
          my: {
            el: _sfc_main$y,
            show: homePage,
            slot: "teek-home-card-my"
          },
          topArticle: {
            el: _sfc_main$w,
            show: homePage && topArticle?.enabled !== false,
            slot: "teek-home-card-top-article"
          },
          category: {
            el: _sfc_main$v,
            props: { categoriesPage },
            show: (homePage || categoriesPage) && category?.enabled !== false,
            slot: "teek-home-card-category"
          },
          tag: {
            el: _sfc_main$u,
            props: { tagsPage },
            show: (homePage || tagsPage) && tag?.enabled !== false,
            slot: "teek-home-card-tag"
          },
          docAnalysis: {
            el: _sfc_main$r,
            show: homePage && docAnalysis?.enabled !== false,
            slot: "teek-home-card-doc-analysis"
          },
          friendLink: {
            el: _sfc_main$s,
            show: homePage && friendLink?.enabled !== false,
            slot: "teek-home-card-friend-link"
          }
        };
      });
      const windowTransition = useWindowTransitionConfig((config) => config.card);
      const cardListInstance = Vue.ref(null);
      const { start } = useWindowTransition(cardListInstance, false);
      Vue.onMounted(() => {
        windowTransition.value && start();
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass([Vue.unref(ns).b(), "flx-column"])
          },
          [
            Vue.renderSlot(_ctx.$slots, "teek-home-card-before"),
            Vue.renderSlot(_ctx.$slots, "teek-home-card", { homeCard: finalHomeCardSort.value }, () => [
              (Vue.openBlock(true), Vue.createElementBlock(
                Vue.Fragment,
                null,
                Vue.renderList(finalHomeCardSort.value, (item) => {
                  return Vue.openBlock(), Vue.createElementBlock(
                    Vue.Fragment,
                    { key: item },
                    [
                      Vue.createCommentVNode(" \u4F7F\u7528\u6DE1\u5165\u52A8\u753B "),
                      Vue.unref(windowTransition) ? (Vue.openBlock(), Vue.createElementBlock(
                        Vue.Fragment,
                        { key: 0 },
                        [
                          _ctx.$slots[`${componentMap.value[item]?.slot}-before`] ? (Vue.openBlock(), Vue.createElementBlock(
                            "div",
                            {
                              key: 0,
                              ref_for: true,
                              ref_key: "cardListInstance",
                              ref: cardListInstance
                            },
                            [
                              Vue.renderSlot(_ctx.$slots, `${componentMap.value[item]?.slot}-before`)
                            ],
                            512
                            /* NEED_PATCH */
                          )) : Vue.createCommentVNode("v-if", true),
                          Vue.createElementVNode(
                            "div",
                            {
                              ref_for: true,
                              ref_key: "cardListInstance",
                              ref: cardListInstance
                            },
                            [
                              Vue.renderSlot(_ctx.$slots, componentMap.value[item]?.slot, {}, () => [
                                componentMap.value[item]?.show ? (Vue.openBlock(), Vue.createBlock(
                                  Vue.resolveDynamicComponent(componentMap.value[item]?.el),
                                  Vue.mergeProps({
                                    key: 0,
                                    ref_for: true
                                  }, componentMap.value[item]?.props),
                                  null,
                                  16
                                  /* FULL_PROPS */
                                )) : Vue.createCommentVNode("v-if", true)
                              ])
                            ],
                            512
                            /* NEED_PATCH */
                          ),
                          _ctx.$slots[`${componentMap.value[item]?.slot}-after`] ? (Vue.openBlock(), Vue.createElementBlock(
                            "div",
                            {
                              key: 1,
                              ref_for: true,
                              ref_key: "cardListInstance",
                              ref: cardListInstance
                            },
                            [
                              Vue.renderSlot(_ctx.$slots, `${componentMap.value[item]?.slot}-after`)
                            ],
                            512
                            /* NEED_PATCH */
                          )) : Vue.createCommentVNode("v-if", true)
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      )) : (Vue.openBlock(), Vue.createElementBlock(
                        Vue.Fragment,
                        { key: 1 },
                        [
                          Vue.createCommentVNode(" \u4E0D\u4F7F\u7528\u6DE1\u5165\u52A8\u753B "),
                          componentMap.value[item]?.slot ? Vue.renderSlot(_ctx.$slots, `${componentMap.value[item]?.slot}-before`, { key: 0 }) : Vue.createCommentVNode("v-if", true),
                          componentMap.value[item]?.slot ? Vue.renderSlot(_ctx.$slots, componentMap.value[item]?.slot, { key: 1 }, () => [
                            componentMap.value[item]?.show ? (Vue.openBlock(), Vue.createBlock(
                              Vue.resolveDynamicComponent(componentMap.value[item]?.el),
                              Vue.mergeProps({
                                key: 0,
                                ref_for: true
                              }, componentMap.value[item]?.props),
                              null,
                              16
                              /* FULL_PROPS */
                            )) : Vue.createCommentVNode("v-if", true)
                          ]) : Vue.createCommentVNode("v-if", true),
                          componentMap.value[item]?.slot ? Vue.renderSlot(_ctx.$slots, `${componentMap.value[item]?.slot}-after`, { key: 2 }) : Vue.createCommentVNode("v-if", true)
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      ))
                    ],
                    64
                    /* STABLE_FRAGMENT */
                  );
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]),
            Vue.renderSlot(_ctx.$slots, "teek-home-card-after")
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const _hoisted_1$c = ["aria-label"];
  const _hoisted_2$9 = { key: 0 };
  const _hoisted_3$6 = ["aria-label"];
  const _hoisted_4$6 = ["aria-label"];
  var _sfc_main$p = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "Home" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("home");
      const { t } = useLocale();
      const { isHomePage } = usePageState();
      const { getTeekConfigRef } = useTeekConfig();
      const teekConfig = getTeekConfigRef(null, {
        teekHome: true,
        homeCardListPosition: "right",
        banner: {},
        wallpaper: {},
        bodyBgImg: {}
      });
      const homePostListInstance = Vue.ref(null);
      Vue.provide(postDataUpdateSymbol, () => homePostListInstance.value?.updateData());
      const isPaging = Vue.ref(false);
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(Vue.unref(ns).b()),
          role: "main",
          "aria-label": Vue.unref(t)("tk.home.label")
        }, [
          Vue.unref(isHomePage) && (Vue.unref(teekConfig).banner.enabled ?? true) ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock(
            "div",
            _hoisted_2$9,
            [
              Vue.createVNode(Vue.unref(_sfc_main$A), { disabled: isPaging.value }, Vue.createSlots({
                _: 2
                /* DYNAMIC */
              }, [
                Vue.renderList(_ctx.$slots, (_, name) => {
                  return {
                    name,
                    fn: Vue.withCtx((scope) => [
                      Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(scope)))
                    ])
                  };
                })
              ]), 1032, ["disabled"])
            ],
            512
            /* NEED_PATCH */
          )), [
            [Vue.vShow, !isPaging.value]
          ]) : Vue.createCommentVNode("v-if", true),
          Vue.createElementVNode(
            "div",
            {
              class: Vue.normalizeClass([Vue.unref(ns).e("content"), Vue.unref(ns).join("wallpaper-outside"), "flx-start-justify-center"])
            },
            [
              Vue.createElementVNode("div", {
                class: Vue.normalizeClass(Vue.unref(ns).e("content__post")),
                "aria-label": Vue.unref(t)("tk.home.postLabel")
              }, [
                Vue.renderSlot(_ctx.$slots, "teek-home-post-before"),
                Vue.createVNode(Vue.unref(_sfc_main$G), {
                  modelValue: isPaging.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isPaging.value = $event),
                  ref_key: "homePostListInstance",
                  ref: homePostListInstance
                }, Vue.createSlots({
                  _: 2
                  /* DYNAMIC */
                }, [
                  Vue.renderList(_ctx.$slots, (_, name) => {
                    return {
                      name,
                      fn: Vue.withCtx((scope) => [
                        Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(scope)))
                      ])
                    };
                  })
                ]), 1032, ["modelValue"]),
                Vue.renderSlot(_ctx.$slots, "teek-home-post-after")
              ], 10, _hoisted_3$6),
              Vue.unref(teekConfig).homeCardListPosition ? (Vue.openBlock(), Vue.createElementBlock("div", {
                key: 0,
                class: Vue.normalizeClass([Vue.unref(ns).e("content__info"), Vue.unref(teekConfig).homeCardListPosition === "left" ? Vue.unref(ns).is("left") : Vue.unref(ns).is("right")]),
                "aria-label": Vue.unref(t)("tk.home.cardLabel")
              }, [
                Vue.createVNode(
                  Vue.unref(_sfc_main$q),
                  null,
                  Vue.createSlots({
                    _: 2
                    /* DYNAMIC */
                  }, [
                    Vue.renderList(_ctx.$slots, (_, name) => {
                      return {
                        name,
                        fn: Vue.withCtx((scope) => [
                          Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(scope)))
                        ])
                      };
                    })
                  ]),
                  1024
                  /* DYNAMIC_SLOTS */
                )
              ], 10, _hoisted_4$6)) : Vue.createCommentVNode("v-if", true)
            ],
            2
            /* CLASS */
          ),
          Vue.unref(teekConfig).wallpaper.enabled && (Vue.unref(teekConfig).banner.bgStyle === "fullImg" || Vue.unref(teekConfig).bodyBgImg.imgSrc) ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$J), { key: 1 })) : Vue.createCommentVNode("v-if", true)
        ], 10, _hoisted_1$c);
      };
    }
  });

  const _hoisted_1$b = ["src"];
  const _hoisted_2$8 = ["innerHTML"];
  const _hoisted_3$5 = ["innerHTML"];
  const _hoisted_4$5 = {
    key: 0,
    class: "features"
  };
  const _hoisted_5$4 = ["innerHTML"];
  const _hoisted_6$3 = ["innerHTML"];
  const _hoisted_7$1 = ["src"];
  const _hoisted_8$1 = ["innerHTML"];
  const _hoisted_9$1 = ["innerHTML"];
  const _hoisted_10 = {
    key: 0,
    class: "highlights"
  };
  const _hoisted_11 = ["innerHTML"];
  const _hoisted_12 = ["innerHTML"];
  var _sfc_main$o = /* @__PURE__ */ Vue.defineComponent({
    __name: "index",
    setup(__props) {
      const ns = useNamespace("home-features");
      const { getTeekConfigRef } = useTeekConfig();
      const featuresConfig = getTeekConfigRef("features", []);
      const windowTransition = useWindowTransitionConfig((config) => config.feature);
      const textInstance = Vue.ref(null);
      const { start } = useWindowTransition(textInstance, false);
      Vue.onMounted(() => {
        windowTransition.value && start();
      });
      return (_ctx, _cache) => {
        return Vue.unref(featuresConfig)?.length ? (Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            key: 0,
            class: Vue.normalizeClass([Vue.unref(ns).b(), "vp-doc"])
          },
          [
            (Vue.openBlock(true), Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(Vue.unref(featuresConfig), (feature) => {
                return Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  {
                    key: feature.title
                  },
                  [
                    feature.features ? (Vue.openBlock(), Vue.createElementBlock(
                      "div",
                      {
                        key: 0,
                        class: Vue.normalizeClass([Vue.unref(ns).e("feature-wrapper"), "features-wrapper"])
                      },
                      [
                        Vue.createElementVNode(
                          "div",
                          {
                            class: Vue.normalizeClass(Vue.unref(ns).e("feature__content"))
                          },
                          [
                            Vue.createElementVNode("img", {
                              src: feature.image,
                              class: "image"
                            }, null, 8, _hoisted_1$b),
                            Vue.createElementVNode(
                              "div",
                              {
                                class: Vue.normalizeClass([Vue.unref(ns).e("feature__header"), "header"])
                              },
                              [
                                Vue.createElementVNode("h2", {
                                  ref_for: true,
                                  ref_key: "textInstance",
                                  ref: textInstance,
                                  innerHTML: feature.title
                                }, null, 8, _hoisted_2$8),
                                feature.details ? (Vue.openBlock(), Vue.createElementBlock("p", {
                                  key: 0,
                                  ref_for: true,
                                  ref_key: "textInstance",
                                  ref: textInstance,
                                  innerHTML: feature.details
                                }, null, 8, _hoisted_3$5)) : Vue.createCommentVNode("v-if", true)
                              ],
                              2
                              /* CLASS */
                            ),
                            feature.features?.length ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_4$5, [
                              (Vue.openBlock(true), Vue.createElementBlock(
                                Vue.Fragment,
                                null,
                                Vue.renderList(feature.features, (item) => {
                                  return Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(item.link ? "a" : "div"), {
                                    key: item.title,
                                    href: Vue.unref(vitepress.withBase)(item.link ?? ""),
                                    class: "features__item item"
                                  }, {
                                    default: Vue.withCtx(() => [
                                      Vue.createElementVNode(
                                        "h3",
                                        {
                                          ref_for: true,
                                          ref_key: "textInstance",
                                          ref: textInstance,
                                          class: "flx-align-center"
                                        },
                                        [
                                          item.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                                            key: 0,
                                            icon: item.icon,
                                            class: "feature-icon"
                                          }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true),
                                          Vue.createElementVNode("span", {
                                            innerHTML: item.title
                                          }, null, 8, _hoisted_5$4)
                                        ],
                                        512
                                        /* NEED_PATCH */
                                      ),
                                      item.details ? (Vue.openBlock(), Vue.createElementBlock("p", {
                                        key: 0,
                                        ref_for: true,
                                        ref_key: "textInstance",
                                        ref: textInstance,
                                        innerHTML: item.details
                                      }, null, 8, _hoisted_6$3)) : Vue.createCommentVNode("v-if", true)
                                    ]),
                                    _: 2
                                    /* DYNAMIC */
                                  }, 1032, ["href"]);
                                }),
                                128
                                /* KEYED_FRAGMENT */
                              ))
                            ])) : Vue.createCommentVNode("v-if", true)
                          ],
                          2
                          /* CLASS */
                        )
                      ],
                      2
                      /* CLASS */
                    )) : feature.highlights ? (Vue.openBlock(), Vue.createElementBlock(
                      "div",
                      {
                        key: 1,
                        class: Vue.normalizeClass([Vue.unref(ns).e("highlight-wrapper"), "features-wrapper"])
                      },
                      [
                        Vue.createElementVNode(
                          "div",
                          {
                            class: Vue.normalizeClass(Vue.unref(ns).e("highlight"))
                          },
                          [
                            Vue.createElementVNode("img", {
                              src: feature.image,
                              class: "image"
                            }, null, 8, _hoisted_7$1),
                            Vue.createElementVNode(
                              "div",
                              {
                                class: Vue.normalizeClass(Vue.unref(ns).e("highlight__content"))
                              },
                              [
                                Vue.createElementVNode(
                                  "div",
                                  {
                                    class: Vue.normalizeClass([Vue.unref(ns).e("highlight__header"), "header"])
                                  },
                                  [
                                    Vue.createElementVNode("h2", {
                                      ref_for: true,
                                      ref_key: "textInstance",
                                      ref: textInstance,
                                      innerHTML: feature.title
                                    }, null, 8, _hoisted_8$1),
                                    feature.details ? (Vue.openBlock(), Vue.createElementBlock("p", {
                                      key: 0,
                                      ref_for: true,
                                      ref_key: "textInstance",
                                      ref: textInstance,
                                      innerHTML: feature.details
                                    }, null, 8, _hoisted_9$1)) : Vue.createCommentVNode("v-if", true)
                                  ],
                                  2
                                  /* CLASS */
                                ),
                                feature.highlights?.length ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_10, [
                                  (Vue.openBlock(true), Vue.createElementBlock(
                                    Vue.Fragment,
                                    null,
                                    Vue.renderList(feature.highlights, (item) => {
                                      return Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(item.link ? "a" : "div"), {
                                        key: item.title,
                                        href: Vue.unref(vitepress.withBase)(item.link ?? ""),
                                        class: Vue.normalizeClass([{ "no-details": !item.details }, "highlights__item item"])
                                      }, {
                                        default: Vue.withCtx(() => [
                                          Vue.createElementVNode(
                                            "h3",
                                            {
                                              ref_for: true,
                                              ref_key: "textInstance",
                                              ref: textInstance
                                            },
                                            [
                                              item.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                                                key: 0,
                                                icon: item.icon,
                                                class: "feature-icon"
                                              }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true),
                                              Vue.createElementVNode("span", {
                                                innerHTML: item.title
                                              }, null, 8, _hoisted_11)
                                            ],
                                            512
                                            /* NEED_PATCH */
                                          ),
                                          item.details ? (Vue.openBlock(), Vue.createElementBlock("p", {
                                            key: 0,
                                            ref_for: true,
                                            ref_key: "textInstance",
                                            ref: textInstance,
                                            innerHTML: item.details
                                          }, null, 8, _hoisted_12)) : Vue.createCommentVNode("v-if", true)
                                        ]),
                                        _: 2
                                        /* DYNAMIC */
                                      }, 1032, ["href", "class"]);
                                    }),
                                    128
                                    /* KEYED_FRAGMENT */
                                  ))
                                ])) : Vue.createCommentVNode("v-if", true)
                              ],
                              2
                              /* CLASS */
                            )
                          ],
                          2
                          /* CLASS */
                        )
                      ],
                      2
                      /* CLASS */
                    )) : Vue.createCommentVNode("v-if", true)
                  ],
                  64
                  /* STABLE_FRAGMENT */
                );
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          2
          /* CLASS */
        )) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  const ns$1 = useNamespace("theme-enhance");
  const transitionName = ns$1.join("theme-enhance-slide");
  const pageMaxWidthVar = ns$1.cssVarName("page-max-width");
  const docMaxWidthVar = ns$1.cssVarName("doc-max-width");
  const layoutModeStorageKey = ns$1.storageKey("layoutMode");
  const pageMaxWidthSlideStorageKey = ns$1.storageKey("pageMaxWidthSlide");
  const docMaxWidthSlideStorageKey = ns$1.storageKey("docMaxWidthSlide");
  const themeColorStorageKey = ns$1.storageKey("themeColor");
  const themeBgColorStorageKey = ns$1.storageKey("themeBgColor");
  const spotlightStorageKey = ns$1.storageKey("spotlight");
  const spotlightStyleStorageKey = ns$1.storageKey("spotlightStyle");

  var LayoutMode = /* @__PURE__ */ ((LayoutMode2) => {
    LayoutMode2["FullWidth"] = "fullWidth";
    LayoutMode2["SidebarWidthAdjustableOnly"] = "sidebarWidthAdjustableOnly";
    LayoutMode2["BothWidthAdjustable"] = "bothWidthAdjustable";
    LayoutMode2["Original"] = "original";
    return LayoutMode2;
  })(LayoutMode || {});
  var SpotlightStyle = /* @__PURE__ */ ((SpotlightStyle2) => {
    SpotlightStyle2["Under"] = "under";
    SpotlightStyle2["Aside"] = "aside";
    return SpotlightStyle2;
  })(SpotlightStyle || {});
  var ThemeColorName = /* @__PURE__ */ ((ThemeColorName2) => {
    ThemeColorName2["vpDefault"] = "vp-default";
    ThemeColorName2["vpGreen"] = "vp-green";
    ThemeColorName2["vpYellow"] = "vp-yellow";
    ThemeColorName2["vpRed"] = "vp-red";
    ThemeColorName2["epBlue"] = "ep-blue";
    ThemeColorName2["epGreen"] = "ep-green";
    ThemeColorName2["epYellow"] = "ep-yellow";
    ThemeColorName2["epRed"] = "ep-red";
    return ThemeColorName2;
  })(ThemeColorName || {});
  const themeColorList = [
    "vp-default" /* vpDefault */,
    "vp-green" /* vpGreen */,
    "vp-yellow" /* vpYellow */,
    "vp-red" /* vpRed */,
    "ep-blue" /* epBlue */,
    "ep-green" /* epGreen */,
    "ep-yellow" /* epYellow */,
    "ep-red" /* epRed */
  ];
  const mobileMaxWidthMedia = "(max-width: 768px)";
  const activateMaxWidthSlideMedia = "(min-width: 1440px)";
  const touchMedia = "(pointer: coarse)";
  const layoutModeAttribute = "layout-mode";
  const themeColorAttribute = "theme-color";

  const useAnimated = (delay = 1e3, immediate = false) => {
    let timer = null;
    const stop = () => {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const start = () => {
      if (!isClient) return;
      if (!immediate) {
        immediate = true;
        return;
      }
      stop();
      document.documentElement.setAttribute(`${layoutModeAttribute}-animated`, "true");
      timer = setTimeout(() => {
        document.documentElement.removeAttribute(`${layoutModeAttribute}-animated`);
      }, Vue.toValue(delay));
    };
    useScopeDispose(stop);
    return { start, stop };
  };

  const _hoisted_1$a = { key: 0 };
  var _sfc_main$n = /* @__PURE__ */ Vue.defineComponent({
    __name: "Title",
    props: {
      title: {},
      disabled: { type: Boolean },
      icon: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass([Vue.unref(ns$1).e("title"), Vue.unref(ns$1).is("disabled", !!__props.disabled)])
          },
          [
            Vue.renderSlot(_ctx.$slots, "icon", {}, () => [
              __props.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                key: 0,
                icon: __props.icon,
                size: 16
              }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true)
            ]),
            Vue.renderSlot(_ctx.$slots, "default", {}, () => [
              __props.title ? (Vue.openBlock(), Vue.createElementBlock(
                "span",
                _hoisted_1$a,
                Vue.toDisplayString(__props.title),
                1
                /* TEXT */
              )) : Vue.createCommentVNode("v-if", true)
            ])
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  var _sfc_main$m = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "Helper" },
    __name: "Helper",
    props: /* @__PURE__ */ Vue.mergeModels({
      triggerEl: {}
    }, {
      "modelValue": { default: false },
      "modelModifiers": {}
    }),
    emits: ["update:modelValue"],
    setup(__props) {
      const visible = Vue.useModel(__props, "modelValue");
      const popoverVisible = Vue.ref(visible.value);
      Vue.watch(popoverVisible, (newVal) => {
        visible.value = newVal;
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1e), {
          class: Vue.normalizeClass(Vue.unref(ns$1).e("helper")),
          modelValue: popoverVisible.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => popoverVisible.value = $event),
          "trigger-el": __props.triggerEl,
          placement: "left-start"
        }, {
          reference: Vue.withCtx(() => [
            Vue.createVNode(Vue.unref(_sfc_main$1t), {
              icon: Vue.unref(questionFilledIcon),
              size: 16
            }, null, 8, ["icon"])
          ]),
          default: Vue.withCtx(() => [
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass(Vue.unref(ns$1).e("helper__popup"))
              },
              [
                Vue.renderSlot(_ctx.$slots, "default")
              ],
              2
              /* CLASS */
            )
          ]),
          _: 3
          /* FORWARDED */
        }, 8, ["class", "modelValue", "trigger-el"]);
      };
    }
  });

  var _sfc_main$l = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "BorderHighlight" },
    __name: "BorderHighlight",
    props: {
      active: { type: Boolean }
    },
    setup(__props) {
      const ns = useNamespace("border-highlight");
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("active", Boolean(__props.active))])
          },
          [
            Vue.renderSlot(_ctx.$slots, "default")
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const _hoisted_1$9 = {
    class: "flx-align-center",
    style: { "margin-bottom": "6px" }
  };
  const _hoisted_2$7 = {
    key: 1,
    style: { "font-weight": "600" }
  };
  const _hoisted_3$4 = { key: 0 };
  const _hoisted_4$4 = {
    key: 1,
    style: { "margin-top": "8px" }
  };
  var _sfc_main$k = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "BaseTemplate" },
    __name: "BaseTemplate",
    props: {
      title: {},
      helperDesc: {},
      icon: {},
      tips: {},
      disabled: { type: Boolean },
      helper: { type: Boolean },
      borderHighlight: { type: Boolean, default: true }
    },
    setup(__props) {
      const helperVisible = Vue.ref(false);
      const titleElementRef = Vue.ref();
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", null, [
          Vue.createElementVNode(
            "div",
            {
              ref_key: "titleElementRef",
              ref: titleElementRef,
              class: "flx-align-center"
            },
            [
              Vue.createVNode(_sfc_main$n, {
                title: __props.title,
                icon: __props.icon,
                disabled: __props.disabled,
                "aria-label": __props.title
              }, {
                default: Vue.withCtx(() => [
                  Vue.renderSlot(_ctx.$slots, "title")
                ]),
                _: 3
                /* FORWARDED */
              }, 8, ["title", "icon", "disabled", "aria-label"]),
              __props.helper ? (Vue.openBlock(), Vue.createBlock(_sfc_main$m, {
                key: 0,
                modelValue: helperVisible.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => helperVisible.value = $event),
                "trigger-el": titleElementRef.value
              }, {
                default: Vue.withCtx(() => [
                  Vue.createElementVNode(
                    "div",
                    {
                      class: Vue.normalizeClass(Vue.unref(ns$1).e("helper__body"))
                    },
                    [
                      Vue.createElementVNode(
                        "h4",
                        {
                          class: Vue.normalizeClass(Vue.unref(ns$1).em("helper", "title"))
                        },
                        [
                          Vue.renderSlot(_ctx.$slots, "helper-title", {}, () => [
                            Vue.createTextVNode(
                              Vue.toDisplayString(__props.title),
                              1
                              /* TEXT */
                            )
                          ])
                        ],
                        2
                        /* CLASS */
                      ),
                      Vue.createElementVNode(
                        "p",
                        {
                          class: Vue.normalizeClass(Vue.unref(ns$1).em("helper", "desc"))
                        },
                        [
                          Vue.renderSlot(_ctx.$slots, "helper-desc", {}, () => [
                            Vue.createTextVNode(
                              Vue.toDisplayString(__props.helperDesc),
                              1
                              /* TEXT */
                            )
                          ])
                        ],
                        2
                        /* CLASS */
                      ),
                      (Vue.openBlock(true), Vue.createElementBlock(
                        Vue.Fragment,
                        null,
                        Vue.renderList(__props.tips, (tip, index) => {
                          return Vue.openBlock(), Vue.createElementBlock(
                            "div",
                            {
                              key: index,
                              class: Vue.normalizeClass(Vue.unref(ns$1).e("helper__body__tip"))
                            },
                            [
                              Vue.createElementVNode("div", _hoisted_1$9, [
                                tip.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                                  key: 0,
                                  icon: tip.icon,
                                  size: 16,
                                  style: { "margin-right": "4px" }
                                }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true),
                                tip.title ? (Vue.openBlock(), Vue.createElementBlock(
                                  "span",
                                  _hoisted_2$7,
                                  Vue.toDisplayString(tip.title),
                                  1
                                  /* TEXT */
                                )) : Vue.createCommentVNode("v-if", true)
                              ]),
                              tip.content ? (Vue.openBlock(), Vue.createElementBlock(
                                "span",
                                _hoisted_3$4,
                                Vue.toDisplayString(tip.content),
                                1
                                /* TEXT */
                              )) : Vue.createCommentVNode("v-if", true)
                            ],
                            2
                            /* CLASS */
                          );
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      ))
                    ],
                    2
                    /* CLASS */
                  )
                ]),
                _: 3
                /* FORWARDED */
              }, 8, ["modelValue", "trigger-el"])) : Vue.createCommentVNode("v-if", true)
            ],
            512
            /* NEED_PATCH */
          ),
          __props.borderHighlight ? (Vue.openBlock(), Vue.createBlock(_sfc_main$l, {
            key: 0,
            active: helperVisible.value,
            style: { "margin-top": "8px" }
          }, {
            default: Vue.withCtx(() => [
              Vue.renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
            /* FORWARDED */
          }, 8, ["active"])) : (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_4$4, [
            Vue.renderSlot(_ctx.$slots, "default")
          ]))
        ]);
      };
    }
  });

  var _sfc_main$j = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "LayoutSwitch" },
    __name: "LayoutSwitch",
    setup(__props) {
      const { getTeekConfigRef } = useTeekConfig();
      const themeEnhanceConfig = getTeekConfigRef("themeEnhance", {});
      const { t } = useLocale();
      const { frontmatter } = vitepress.useData();
      const layoutMode = useStorage(
        layoutModeStorageKey,
        themeEnhanceConfig.value.layoutSwitch?.defaultMode || LayoutMode.Original
      );
      const isMobile = useMediaQuery(mobileMaxWidthMedia);
      const oldLayoutMode = Vue.ref(layoutMode.value);
      const { start: startAnimated } = useAnimated();
      const update = (val) => {
        if (!isClient) return;
        const { layoutSwitch } = themeEnhanceConfig.value;
        if (!layoutSwitch?.disableAnimation) startAnimated();
        const el = document.documentElement;
        if (el.getAttribute(layoutModeAttribute) === val) return;
        el.setAttribute(layoutModeAttribute, val);
        themeEnhanceConfig.value.layoutSwitch?.switchModeDone?.(val);
      };
      Vue.watch(layoutMode, update, { immediate: true });
      Vue.watch(
        () => frontmatter.value.layoutMode,
        (newVal) => {
          if (newVal) {
            oldLayoutMode.value = layoutMode.value;
            layoutMode.value = newVal;
          } else {
            layoutMode.value = oldLayoutMode.value;
          }
        },
        { immediate: true }
      );
      Vue.watch(
        () => themeEnhanceConfig.value.layoutSwitch?.defaultMode,
        (newVal) => {
          if (newVal) layoutMode.value = newVal;
        }
      );
      const content = Vue.computed(() => [
        {
          value: LayoutMode.FullWidth,
          title: t("tk.themeEnhance.layoutSwitch.fullWidthTipTitle"),
          tipContent: t("tk.themeEnhance.layoutSwitch.fullWidthHelpTipContent"),
          icon: fullScreenOneIcon
        },
        {
          value: LayoutMode.SidebarWidthAdjustableOnly,
          title: t("tk.themeEnhance.layoutSwitch.sidebarWidthAdjustableOnlyTipTitle"),
          tipContent: t("tk.themeEnhance.layoutSwitch.sidebarWidthAdjustableOnlyHelpTipContent"),
          icon: fullscreenTwoIcon
        },
        {
          value: LayoutMode.BothWidthAdjustable,
          title: t("tk.themeEnhance.layoutSwitch.bothWidthAdjustableTipTitle"),
          tipContent: t("tk.themeEnhance.layoutSwitch.bothWidthAdjustableHelpTipContent"),
          icon: fullscreenIcon
        },
        {
          value: LayoutMode.Original,
          title: t("tk.themeEnhance.layoutSwitch.originalWidthTipTitle"),
          tipContent: t("tk.themeEnhance.layoutSwitch.originalWidthHelpTipContent"),
          icon: overallReductionIcon
        }
      ]);
      const segmentedOptions = Vue.computed(
        () => content.value.map((item) => ({
          value: item.value,
          title: item.title,
          ariaLabel: item.title,
          icon: item.icon
        }))
      );
      const tips = Vue.computed(
        () => content.value.map((item) => ({
          title: item.title,
          icon: item.icon,
          content: item.tipContent
        }))
      );
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(_sfc_main$k, {
          icon: Vue.unref(layoutIcon),
          title: Vue.unref(t)("tk.themeEnhance.layoutSwitch.title"),
          helper: !Vue.unref(themeEnhanceConfig).layoutSwitch?.disableHelp,
          "helper-desc": Vue.unref(t)("tk.themeEnhance.layoutSwitch.helpDesc"),
          tips: tips.value,
          disabled: Vue.unref(isMobile)
        }, {
          default: Vue.withCtx(() => [
            Vue.createVNode(Vue.unref(_sfc_main$1c), {
              modelValue: Vue.unref(layoutMode),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(layoutMode) ? layoutMode.value = $event : null),
              options: segmentedOptions.value,
              disabled: Vue.unref(isMobile)
            }, null, 8, ["modelValue", "options", "disabled"])
          ]),
          _: 1
          /* STABLE */
        }, 8, ["icon", "title", "helper", "helper-desc", "tips", "disabled"]);
      };
    }
  });

  var _sfc_main$i = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "LayoutPageWidthSlide" },
    __name: "LayoutPageWidthSlide",
    setup(__props) {
      const { getTeekConfigRef } = useTeekConfig();
      const themeEnhanceConfig = getTeekConfigRef("themeEnhance", {});
      const { t } = useLocale();
      const min = Vue.computed(() => 60 * 100);
      const max = Vue.computed(() => 100 * 100);
      const pageMaxWidth = useStorage(
        pageMaxWidthSlideStorageKey,
        (themeEnhanceConfig.value.layoutSwitch?.defaultPageMaxWidth || 90) * 100
      );
      const layoutMode = useStorage(
        layoutModeStorageKey,
        themeEnhanceConfig.value.layoutSwitch?.defaultMode || LayoutMode.Original
      );
      const { start: startAnimated } = useAnimated();
      const updatePageMaxWidth = (val) => {
        if (!isClient) return;
        if (!themeEnhanceConfig.value.layoutSwitch?.disableAnimation) startAnimated();
        document.body.style.setProperty(pageMaxWidthVar, `${Math.ceil(val / 100)}%`);
      };
      const isMobile = useMediaQuery(mobileMaxWidthMedia);
      const shouldActivateMaxWidth = useMediaQuery(activateMaxWidthSlideMedia);
      Vue.watch(shouldActivateMaxWidth, () => {
        updatePageMaxWidth(pageMaxWidth.value);
      });
      const update = useDebounce(updatePageMaxWidth, 1e3);
      Vue.watch(pageMaxWidth, update);
      const format = (val) => `${Math.ceil(val / 100)}%`;
      const tips = [
        {
          title: t("tk.themeEnhance.pageLayoutMaxWidth.helpTipTitle"),
          icon: scaleIcon,
          content: t("tk.themeEnhance.pageLayoutMaxWidth.helpTipContent")
        }
      ];
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.Transition, {
          name: Vue.unref(transitionName),
          persisted: ""
        }, {
          default: Vue.withCtx(() => [
            Vue.withDirectives(Vue.createVNode(_sfc_main$k, {
              icon: Vue.unref(autoWidthIcon),
              title: Vue.unref(t)("tk.themeEnhance.pageLayoutMaxWidth.title"),
              helper: !Vue.unref(themeEnhanceConfig).layoutSwitch?.disablePageMaxWidthHelp,
              "helper-desc": Vue.unref(t)("tk.themeEnhance.pageLayoutMaxWidth.helpDesc"),
              tips,
              disabled: Vue.unref(isMobile)
            }, {
              default: Vue.withCtx(() => [
                Vue.createVNode(Vue.unref(_sfc_main$1m), {
                  modelValue: Vue.unref(pageMaxWidth),
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(pageMaxWidth) ? pageMaxWidth.value = $event : null),
                  disabled: Vue.unref(isMobile),
                  min: min.value,
                  max: max.value,
                  format,
                  class: Vue.normalizeClass(Vue.unref(ns$1).e("slide")),
                  "aria-label": Vue.unref(t)("tk.themeEnhance.pageLayoutMaxWidth.helperTipTitle")
                }, null, 8, ["modelValue", "disabled", "min", "max", "class", "aria-label"])
              ]),
              _: 1
              /* STABLE */
            }, 8, ["icon", "title", "helper", "helper-desc", "disabled"]), [
              [Vue.vShow, Vue.unref(layoutMode) === Vue.unref(LayoutMode).SidebarWidthAdjustableOnly || Vue.unref(layoutMode) === Vue.unref(LayoutMode).BothWidthAdjustable]
            ])
          ]),
          _: 1
          /* STABLE */
        }, 8, ["name"]);
      };
    }
  });

  var _sfc_main$h = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "LayoutDocWidthSlide" },
    __name: "LayoutDocWidthSlide",
    setup(__props) {
      const { getTeekConfigRef } = useTeekConfig();
      const themeEnhanceConfig = getTeekConfigRef("themeEnhance", {});
      const { t } = useLocale();
      const min = Vue.computed(() => 60 * 100);
      const max = Vue.computed(() => 100 * 100);
      const docMaxWidth = useStorage(
        docMaxWidthSlideStorageKey,
        (themeEnhanceConfig.value.layoutSwitch?.defaultDocMaxWidth || 95) * 100
      );
      const layoutMode = useStorage(
        layoutModeStorageKey,
        themeEnhanceConfig.value.layoutSwitch?.defaultMode || LayoutMode.Original
      );
      const { start: startAnimated } = useAnimated();
      const updateMaxWidth = (val) => {
        if (!isClient) return;
        if (!themeEnhanceConfig.value.layoutSwitch?.disableAnimation) startAnimated();
        const bodyStyle = document.body.style;
        if (!shouldActivateMaxWidth.value) bodyStyle.setProperty(ns$1.join("page-max-width"), `100%`);
        bodyStyle.setProperty(docMaxWidthVar, `${Math.ceil(val / 100)}%`);
      };
      const isMobile = useMediaQuery(mobileMaxWidthMedia);
      const shouldActivateMaxWidth = useMediaQuery(activateMaxWidthSlideMedia);
      Vue.watch(shouldActivateMaxWidth, () => {
        updateMaxWidth(docMaxWidth.value);
      });
      const update = useDebounce(updateMaxWidth, 1e3);
      Vue.watch(docMaxWidth, update);
      const format = (val) => `${Math.ceil(val / 100)}%`;
      const tips = [
        {
          title: t("tk.themeEnhance.docLayoutMaxWidth.helpTipTitle"),
          icon: scaleIcon,
          content: t("tk.themeEnhance.docLayoutMaxWidth.helpTipContent")
        }
      ];
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.Transition, {
          name: Vue.unref(transitionName),
          persisted: ""
        }, {
          default: Vue.withCtx(() => [
            Vue.withDirectives(Vue.createVNode(_sfc_main$k, {
              icon: Vue.unref(autoWidthIcon),
              title: Vue.unref(t)("tk.themeEnhance.docLayoutMaxWidth.title"),
              helper: !Vue.unref(themeEnhanceConfig).layoutSwitch?.disableDocMaxWidthHelp,
              "helper-desc": Vue.unref(t)("tk.themeEnhance.docLayoutMaxWidth.helpDesc"),
              tips,
              disabled: Vue.unref(isMobile)
            }, {
              default: Vue.withCtx(() => [
                Vue.createVNode(Vue.unref(_sfc_main$1m), {
                  modelValue: Vue.unref(docMaxWidth),
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(docMaxWidth) ? docMaxWidth.value = $event : null),
                  disabled: Vue.unref(isMobile),
                  min: min.value,
                  max: max.value,
                  format,
                  class: Vue.normalizeClass(Vue.unref(ns$1).e("slide")),
                  "aria-label": Vue.unref(t)("tk.themeEnhance.docLayoutMaxWidth.helperTipTitle")
                }, null, 8, ["modelValue", "disabled", "min", "max", "class", "aria-label"])
              ]),
              _: 1
              /* STABLE */
            }, 8, ["icon", "title", "helper", "helper-desc", "disabled"]), [
              [Vue.vShow, Vue.unref(layoutMode) === Vue.unref(LayoutMode).BothWidthAdjustable]
            ])
          ]),
          _: 1
          /* STABLE */
        }, 8, ["name"]);
      };
    }
  });

  var _sfc_main$g = /* @__PURE__ */ Vue.defineComponent({
    __name: "Switch",
    props: {
      "modelValue": { default: false },
      "modelModifiers": {}
    },
    emits: ["update:modelValue"],
    setup(__props) {
      const check = Vue.useModel(__props, "modelValue");
      const handleClick = () => {
        check.value = !check.value;
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "span",
          {
            class: Vue.normalizeClass([Vue.unref(ns$1).e("switch"), Vue.unref(ns$1).is("checked", check.value)]),
            onClick: handleClick
          },
          [..._cache[0] || (_cache[0] = [
            Vue.createElementVNode(
              "div",
              { class: "action" },
              null,
              -1
              /* CACHED */
            )
          ])],
          2
          /* CLASS */
        );
      };
    }
  });

  const useThemeColorList = () => {
    if (!isClient) return;
    const { getTeekConfigRef } = useTeekConfig();
    const themeEnhanceConfig = getTeekConfigRef("themeEnhance", {});
    const { t } = useLocale();
    return Vue.computed(() => {
      const { customize = false, append = [] } = themeEnhanceConfig.value.themeColor || {};
      const useVitepressTheme = isBoolean$1(customize) ? customize === false : customize?.vitepressTheme ?? true;
      const useElementPlusTheme = isBoolean$1(customize) ? customize === false : customize?.elementPlusTheme ?? true;
      const vitePressThemeColorList = useVitepressTheme ? [
        {
          label: t("tk.themeEnhance.themeColor.vpLabel"),
          tip: t("tk.themeEnhance.themeColor.vpTip"),
          options: [
            {
              value: ThemeColorName.vpDefault,
              label: t("tk.themeEnhance.themeColor.defaultLabel"),
              title: `VitePress ${t("tk.themeEnhance.themeColor.defaultLabel")}`,
              ariaLabel: `VitePress ${t("tk.themeEnhance.themeColor.defaultLabel")}`,
              color: getComputedStyle(document.documentElement).getPropertyValue("--vp-c-indigo-1")
            },
            {
              value: ThemeColorName.vpGreen,
              label: t("tk.themeEnhance.themeColor.greenLabel"),
              title: `VitePress ${t("tk.themeEnhance.themeColor.greenLabel")}`,
              ariaLabel: `VitePress ${t("tk.themeEnhance.themeColor.greenLabel")}`,
              color: getComputedStyle(document.documentElement).getPropertyValue("--vp-c-green-1")
            },
            {
              value: ThemeColorName.vpYellow,
              label: t("tk.themeEnhance.themeColor.yellowLabel"),
              title: `VitePress ${t("tk.themeEnhance.themeColor.yellowLabel")}`,
              ariaLabel: `VitePress ${t("tk.themeEnhance.themeColor.yellowLabel")}`,
              color: getComputedStyle(document.documentElement).getPropertyValue("--vp-c-yellow-1")
            },
            {
              value: ThemeColorName.vpRed,
              label: t("tk.themeEnhance.themeColor.redLabel"),
              title: `VitePress ${t("tk.themeEnhance.themeColor.redLabel")}`,
              ariaLabel: `VitePress ${t("tk.themeEnhance.themeColor.redLabel")}`,
              color: getComputedStyle(document.documentElement).getPropertyValue("--vp-c-red-1")
            }
          ]
        }
      ] : [];
      const elementPlusThemeColorList = useElementPlusTheme ? [
        {
          label: t("tk.themeEnhance.themeColor.epLabel"),
          tip: t("tk.themeEnhance.themeColor.epTip"),
          options: [
            {
              value: ThemeColorName.epBlue,
              label: `${t("tk.themeEnhance.themeColor.blueLabel")}`,
              title: `ElementPlus ${t("tk.themeEnhance.themeColor.blueLabel")}`,
              ariaLabel: `ElementPlus ${t("tk.themeEnhance.themeColor.blueLabel")}`,
              color: getComputedStyle(document.documentElement).getPropertyValue("--tk-el-color-primary")
            },
            {
              value: ThemeColorName.epGreen,
              label: `${t("tk.themeEnhance.themeColor.greenLabel")}`,
              title: `ElementPlus ${t("tk.themeEnhance.themeColor.greenLabel")}`,
              ariaLabel: `ElementPlus ${t("tk.themeEnhance.themeColor.greenLabel")}`,
              color: getComputedStyle(document.documentElement).getPropertyValue("--tk-el-color-success")
            },
            {
              value: ThemeColorName.epYellow,
              label: `${t("tk.themeEnhance.themeColor.yellowLabel")}`,
              title: `ElementPlus ${t("tk.themeEnhance.themeColor.yellowLabel")}`,
              ariaLabel: `ElementPlus ${t("tk.themeEnhance.themeColor.yellowLabel")}`,
              color: getComputedStyle(document.documentElement).getPropertyValue("--tk-el-color-warning")
            },
            {
              value: ThemeColorName.epRed,
              label: `${t("tk.themeEnhance.themeColor.redLabel")}`,
              title: `ElementPlus ${t("tk.themeEnhance.themeColor.redLabel")}`,
              ariaLabel: `ElementPlus ${t("tk.themeEnhance.themeColor.redLabel")}`,
              color: getComputedStyle(document.documentElement).getPropertyValue("--tk-el-color-danger")
            }
          ]
        }
      ] : [];
      return [...vitePressThemeColorList, ...elementPlusThemeColorList, ...append];
    });
  };

  const _hoisted_1$8 = { class: "flx-justify-between flx-1" };
  const _hoisted_2$6 = { class: "flx-align-center" };
  const _hoisted_3$3 = { class: "label" };
  const _hoisted_4$3 = ["title", "aria-label"];
  const _hoisted_5$3 = { class: "color-list flx-justify-between flx-wrap" };
  const _hoisted_6$2 = ["onClick", "title", "aria-label"];
  var _sfc_main$f = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ThemeColor" },
    __name: "ThemeColor",
    setup(__props) {
      const { getTeekConfigRef } = useTeekConfig();
      const themeEnhanceConfig = getTeekConfigRef("themeEnhance", {});
      const { t } = useLocale();
      const { frontmatter } = vitepress.useData();
      const isMobile = useMediaQuery(mobileMaxWidthMedia);
      const themeColorName = useStorage(
        themeColorStorageKey,
        themeEnhanceConfig.value.themeColor?.defaultColorName || ThemeColorName.vpDefault
      );
      const isSpread = useStorage(themeBgColorStorageKey, themeEnhanceConfig.value.themeColor?.defaultSpread || false);
      const oldThemeColor = Vue.ref(themeColorName.value);
      const primaryColor = Vue.ref("");
      const { clear, updateSpread } = useThemeColor(primaryColor, () => {
        if (themeColorList.includes(themeColorName.value)) {
          return [varNameList.vpBrand1, varNameList.vpBrand2, varNameList.vpBrand3, varNameList.vpBrandSoft];
        }
      });
      const themeColorSelectList = useThemeColorList();
      const update = (val) => {
        if (!isClient) return;
        const el = document.documentElement;
        if (el.getAttribute(themeColorAttribute) === val) return;
        el.setAttribute(themeColorAttribute, val);
        if (themeColorList.includes(val)) {
          clear();
          primaryColor.value = getComputedStyle(el).getPropertyValue(varNameList.vpBrand1);
        } else {
          const appendThemeColor = themeEnhanceConfig.value.themeColor?.append || [];
          const option = appendThemeColor.map((item) => item.options).flat().filter((item) => item.value === val);
          const color = option[0]?.color;
          !color && clear();
          primaryColor.value = color || getComputedStyle(el).getPropertyValue(varNameList.vpBrand1);
        }
        themeEnhanceConfig.value.themeColor?.switchColorDone?.(val);
      };
      Vue.watch(themeColorName, update, { immediate: true });
      Vue.watch(
        () => frontmatter.value.themeColorName,
        (newVal) => {
          if (newVal) {
            oldThemeColor.value = themeColorName.value;
            themeColorName.value = newVal;
          } else {
            themeColorName.value = oldThemeColor.value;
          }
        },
        { immediate: true }
      );
      Vue.watch(isSpread, updateSpread, { immediate: true, flush: "post" });
      const tips = [
        { title: t("tk.themeEnhance.themeColor.vpHelpTipTitle"), content: t("tk.themeEnhance.themeColor.vpHelpTipContent") },
        { title: t("tk.themeEnhance.themeColor.epHelpTipTitle"), content: t("tk.themeEnhance.themeColor.epHelpTipContent") }
      ];
      const handleChangePrimaryColor = (option) => {
        themeColorName.value = option.value;
      };
      const getStyle = (color) => {
        return color ? { backgroundColor: color } : {};
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(_sfc_main$k, {
          class: Vue.normalizeClass(Vue.unref(ns$1).e("theme-color")),
          icon: Vue.unref(waterIcon),
          title: Vue.unref(t)("tk.themeEnhance.themeColor.title"),
          helper: !Vue.unref(themeEnhanceConfig).themeColor?.disableHelp,
          "helper-desc": Vue.unref(t)("tk.themeEnhance.themeColor.helpDesc"),
          tips,
          disabled: Vue.unref(isMobile)
        }, {
          title: Vue.withCtx(() => [
            Vue.createElementVNode("div", _hoisted_1$8, [
              Vue.createTextVNode(
                Vue.toDisplayString(Vue.unref(t)("tk.themeEnhance.themeColor.title")) + " ",
                1
                /* TEXT */
              ),
              Vue.createElementVNode("div", _hoisted_2$6, [
                Vue.createElementVNode(
                  "span",
                  _hoisted_3$3,
                  Vue.toDisplayString(Vue.unref(t)("tk.themeEnhance.themeColor.speedLabel")),
                  1
                  /* TEXT */
                ),
                Vue.createVNode(_sfc_main$g, {
                  modelValue: Vue.unref(isSpread),
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(isSpread) ? isSpread.value = $event : null)
                }, null, 8, ["modelValue"])
              ])
            ])
          ]),
          default: Vue.withCtx(() => [
            (Vue.openBlock(true), Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(Vue.unref(themeColorSelectList), (item) => {
                return Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  {
                    key: item.label
                  },
                  [
                    Vue.createElementVNode("h3", {
                      title: item.tip,
                      "aria-label": item.label
                    }, Vue.toDisplayString(item.label), 9, _hoisted_4$3),
                    Vue.createElementVNode("ul", _hoisted_5$3, [
                      (Vue.openBlock(true), Vue.createElementBlock(
                        Vue.Fragment,
                        null,
                        Vue.renderList(item.options, (option) => {
                          return Vue.openBlock(), Vue.createElementBlock("li", {
                            key: item.label + option.value,
                            class: "flx-column-center",
                            onClick: ($event) => handleChangePrimaryColor(option),
                            title: option.title,
                            "aria-label": option.ariaLabel ?? option.title ?? option.label
                          }, [
                            Vue.createElementVNode(
                              "div",
                              {
                                class: Vue.normalizeClass(["color-wrapper flx-center", Vue.unref(ns$1).is("active", option.value === Vue.unref(themeColorName))])
                              },
                              [
                                Vue.createElementVNode(
                                  "div",
                                  {
                                    class: "color-bg",
                                    style: Vue.normalizeStyle(getStyle(option.color))
                                  },
                                  null,
                                  4
                                  /* STYLE */
                                )
                              ],
                              2
                              /* CLASS */
                            ),
                            Vue.createElementVNode(
                              "span",
                              null,
                              Vue.toDisplayString(option.label),
                              1
                              /* TEXT */
                            )
                          ], 8, _hoisted_6$2);
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      ))
                    ])
                  ],
                  64
                  /* STABLE_FRAGMENT */
                );
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["class", "icon", "title", "helper", "helper-desc", "disabled"]);
      };
    }
  });

  var _sfc_main$e = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "SpotlightHover" },
    __name: "SpotlightHover",
    props: {
      enabled: { type: Boolean }
    },
    setup(__props) {
      const props = __props;
      const shouldRecalculate = Vue.ref(false);
      const boxStyles = Vue.ref({ display: "none" });
      const vpDocElement = Vue.ref();
      const highlightedElement = Vue.ref();
      const spotlightStyle = useStorage(spotlightStyleStorageKey, SpotlightStyle.Aside);
      const mousePosition = Vue.ref({ x: 0, y: 0 });
      const computeBoxStyles = (bounding) => {
        return {
          display: "block",
          width: `${bounding.width + 8}px`,
          height: `${bounding.height + 8}px`,
          left: `${bounding.left - 4}px`,
          top: `${bounding.top - 4}px`,
          transition: "all 0.2s ease",
          borderRadius: "8px"
        };
      };
      const findChildElementUnderVPDocElement = (element) => {
        if (element === null) return null;
        if (element.parentElement === document.querySelector(".VPDoc main .vp-doc > div")) return element;
        else return findChildElementUnderVPDocElement(element.parentElement);
      };
      const watchHandler = () => {
        if (!isClient) return;
        const element = document.elementFromPoint(mousePosition.value.x, mousePosition.value.y);
        if (!(element && vpDocElement.value?.contains(element))) return;
        const el = findChildElementUnderVPDocElement(element);
        highlightedElement.value = el || void 0;
        if (highlightedElement.value && highlightedElement.value.tagName === "P") {
          const val = highlightedElement.value;
          const style = window.getComputedStyle(val);
          const lineHeight = Number.parseFloat(style.lineHeight);
          const lines = Math.floor(val.offsetHeight / lineHeight);
          const rect = val.getBoundingClientRect();
          const relativeY = mousePosition.value.y - rect.top;
          for (let i = 0; i < lines; i++) {
            const top = i * lineHeight;
            const height = lineHeight;
            const left = val.offsetLeft;
            const width = val.offsetWidth;
            if (relativeY >= top && relativeY < top + height) {
              boxStyles.value = computeBoxStyles({
                top: top + rect.top,
                left: left + rect.left,
                width,
                height
              });
              break;
            }
          }
        } else {
          if (highlightedElement.value) {
            const rect = highlightedElement.value.getBoundingClientRect();
            boxStyles.value = computeBoxStyles({
              top: rect.top,
              left: rect.left,
              width: rect.width,
              height: rect.height
            });
          }
        }
      };
      useEventListener(
        () => document,
        "mousemove",
        (event) => {
          mousePosition.value = { x: event.clientX, y: event.clientY };
        }
      );
      useEventListener(() => document, "scroll", watchHandler, true);
      Vue.onMounted(() => {
        vpDocElement.value = document.querySelector(".VPDoc main .vp-doc");
      });
      const route = vitepress.useRoute();
      Vue.watch(
        route,
        () => {
          vpDocElement.value = document.querySelector(".VPDoc main .vp-doc");
          shouldRecalculate.value = true;
          boxStyles.value = { display: "none" };
          watchHandler();
          shouldRecalculate.value = false;
        },
        { flush: "post" }
      );
      Vue.watch([() => mousePosition.value.x, () => mousePosition.value.y], () => {
        if (props.enabled) watchHandler();
      });
      Vue.watch(
        () => props.enabled,
        (val) => {
          if (!val) boxStyles.value = { display: "none" };
        }
      );
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.Teleport, { to: "body" }, [
          props.enabled && !shouldRecalculate.value ? (Vue.openBlock(), Vue.createElementBlock(
            "div",
            {
              key: 0,
              style: Vue.normalizeStyle(boxStyles.value),
              class: Vue.normalizeClass([
                Vue.unref(ns$1).join("spotlight-hover"),
                Vue.unref(spotlightStyle) === Vue.unref(SpotlightStyle).Under ? Vue.unref(ns$1).join("spotlight-hover__under") : "",
                Vue.unref(spotlightStyle) === Vue.unref(SpotlightStyle).Aside ? Vue.unref(ns$1).join("spotlight-hover__aside") : ""
              ]),
              "aria-hidden": "true",
              focusable: "false"
            },
            null,
            6
            /* CLASS, STYLE */
          )) : Vue.createCommentVNode("v-if", true)
        ]);
      };
    }
  });

  var _sfc_main$d = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "Spotlight" },
    __name: "Spotlight",
    setup(__props) {
      const { getTeekConfigRef } = useTeekConfig();
      const themeEnhanceConfig = getTeekConfigRef("themeEnhance", {});
      const { t } = useLocale();
      const { frontmatter } = vitepress.useData();
      const supportTouch = useMediaQuery(touchMedia);
      const spotlight = useStorage(spotlightStorageKey, themeEnhanceConfig.value.spotlight?.defaultValue ?? true);
      const oldSpotlight = Vue.ref(spotlight.value);
      Vue.watch(
        () => frontmatter.value.spotlight,
        (newVal) => {
          if (newVal !== void 0) {
            oldSpotlight.value = spotlight.value;
            spotlight.value = newVal;
          } else {
            spotlight.value = oldSpotlight.value;
          }
        },
        { immediate: true }
      );
      const segmentedOptions = Vue.computed(() => [
        {
          value: true,
          label: "ON",
          title: t("tk.themeEnhance.spotlight.onTipTitle"),
          ariaLabel: t("tk.themeEnhance.spotlight.onTipTitle")
        },
        {
          value: false,
          label: "OFF",
          title: t("tk.themeEnhance.spotlight.offTipTitle"),
          ariaLabel: t("tk.themeEnhance.spotlight.offTipTitle")
        }
      ]);
      const tips = [
        {
          title: `ON ${t("tk.themeEnhance.spotlight.onTipTitle")}`,
          content: t("tk.themeEnhance.spotlight.onHelpTipContent")
        },
        {
          title: `OFF ${t("tk.themeEnhance.spotlight.offTipTitle")}`,
          content: t("tk.themeEnhance.spotlight.offHelpTipContent")
        }
      ];
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          Vue.Fragment,
          null,
          [
            Vue.createVNode(_sfc_main$k, {
              icon: Vue.unref(clickIcon),
              title: Vue.unref(t)("tk.themeEnhance.spotlight.title"),
              helper: !Vue.unref(themeEnhanceConfig).spotlight?.disableHelp,
              "helper-desc": Vue.unref(t)("tk.themeEnhance.spotlight.helpDesc"),
              tips,
              disabled: Vue.unref(supportTouch)
            }, {
              default: Vue.withCtx(() => [
                Vue.createVNode(Vue.unref(_sfc_main$1c), {
                  modelValue: Vue.unref(spotlight),
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(spotlight) ? spotlight.value = $event : null),
                  options: segmentedOptions.value,
                  disabled: Vue.unref(supportTouch)
                }, null, 8, ["modelValue", "options", "disabled"])
              ]),
              _: 1
              /* STABLE */
            }, 8, ["icon", "title", "helper", "helper-desc", "disabled"]),
            Vue.unref(spotlight) && !Vue.unref(supportTouch) ? (Vue.openBlock(), Vue.createBlock(_sfc_main$e, {
              key: 0,
              enabled: Vue.unref(spotlight) && !Vue.unref(supportTouch)
            }, null, 8, ["enabled"])) : Vue.createCommentVNode("v-if", true)
          ],
          64
          /* STABLE_FRAGMENT */
        );
      };
    }
  });

  var _sfc_main$c = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "SpotlightStyle" },
    __name: "SpotlightStyle",
    setup(__props) {
      const { getTeekConfigRef } = useTeekConfig();
      const themeEnhanceConfig = getTeekConfigRef("themeEnhance", {});
      const { t } = useLocale();
      const spotlightStyle = useStorage(
        spotlightStyleStorageKey,
        themeEnhanceConfig.value.spotlight?.defaultStyle || SpotlightStyle.Aside
      );
      const spotlightToggledOn = useStorage(spotlightStorageKey, themeEnhanceConfig.value.spotlight?.defaultValue ?? true);
      const supportTouch = useMediaQuery(touchMedia);
      const content = Vue.computed(() => [
        {
          value: SpotlightStyle.Aside,
          title: t("tk.themeEnhance.spotlightStyles.asideTipTitle"),
          helpMessage: t("tk.themeEnhance.spotlightStyles.asideHelpTipContent"),
          ariaLabel: t("tk.themeEnhance.spotlightStyles.asideTipTitle"),
          icon: alignTextLeftIcon
        },
        {
          value: SpotlightStyle.Under,
          title: t("tk.themeEnhance.spotlightStyles.underTipTitle"),
          helpMessage: t("tk.themeEnhance.spotlightStyles.underHelpTipContent"),
          ariaLabel: t("tk.themeEnhance.spotlightStyles.underTipTitle"),
          icon: alignLeftIcon
        }
      ]);
      const segmentedOptions = Vue.computed(
        () => content.value.map((item) => ({
          value: item.value,
          title: item.title,
          ariaLabel: item.ariaLabel,
          icon: item.icon
        }))
      );
      const tips = Vue.computed(
        () => content.value.map((item) => ({
          title: item.title,
          icon: item.icon,
          content: item.helpMessage
        }))
      );
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.Transition, { name: Vue.unref(transitionName) }, {
          default: Vue.withCtx(() => [
            Vue.unref(spotlightToggledOn) ? (Vue.openBlock(), Vue.createBlock(_sfc_main$k, {
              key: 0,
              icon: Vue.unref(clickIcon),
              title: Vue.unref(t)("tk.themeEnhance.spotlightStyles.title"),
              helper: !Vue.unref(themeEnhanceConfig).spotlight?.disableHelp,
              "helper-desc": Vue.unref(t)("tk.themeEnhance.spotlightStyles.helpDesc"),
              tips: tips.value,
              disabled: Vue.unref(supportTouch)
            }, {
              default: Vue.withCtx(() => [
                Vue.createVNode(Vue.unref(_sfc_main$1c), {
                  modelValue: Vue.unref(spotlightStyle),
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(spotlightStyle) ? spotlightStyle.value = $event : null),
                  options: segmentedOptions.value,
                  disabled: Vue.unref(supportTouch)
                }, null, 8, ["modelValue", "options", "disabled"])
              ]),
              _: 1
              /* STABLE */
            }, 8, ["icon", "title", "helper", "helper-desc", "tips", "disabled"])) : Vue.createCommentVNode("v-if", true)
          ]),
          _: 1
          /* STABLE */
        }, 8, ["name"]);
      };
    }
  });

  var _sfc_main$b = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ThemeEnhance" },
    __name: "index",
    setup(__props) {
      const { getTeekConfigRef } = useTeekConfig();
      const themeEnhanceConfig = getTeekConfigRef("themeEnhance", { position: "top" });
      const isMobile = useMediaQuery(mobileMaxWidthMedia);
      const disabledList = Vue.computed(() => {
        return {
          layoutSwitch: themeEnhanceConfig.value.layoutSwitch?.disabled ?? false,
          themeColor: themeEnhanceConfig.value.themeColor?.disabled ?? false,
          spotlight: themeEnhanceConfig.value.spotlight?.disabled ?? false
        };
      });
      return (_ctx, _cache) => {
        return !Vue.unref(isMobile) && Vue.unref(themeEnhanceConfig).position === "top" ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1e), {
          key: 0,
          class: Vue.normalizeClass([Vue.unref(ns$1).b(), "flx-align-center"]),
          "popper-class": Vue.unref(ns$1).e("popover"),
          "y-offset": -15
        }, {
          reference: Vue.withCtx(() => [
            Vue.createVNode(Vue.unref(_sfc_main$1t), {
              icon: Vue.unref(readingIcon),
              size: 20
            }, null, 8, ["icon"])
          ]),
          default: Vue.withCtx(() => [
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass(Vue.unref(ns$1).e("content"))
              },
              [
                Vue.renderSlot(_ctx.$slots, "teek-theme-enhance-top"),
                !disabledList.value.layoutSwitch ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 0 },
                  [
                    Vue.createVNode(_sfc_main$j),
                    Vue.createVNode(_sfc_main$i),
                    Vue.createVNode(_sfc_main$h)
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true),
                !disabledList.value.themeColor ? (Vue.openBlock(), Vue.createBlock(_sfc_main$f, { key: 1 })) : Vue.createCommentVNode("v-if", true),
                !disabledList.value.spotlight ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 2 },
                  [
                    Vue.createVNode(_sfc_main$d),
                    Vue.createVNode(_sfc_main$c)
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true),
                Vue.renderSlot(_ctx.$slots, "teek-theme-enhance-bottom")
              ],
              2
              /* CLASS */
            )
          ]),
          _: 3
          /* FORWARDED */
        }, 8, ["class", "popper-class"])) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  const ns = useNamespace("right-bottom-button");

  const _hoisted_1$7 = ["title", "aria-label", "aria-valuenow"];
  const _hoisted_2$5 = {
    key: 0,
    class: "content"
  };
  var _sfc_main$a = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "BackTop" },
    __name: "BackTop",
    setup(__props) {
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const backTopConfig = getTeekConfigRef("backTop", {
        enabled: true,
        content: "progress"
      });
      const scrollTop = Vue.ref(0);
      const showToTop = Vue.computed(() => scrollTop.value > 100);
      const progress = Vue.ref(0);
      const scrollToTop = useDebounce(
        () => {
          if (!isClient) return;
          document.querySelector("html")?.scrollIntoView({ behavior: "smooth" });
          setTimeout(() => {
            backTopConfig.value.done?.(message);
          }, 600);
        },
        500,
        true
      );
      const watchScroll = () => {
        scrollTop.value = document.documentElement.scrollTop || document.body.scrollTop || 0;
        updateScrollProgress();
      };
      const updateScrollProgress = () => {
        const p = window.scrollY / (document.documentElement.scrollHeight - window.innerHeight);
        progress.value = Math.round(p * 100);
      };
      Vue.onMounted(() => {
        updateScrollProgress();
      });
      useEventListener(() => window, "scroll", watchScroll);
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.Transition, {
          name: Vue.unref(ns).join("fade")
        }, {
          default: Vue.withCtx(() => [
            Vue.renderSlot(_ctx.$slots, "default", {
              show: showToTop.value,
              progress: progress.value,
              icon: Vue.unref(rocketIcon),
              scrollToTop: Vue.unref(scrollToTop)
            }, () => [
              Vue.withDirectives(Vue.createElementVNode("div", {
                title: Vue.unref(t)("tk.rightBottomButton.backTopTitle"),
                class: Vue.normalizeClass([Vue.unref(ns).e("button"), "back-top"]),
                onClick: _cache[0] || (_cache[0] = //@ts-ignore
                (...args) => Vue.unref(scrollToTop) && Vue.unref(scrollToTop)(...args)),
                style: Vue.normalizeStyle({ [Vue.unref(ns).cssVarName("progress")]: progress.value }),
                role: "button",
                "aria-label": Vue.unref(t)("tk.rightBottomButton.backTopTitle"),
                "aria-valuenow": progress.value,
                "aria-valuemin": "0",
                "aria-valuemax": "100"
              }, [
                Vue.unref(backTopConfig).content === "progress" ? (Vue.openBlock(), Vue.createElementBlock(
                  "span",
                  _hoisted_2$5,
                  Vue.toDisplayString(progress.value),
                  1
                  /* TEXT */
                )) : Vue.unref(backTopConfig).content === "icon" ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1t), {
                  key: 1,
                  icon: Vue.unref(rocketIcon),
                  "aria-hidden": "true"
                }, null, 8, ["icon"])) : Vue.createCommentVNode("v-if", true)
              ], 14, _hoisted_1$7), [
                [Vue.vShow, showToTop.value]
              ])
            ])
          ]),
          _: 3
          /* FORWARDED */
        }, 8, ["name"]);
      };
    }
  });

  const _hoisted_1$6 = ["title", "aria-label"];
  var _sfc_main$9 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ToComment" },
    __name: "ToComment",
    setup(__props) {
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const toCommentConfig = getTeekConfigRef("toComment", {});
      const scrollTop = Vue.ref(0);
      const showToComment = Vue.computed(() => {
        if (!isClient) return false;
        const docContentHeight = document.querySelector(".content-container .main")?.getBoundingClientRect().height;
        const docFooterHeight = document.querySelector(".VPDocFooter")?.getBoundingClientRect().height || 200;
        let height = 0;
        if (docContentHeight) height = docContentHeight - docFooterHeight - window.innerHeight / 2;
        return scrollTop.value < height;
      });
      const scrollToComment = useDebounce(
        () => {
          if (!isClient) return;
          document.querySelector(`#${ns.join("comment")}`)?.scrollIntoView({ behavior: "smooth" });
          setTimeout(() => {
            toCommentConfig.value.done?.(message);
          }, 600);
        },
        500,
        true
      );
      const watchScroll = () => {
        scrollTop.value = document.documentElement.scrollTop || document.body.scrollTop || 0;
      };
      useEventListener(() => window, "scroll", watchScroll);
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.Transition, {
          name: Vue.unref(ns).join("fade")
        }, {
          default: Vue.withCtx(() => [
            Vue.renderSlot(_ctx.$slots, "default", {
              show: showToComment.value,
              icon: Vue.unref(commentIcon),
              scrollToComment: Vue.unref(scrollToComment)
            }, () => [
              Vue.withDirectives(Vue.createElementVNode("div", {
                title: Vue.unref(t)("tk.rightBottomButton.toComment"),
                class: Vue.normalizeClass(Vue.unref(ns).e("button")),
                onClick: _cache[0] || (_cache[0] = //@ts-ignore
                (...args) => Vue.unref(scrollToComment) && Vue.unref(scrollToComment)(...args)),
                role: "button",
                "aria-label": Vue.unref(t)("tk.rightBottomButton.toComment")
              }, [
                Vue.createVNode(Vue.unref(_sfc_main$1t), {
                  icon: Vue.unref(commentIcon),
                  "aria-hidden": "true"
                }, null, 8, ["icon"])
              ], 10, _hoisted_1$6), [
                [Vue.vShow, showToComment.value]
              ])
            ])
          ]),
          _: 3
          /* FORWARDED */
        }, 8, ["name"]);
      };
    }
  });

  const _hoisted_1$5 = ["title", "aria-label"];
  const _hoisted_2$4 = ["onClick", "title", "aria-label"];
  var _sfc_main$8 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "ThemeColor" },
    __name: "ThemeColor",
    setup(__props) {
      const { t } = useLocale();
      const { frontmatter } = vitepress.useData();
      const { getTeekConfigRef } = useTeekConfig();
      const themeEnhanceConfig = getTeekConfigRef("themeEnhance", {});
      const themeColorName = useStorage(
        themeColorStorageKey,
        themeEnhanceConfig.value.themeColor?.defaultColorName || ThemeColorName.vpDefault
      );
      const oldThemeColor = Vue.ref(themeColorName.value);
      const primaryColor = Vue.ref("");
      const { clear } = useThemeColor(primaryColor, () => {
        if (themeColorList.includes(themeColorName.value)) {
          return [varNameList.vpBrand1, varNameList.vpBrand2, varNameList.vpBrand3, varNameList.vpBrandSoft];
        }
      });
      const themeColorSelectList = useThemeColorList();
      const update = (val) => {
        if (!isClient) return;
        const el = document.documentElement;
        themeColorName.value = val;
        if (el.getAttribute(themeColorAttribute) === val) return;
        el.setAttribute(themeColorAttribute, val);
        if (themeColorList.includes(val)) {
          clear();
          primaryColor.value = getComputedStyle(el).getPropertyValue(varNameList.vpBrand1);
        } else {
          const appendThemeColor = themeEnhanceConfig.value.themeColor?.append || [];
          const option = appendThemeColor.map((item) => item.options).flat().filter((item) => item.value === val);
          const color = option[0]?.color;
          !color && clear();
          primaryColor.value = color || getComputedStyle(el).getPropertyValue(varNameList.vpBrand1);
        }
        themeEnhanceConfig.value.themeColor?.switchColorDone?.(val);
      };
      Vue.watch(themeColorName, update, { immediate: true });
      Vue.watch(
        () => frontmatter.value.themeColorName,
        (newVal) => {
          if (newVal) {
            oldThemeColor.value = themeColorName.value;
            themeColorName.value = newVal;
          } else {
            themeColorName.value = oldThemeColor.value;
          }
        },
        { immediate: true }
      );
      Vue.onMounted(() => {
        if (frontmatter.value.themeColor) update(frontmatter.value.themeColor);
        else update(themeColorName.value);
      });
      const handleChangePrimaryColor = (option) => {
        themeColorName.value = option.value;
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1e), {
          class: Vue.normalizeClass(Vue.unref(ns).e("button")),
          "popper-class": Vue.unref(ns).e("dropdown"),
          placement: "left-start",
          width: 120,
          "x-offset": 15,
          "transition-name": Vue.unref(ns).join("fade-scale"),
          title: Vue.unref(t)("tk.themeEnhance.themeColor.title"),
          role: "button",
          "aria-label": Vue.unref(t)("tk.themeEnhance.themeColor.title")
        }, {
          reference: Vue.withCtx(() => [
            Vue.createVNode(Vue.unref(_sfc_main$1t), {
              icon: Vue.unref(magicIcon),
              "aria-hidden": "true"
            }, null, 8, ["icon"])
          ]),
          default: Vue.withCtx(() => [
            (Vue.openBlock(true), Vue.createElementBlock(
              Vue.Fragment,
              null,
              Vue.renderList(Vue.unref(themeColorSelectList), (item) => {
                return Vue.openBlock(), Vue.createElementBlock("ul", {
                  key: item.label
                }, [
                  Vue.createElementVNode("li", {
                    class: Vue.normalizeClass(`${Vue.unref(ns).e("dropdown__title")} sle`),
                    title: item.tip,
                    "aria-label": item.label
                  }, Vue.toDisplayString(item.label), 11, _hoisted_1$5),
                  Vue.createElementVNode("li", null, [
                    Vue.createElementVNode("ul", null, [
                      (Vue.openBlock(true), Vue.createElementBlock(
                        Vue.Fragment,
                        null,
                        Vue.renderList(item.options, (option) => {
                          return Vue.openBlock(), Vue.createElementBlock("li", {
                            key: item.label + option.value,
                            class: Vue.normalizeClass(["dropdown-item", "sle", { active: option.value === Vue.unref(themeColorName) }]),
                            onClick: ($event) => handleChangePrimaryColor(option),
                            role: "button",
                            title: option.title,
                            "aria-label": option.ariaLabel ?? option.title ?? option.label
                          }, Vue.toDisplayString(option.label), 11, _hoisted_2$4);
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      ))
                    ])
                  ])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["class", "popper-class", "transition-name", "title", "aria-label"]);
      };
    }
  });

  var _sfc_main$7 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "RightBottomButton" },
    __name: "index",
    setup(__props) {
      const { getTeekConfigRef } = useTeekConfig();
      const backTopConfig = getTeekConfigRef("backTop", { enabled: true });
      const toCommentConfig = getTeekConfigRef("toComment", { enabled: true });
      const themeEnhanceConfig = getTeekConfigRef("themeEnhance", { enabled: true });
      const teekConfig = getTeekConfigRef(null, { comment: { provider: "" } });
      const { frontmatter } = vitepress.useData();
      const commentConfig = Vue.computed(() => {
        const comment = frontmatter.value.comment ?? teekConfig.value.comment;
        if (isBoolean$1(comment)) return { enabled: comment };
        const getArtalkInstance = Vue.inject(artalkContext, null);
        const getGiscusInstance = Vue.inject(giscusContext, null);
        const getTwikooInstance = Vue.inject(twikooContext, null);
        const getWalineInstance = Vue.inject(walineContext, null);
        if (getArtalkInstance || getGiscusInstance || getTwikooInstance || getWalineInstance) {
          return { enabled: true };
        }
        return { enabled: true, provider: comment.provider };
      });
      const isMobile = useMediaQuery(mobileMaxWidthMedia);
      const disabledThemeColor = Vue.computed(() => {
        const { enabled = true, themeColor = {}, position = "top" } = themeEnhanceConfig.value;
        const isDisabled = themeColor.disabled ?? themeColor.disabledInMobile;
        if (!enabled) return true;
        if (isDisabled !== void 0) return isDisabled;
        return !isMobile.value && position === "top";
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).join("wallpaper-outside"), "flx-column"])
          },
          [
            Vue.renderSlot(_ctx.$slots, "teek-right-bottom-before"),
            Vue.unref(backTopConfig).enabled ? (Vue.openBlock(), Vue.createBlock(_sfc_main$a, { key: 0 }, {
              default: Vue.withCtx((scope) => [
                Vue.renderSlot(_ctx.$slots, "teek-back-top", Vue.normalizeProps(Vue.guardReactiveProps(scope)))
              ]),
              _: 3
              /* FORWARDED */
            })) : Vue.createCommentVNode("v-if", true),
            Vue.unref(toCommentConfig).enabled && (commentConfig.value.enabled || commentConfig.value.provider) ? (Vue.openBlock(), Vue.createBlock(_sfc_main$9, { key: 1 }, {
              default: Vue.withCtx((scope) => [
                Vue.renderSlot(_ctx.$slots, "teek-to-comment", Vue.normalizeProps(Vue.guardReactiveProps(scope)))
              ]),
              _: 3
              /* FORWARDED */
            })) : Vue.createCommentVNode("v-if", true),
            !disabledThemeColor.value ? (Vue.openBlock(), Vue.createBlock(_sfc_main$8, { key: 2 })) : Vue.createCommentVNode("v-if", true),
            Vue.renderSlot(_ctx.$slots, "teek-right-bottom-after")
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const _hoisted_1$4 = ["aria-label"];
  const _hoisted_2$3 = ["aria-label"];
  const _hoisted_3$2 = ["aria-label"];
  const _hoisted_4$2 = { class: "flx-align-center" };
  const _hoisted_5$2 = {
    id: "notice-title",
    class: "title sle"
  };
  const _hoisted_6$1 = ["aria-label"];
  var _sfc_main$6 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "Notice" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("notice");
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const vpRouter = useVpRouter();
      const { localeIndex } = vitepress.useData();
      const noticeConfig = getTeekConfigRef("notice", {
        noticeStyle: void 0,
        iconStyle: {},
        popoverStyle: {},
        title: t("tk.notice.title"),
        initOpen: true,
        duration: 0,
        mobileMinify: false,
        reopen: true,
        useStorage: true,
        twinkle: false,
        position: "top",
        noticeIcon,
        closeIcon,
        onAfterRouteChange: void 0
      });
      const destroyNoticeIcon = Vue.ref(false);
      const showNoticeIcon = Vue.computed(() => !showPopover.value && !destroyNoticeIcon.value);
      const showPopover = Vue.ref(noticeConfig.value.initOpen);
      Vue.watch(
        () => noticeConfig.value.initOpen,
        (newValue) => showPopover.value = newValue
      );
      const styleObj = Vue.computed(() => {
        const { noticeStyle } = noticeConfig.value;
        if (!noticeStyle) return "";
        return noticeStyle.trim().startsWith(`.${ns.b()}`) ? noticeStyle : `.${ns.b()} { ${noticeStyle} }`;
      });
      const noticeTitle = Vue.computed(() => {
        const { title } = noticeConfig.value;
        if (isString$1(title)) return title;
        return title(localeIndex.value);
      });
      const { isMobile } = useCommon();
      Vue.watch(
        () => noticeConfig.value.mobileMinify,
        (val) => {
          if (isMobile.value) destroyNoticeIcon.value = val;
        },
        { immediate: true }
      );
      let timer;
      const closePopoverWhenTimeout = () => {
        const { duration } = noticeConfig.value;
        if (showPopover.value && duration > 0) {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          timer = setTimeout(handleClosePopover, duration);
        }
      };
      Vue.onMounted(() => {
        vpRouter.bindAfterRouteChange(
          ns.join("notice"),
          () => noticeConfig.value.onAfterRouteChange?.(vpRouter.route, showNoticeIcon.value, showPopover.value)
        );
        closePopoverWhenTimeout();
      });
      const openOrDisableScroll = (action) => {
        if (!isClient) return;
        if (noticeConfig.value.position !== "center") return;
        const actions = {
          open: "remove",
          disable: "add"
        };
        document.documentElement.classList[actions[action]]("disable-scroll");
      };
      const storageKey = Vue.computed(() => ns.storageKey("notice", localeIndex.value, isClient ? window.location.hostname : ""));
      if (noticeConfig.value.useStorage) {
        Vue.watch(
          localeIndex,
          () => {
            if (!noticeConfig.value.useStorage) return;
            const oldValue = localStorage.getItem(storageKey.value);
            if (oldValue) {
              const isShowPopover = oldValue === "true";
              showPopover.value = isShowPopover;
              if (isShowPopover) openOrDisableScroll("disable");
            }
          },
          { immediate: true }
        );
      }
      const handleOpenPopover = () => {
        showPopover.value = true;
        storagePopoverState("true");
        closePopoverWhenTimeout();
        openOrDisableScroll("disable");
      };
      const handleClosePopover = () => {
        showPopover.value = false;
        storagePopoverState("false");
        if (!noticeConfig.value.reopen) destroyNoticeIcon.value = true;
        if (timer) clearTimeout(timer);
        openOrDisableScroll("open");
      };
      const storagePopoverState = (state) => {
        if (noticeConfig.value.useStorage) localStorage.setItem(storageKey.value, state);
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).join("wallpaper-outside")]),
          "aria-label": Vue.unref(t)("tk.notice.label")
        }, [
          styleObj.value ? (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent("style"), { key: 0 }, {
            default: Vue.withCtx(() => [
              Vue.createTextVNode(
                Vue.toDisplayString(styleObj.value),
                1
                /* TEXT */
              )
            ]),
            _: 1
            /* STABLE */
          })) : Vue.createCommentVNode("v-if", true),
          Vue.createCommentVNode(" \u516C\u544A\u56FE\u6807 "),
          !destroyNoticeIcon.value ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("div", {
            key: 1,
            class: Vue.normalizeClass([Vue.unref(ns).e("icon"), { twinkle: Vue.unref(noticeConfig).twinkle }, "flx"]),
            style: Vue.normalizeStyle(Vue.unref(noticeConfig).iconStyle),
            onClick: handleOpenPopover,
            role: "button",
            "aria-label": Vue.unref(t)("tk.notice.openLabel")
          }, [
            Vue.createVNode(Vue.unref(_sfc_main$1t), {
              icon: Vue.unref(noticeConfig).noticeIcon,
              color: "#ffffff",
              size: "14px",
              "aria-hidden": "true"
            }, null, 8, ["icon"])
          ], 14, _hoisted_2$3)), [
            [Vue.vShow, showNoticeIcon.value]
          ]) : Vue.createCommentVNode("v-if", true),
          Vue.createCommentVNode(" \u516C\u544A\u5F39\u7A97 "),
          Vue.withDirectives(Vue.createElementVNode(
            "div",
            {
              class: Vue.normalizeClass([Vue.unref(ns).e("popover"), Vue.unref(ns).is(Vue.unref(noticeConfig).position)]),
              style: Vue.normalizeStyle(Vue.unref(noticeConfig).popoverStyle),
              role: "dialog",
              "aria-modal": true,
              "aria-labelledby": "notice-title"
            },
            [
              Vue.renderSlot(_ctx.$slots, "header", {}, () => [
                Vue.createElementVNode("div", {
                  class: Vue.normalizeClass([Vue.unref(ns).e("popover__header"), "flx-justify-between"]),
                  "aria-label": Vue.unref(t)("tk.notice.headLabel")
                }, [
                  Vue.createElementVNode("div", _hoisted_4$2, [
                    Vue.createVNode(Vue.unref(_sfc_main$1t), {
                      icon: Vue.unref(noticeConfig).noticeIcon,
                      color: "#ffffff",
                      size: "20px",
                      "aria-hidden": "true"
                    }, null, 8, ["icon"]),
                    Vue.createElementVNode(
                      "span",
                      _hoisted_5$2,
                      Vue.toDisplayString(noticeTitle.value),
                      1
                      /* TEXT */
                    )
                  ]),
                  Vue.createVNode(Vue.unref(_sfc_main$1t), {
                    icon: Vue.unref(noticeConfig).closeIcon,
                    color: "#ffffff",
                    size: "20px",
                    class: Vue.normalizeClass(Vue.unref(ns).join("pointer")),
                    onClick: handleClosePopover,
                    role: "button",
                    "aria-label": Vue.unref(t)("tk.notice.closeLabel")
                  }, null, 8, ["icon", "class", "aria-label"])
                ], 10, _hoisted_3$2)
              ]),
              Vue.createElementVNode("div", {
                class: Vue.normalizeClass(Vue.unref(ns).e("popover__content")),
                "aria-label": Vue.unref(t)("tk.notice.contentLabel")
              }, [
                Vue.renderSlot(_ctx.$slots, "teek-notice-content")
              ], 10, _hoisted_6$1)
            ],
            6
            /* CLASS, STYLE */
          ), [
            [Vue.vShow, showPopover.value]
          ]),
          Vue.createCommentVNode(" \u906E\u7F69\u5C42\uFF0C\u4E0E\u516C\u544A\u5F39\u7A97\u4E00\u8D77\u51FA\u73B0 "),
          Vue.withDirectives(Vue.createElementVNode(
            "div",
            {
              class: Vue.normalizeClass(Vue.unref(ns).e("mask")),
              role: "presentation"
            },
            null,
            2
            /* CLASS */
          ), [
            [Vue.vShow, showPopover.value && Vue.unref(noticeConfig).position === "center"]
          ])
        ], 10, _hoisted_1$4);
      };
    }
  });

  const getLoginStorageKey = () => {
    if (!isClient) return { siteLoginKey: "", pagesLoginKey: "", pageLoginKey: "", realmLoginKey: "" };
    const ns = useNamespace();
    const siteLoginKey = ns.storageKey("private", "site", window.location.hostname);
    const pagesLoginKey = ns.storageKey("private", "pages", window.location.hostname);
    const pageLoginKey = ns.storageKey("private", "page", window.location.hostname);
    const realmLoginKey = ns.storageKey("private", "realm", window.location.hostname);
    return { siteLoginKey, pagesLoginKey, pageLoginKey, realmLoginKey };
  };
  const loginUrlKeyMap = {
    realm: "realm",
    toPath: "toPath",
    verifyMode: "verifyMode"
  };
  const verifyModeMap = {
    site: "site",
    pages: "pages",
    page: "page",
    realm: "realm"
  };
  const defaultPrivateConfig = {
    enabled: false,
    expire: "1d",
    session: false,
    siteLogin: false,
    site: [],
    pages: [],
    realm: {}
  };

  const _hoisted_1$3 = ["aria-label"];
  const _hoisted_2$2 = ["src"];
  const _hoisted_3$1 = ["src"];
  const _hoisted_4$1 = { class: "title" };
  const _hoisted_5$1 = { class: "flx-space-y-20 login-form" };
  const _hoisted_6 = ["for"];
  const _hoisted_7 = ["onUpdate:modelValue", "type", "placeholder", "onFocus", "onBlur"];
  const _hoisted_8 = ["aria-label"];
  const _hoisted_9 = ["aria-label"];
  var _sfc_main$5 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "LoginPage" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("login");
      const router = vitepress.useRouter();
      const { frontmatter } = vitepress.useData();
      const posts = usePosts();
      const { t } = useLocale();
      const { getTeekConfigRef } = useTeekConfig();
      const privateConfig = getTeekConfigRef("private", defaultPrivateConfig);
      const { siteLoginKey, pagesLoginKey, pageLoginKey, realmLoginKey } = getLoginStorageKey();
      const imgCode = Vue.ref("");
      const loginForm = Vue.reactive({
        username: {
          model: "",
          focusModel: false,
          errorModel: false,
          icon: userIcon,
          placeholder: t("tk.login.usernamePlaceholder"),
          type: "text"
        },
        password: {
          model: "",
          focusModel: false,
          errorModel: false,
          icon: lockIcon,
          placeholder: t("tk.login.passwordPlaceholder"),
          type: "password"
        },
        verifyCode: {
          model: "",
          focusModel: false,
          errorModel: false,
          icon: warningFilledIcon,
          placeholder: t("tk.login.verifyCodePlaceholder"),
          type: "text",
          append: Vue.markRaw(_sfc_main$19),
          appendModel: imgCode
        }
      });
      const checkLoginForm = () => {
        if (loginForm.verifyCode.model === "") {
          loginForm.verifyCode.errorModel = true;
          message.warning({ message: t("tk.login.verifyCodeNonNull"), plain: true });
          return false;
        }
        if (loginForm.verifyCode.model !== imgCode.value) {
          loginForm.verifyCode.errorModel = true;
          message.error({ message: t("tk.login.verifyCodeError"), plain: true });
          return false;
        }
        if (loginForm.username.model === "" || loginForm.password.model === "") {
          loginForm.username.errorModel = true;
          message.warning({ message: t("tk.login.loginInfoNonNull"), plain: true });
          return false;
        }
        if (loginForm.password.model === "") {
          loginForm.password.errorModel = true;
          message.warning({ message: t("tk.login.loginInfoNonNull"), plain: true });
          return false;
        }
        return true;
      };
      const getExpire = (expire) => {
        if (!expire) return 864e5;
        if (expire.indexOf("d") !== -1) return parseInt(expire.replace("d", "")) * 24 * 60 * 60 * 1e3;
        if (expire.indexOf("h") !== -1) return parseInt(expire.replace("h", "")) * 60 * 60 * 1e3;
        return parseInt(expire) * 1e3;
      };
      const resetForm = () => {
        Object.values(loginForm).forEach((form) => {
          form.model = "";
          form.focusModel = false;
        });
      };
      const getLoginHandler = () => {
        const { searchParams } = new URL(window.location.href);
        const verifyModeValue = searchParams.get(loginUrlKeyMap.verifyMode);
        const toPath = searchParams.get(loginUrlKeyMap.toPath);
        const realmValue = searchParams.get(loginUrlKeyMap.realm);
        const { site = [], pages = [], realm = {} } = privateConfig.value;
        return [
          {
            // 单页面级别登录
            condition: () => verifyModeValue === verifyModeMap.page && toPath,
            handle: () => execLogin([], pageLoginKey, { toPath })
          },
          {
            // 单页面级别登录
            condition: () => verifyModeValue === verifyModeMap.realm && realmValue,
            handle: () => execLogin(realm[realmValue] || [], realmLoginKey, { isRealm: true, realm: realmValue })
          },
          {
            // 全局页面级别登录
            condition: () => verifyModeValue === verifyModeMap.pages,
            handle: () => execLogin(pages, pagesLoginKey)
          },
          {
            // 站点级别登录
            condition: () => verifyModeValue === verifyModeMap.site,
            handle: () => execLogin(site, siteLoginKey, { isSite: true })
          }
        ].find((item) => item.condition());
      };
      const login = () => {
        if (!isClient) return;
        const { enabled = false } = privateConfig.value;
        if (!enabled) {
          message.success({ message: t("tk.login.loginSuccess"), plain: true });
          return router.go("/");
        }
        if (!checkLoginForm()) return;
        const { searchParams } = new URL(window.location.href);
        const toPath = searchParams.get(loginUrlKeyMap.toPath);
        let isLogin = false;
        const handler = getLoginHandler();
        if (handler) {
          const { doLogin } = privateConfig.value;
          const loginInfo = { username: loginForm.username.model, password: loginForm.password.model };
          const nativeLogin = handler.handle;
          isLogin = doLogin ? doLogin(loginInfo, "page", nativeLogin) : nativeLogin();
        }
        if (isLogin === void 0) return;
        if (isLogin) {
          message.success({ message: t("tk.login.loginSuccess"), plain: true });
          if (toPath) router.go(toPath);
        } else message.error({ message: t("tk.login.loginError"), plain: true });
      };
      const execLogin = (loginInfo, storageKey, options = {}) => {
        const { toPath } = options;
        if (toPath) return execSinglePageLogin(toPath, storageKey);
        const credential = loginInfo.find(
          (item) => item.username === loginForm.username.model && item.password === loginForm.password.model
        );
        if (!credential) return false;
        return storeLoginInfo(credential, storageKey, options);
      };
      const execSinglePageLogin = (toPath, storageKey) => {
        const post = posts.value.originPosts.find((post2) => [post2.frontmatter.permalink, post2.url].includes(toPath));
        if (!post) return false;
        const { username, password, session, expire, strategy, realm } = post.frontmatter || {};
        const loginInfoList = [
          ...post.frontmatter.loginInfo || [],
          { username, password, session, expire, strategy, realm }
        ].filter((item) => ![void 0, ""].includes(item.username) && ![void 0, ""].includes(item.password));
        const loginInfo = loginInfoList.find(
          (item) => item.username === loginForm.username.model && item.password === loginForm.password.model
        );
        if (loginInfo) {
          return storeLoginInfo({ ...loginInfo}, storageKey + post.url);
        }
        if (realm && privateConfig.value.realm) {
          const nativeLogin = () => execLogin(privateConfig.value.realm[realm], realmLoginKey, { isRealm: true, realm });
          return privateConfig.value.doLogin ? privateConfig.value.doLogin({ username, password }, "realm", nativeLogin) : nativeLogin();
        }
        return false;
      };
      const storeLoginInfo = (loginInfo, storageKey, options = {}) => {
        const { session, expire, strategy = "once", role = "common" } = loginInfo;
        const { isSite = false, isRealm = false, realm } = options;
        const storage = session || privateConfig.value.session ? sessionStorage : localStorage;
        const key = isRealm ? `${storageKey}${realm}` : storageKey;
        const encrypt = privateConfig.value.encrypt;
        try {
          storage.setItem(
            key,
            JSON.stringify({
              username: loginForm.username.model,
              password: encrypt ? encrypt(loginForm.password.model, frontmatter) : loginForm.password.model,
              loginTime: (/* @__PURE__ */ new Date()).getTime(),
              expire: strategy === "always" ? (/* @__PURE__ */ new Date()).getTime() + 30 * 1e3 : getExpire(expire || privateConfig.value.expire),
              strategy: strategy || "once",
              ...isSite && { role }
              // 站点级别登录信息需要存储角色，如果为 admin，代表后续有所有的文章页面权限
            })
          );
          return true;
        } catch (error) {
          console.error("[Teek Error] Failed to store credentials:", error);
          return false;
        }
      };
      const handleFocus = (item, formName) => {
        item.focusModel = true;
        item.errorModel = false;
        privateConfig.value.onFocus?.(item.model, formName);
      };
      const handleBlur = (item, formName) => {
        item.focusModel = false;
        if (item.model === "") item.errorModel = true;
        privateConfig.value.onBlur?.(item.model, formName);
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(Vue.unref(ns).b()),
          "aria-label": Vue.unref(t)("tk.login.label")
        }, [
          Vue.createElementVNode(
            "div",
            {
              class: Vue.normalizeClass(Vue.unref(ns).e("wrapper"))
            },
            [
              Vue.unref(frontmatter).leftImg ? (Vue.openBlock(), Vue.createElementBlock(
                "div",
                {
                  key: 0,
                  class: Vue.normalizeClass(Vue.unref(ns).e("left"))
                },
                [
                  Vue.createElementVNode("img", {
                    src: Vue.unref(vitepress.withBase)(Vue.unref(frontmatter).leftImg),
                    alt: "login"
                  }, null, 8, _hoisted_2$2)
                ],
                2
                /* CLASS */
              )) : Vue.createCommentVNode("v-if", true),
              Vue.createElementVNode(
                "div",
                {
                  class: Vue.normalizeClass(Vue.unref(ns).e("right"))
                },
                [
                  Vue.createElementVNode(
                    "div",
                    {
                      class: Vue.normalizeClass([Vue.unref(ns).e("right__header"), "flx-center"])
                    },
                    [
                      Vue.unref(frontmatter).logo ? (Vue.openBlock(), Vue.createElementBlock("img", {
                        key: 0,
                        src: Vue.unref(frontmatter).logo,
                        alt: "logo"
                      }, null, 8, _hoisted_3$1)) : Vue.createCommentVNode("v-if", true),
                      Vue.createElementVNode(
                        "span",
                        _hoisted_4$1,
                        Vue.toDisplayString(Vue.unref(frontmatter).name ?? "VitePress Theme Teek"),
                        1
                        /* TEXT */
                      )
                    ],
                    2
                    /* CLASS */
                  ),
                  Vue.createElementVNode("form", _hoisted_5$1, [
                    (Vue.openBlock(true), Vue.createElementBlock(
                      Vue.Fragment,
                      null,
                      Vue.renderList(loginForm, (item, key) => {
                        return Vue.openBlock(), Vue.createElementBlock("div", {
                          key,
                          class: "flx login-form-item"
                        }, [
                          Vue.createElementVNode(
                            "div",
                            {
                              class: Vue.normalizeClass([Vue.unref(ns).e("right__form"), Vue.unref(ns).is("focus", item.focusModel), Vue.unref(ns).is("error", item.errorModel)])
                            },
                            [
                              Vue.createVNode(Vue.unref(_sfc_main$1t), {
                                icon: item.icon
                              }, null, 8, ["icon"]),
                              Vue.createElementVNode("label", {
                                for: "input-" + key,
                                class: "sr-only"
                              }, Vue.toDisplayString(item.placeholder), 9, _hoisted_6),
                              Vue.withDirectives(Vue.createElementVNode("input", {
                                "onUpdate:modelValue": ($event) => item.model = $event,
                                type: item.type,
                                class: Vue.normalizeClass(Vue.unref(ns).em("right__form", "control")),
                                placeholder: item.placeholder,
                                onFocus: ($event) => handleFocus(item, key),
                                onBlur: ($event) => handleBlur(item, key),
                                onKeydown: Vue.withKeys(login, ["enter"])
                              }, null, 42, _hoisted_7), [
                                [Vue.vModelDynamic, item.model]
                              ])
                            ],
                            2
                            /* CLASS */
                          ),
                          item.append ? (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(item.append), {
                            key: 0,
                            modelValue: item.appendModel,
                            "onUpdate:modelValue": ($event) => item.appendModel = $event
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])) : Vue.createCommentVNode("v-if", true)
                        ]);
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    )),
                    Vue.createElementVNode(
                      "div",
                      {
                        class: Vue.normalizeClass(Vue.unref(ns).e("right__form__btn"))
                      },
                      [
                        Vue.createElementVNode("button", {
                          type: "button",
                          onClick: _cache[0] || (_cache[0] = ($event) => resetForm()),
                          class: "flx-center",
                          "aria-label": Vue.unref(t)("tk.login.reset")
                        }, [
                          Vue.createVNode(Vue.unref(_sfc_main$1t), { icon: Vue.unref(refreshRightIcon) }, null, 8, ["icon"]),
                          Vue.createElementVNode(
                            "span",
                            null,
                            Vue.toDisplayString(Vue.unref(t)("tk.login.reset")),
                            1
                            /* TEXT */
                          )
                        ], 8, _hoisted_8),
                        Vue.createElementVNode("button", {
                          type: "button",
                          onClick: _cache[1] || (_cache[1] = ($event) => login()),
                          class: "flx-center primary",
                          "aria-label": Vue.unref(t)("tk.login.login")
                        }, [
                          Vue.createVNode(Vue.unref(_sfc_main$1t), { icon: Vue.unref(successFilledIcon) }, null, 8, ["icon"]),
                          Vue.createElementVNode(
                            "span",
                            null,
                            Vue.toDisplayString(Vue.unref(t)("tk.login.login")),
                            1
                            /* TEXT */
                          )
                        ], 8, _hoisted_9)
                      ],
                      2
                      /* CLASS */
                    )
                  ])
                ],
                2
                /* CLASS */
              )
            ],
            2
            /* CLASS */
          )
        ], 10, _hoisted_1$3);
      };
    }
  });

  const useWatchLogin = () => {
    const router = vitepress.useRouter();
    const { frontmatter } = vitepress.useData();
    const { loginPath } = usePagePath();
    const { siteLoginKey, pagesLoginKey, pageLoginKey, realmLoginKey } = getLoginStorageKey();
    const { getTeekConfigRef } = useTeekConfig();
    const privateConfig = getTeekConfigRef("private", defaultPrivateConfig);
    const getLoginInfo = (key) => {
      const infoStr = localStorage.getItem(key) || sessionStorage.getItem(key);
      return infoStr ? JSON.parse(infoStr) : null;
    };
    const isValidCredential = (credentialList, loginInfo) => {
      const decrypt = privateConfig.value.decrypt;
      return credentialList.some(
        (item) => item.username === loginInfo.username && item.password === (decrypt ? decrypt(loginInfo.password, frontmatter) : loginInfo.password)
      );
    };
    const isLoginExpired = (loginInfo, key) => {
      const { expire, loginTime, strategy } = loginInfo;
      if (strategy === "always") {
        sessionStorage.removeItem(key);
        localStorage.removeItem(key);
      }
      return expire && loginTime && (/* @__PURE__ */ new Date()).getTime() - loginTime > expire;
    };
    const isLogin = (loginKey, credentialList, type) => {
      const nativeValidate = () => {
        const loginInfo = getLoginInfo(loginKey);
        return !!(loginInfo && isValidCredential(credentialList, loginInfo) && !isLoginExpired(loginInfo, loginKey));
      };
      return privateConfig.value.doValidate ? privateConfig.value.doValidate(type, frontmatter.value, nativeValidate) : nativeValidate();
    };
    const watchSite = () => {
      if (!isClient) return;
      if (!privateConfig.value.enabled) return;
      if (!privateConfig.value.siteLogin || !loginPath.value || router.route.data.frontmatter.loginPage) return;
      const { verifyMode, toPath } = loginUrlKeyMap;
      const goLogin = `${loginPath.value}?${verifyMode}=${verifyModeMap.site}&${toPath}=${window.location.href}`;
      if (!isLogin(siteLoginKey, privateConfig.value.site || [], "site")) router.go(goLogin);
    };
    const watchPages = () => {
      if (!isClient) return;
      if (!privateConfig.value.enabled) return;
      Vue.watch(
        router.route,
        (newVal) => {
          if (!privateConfig.value.enabled) return;
          if (!frontmatter.value.private || !loginPath.value || newVal.data.frontmatter.loginPage) return;
          if (isLogin(siteLoginKey, privateConfig.value.site || [], "site")) {
            const siteLoginInfo = getLoginInfo(siteLoginKey);
            if (siteLoginInfo.role === "admin") return;
          }
          const { verifyMode, toPath, realm: realmKey } = loginUrlKeyMap;
          const goLogin = `${loginPath.value}?${verifyMode}={verifyMode}&${toPath}=${newVal.path}`;
          const realm = frontmatter.value.privateRealm;
          const page = [
            ...frontmatter.value.loginInfo || [],
            { username: frontmatter.value.username, password: frontmatter.value.password }
          ].filter((item) => ![void 0, ""].includes(item.username) && ![void 0, ""].includes(item.password));
          if (page.length) {
            const path = "/" + newVal.data.filePath.replace(".md", "");
            const key = pageLoginKey + path;
            if (isLogin(key, page, "page") || isLogin(`${key}.html`, page, "page")) return;
          }
          if (realm) {
            const goRealm = goLogin.replace("{verifyMode}", verifyModeMap.realm) + `&${realmKey}=${realm}`;
            if (!isLogin(realmLoginKey + realm, privateConfig.value.realm[realm] || [], "realm")) router.go(goRealm);
            return;
          }
          if (page.length) {
            const goPage = goLogin.replace("{verifyMode}", verifyModeMap.page);
            return router.go(goPage);
          }
          const goPages = goLogin.replace("{verifyMode}", verifyModeMap.pages);
          if (!isLogin(pagesLoginKey, privateConfig.value.pages || [], "pages")) router.go(goPages);
        },
        { immediate: true }
      );
    };
    return { watchSite, watchPages };
  };

  const _hoisted_1$2 = ["src"];
  const _hoisted_2$1 = { key: 1 };
  var _sfc_main$4 = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "RiskLinkPage" },
    __name: "index",
    setup(__props) {
      const ns = useNamespace("risk-link");
      const { t } = useLocale();
      const { frontmatter } = vitepress.useData();
      const targetLink = Vue.ref("");
      Vue.onMounted(() => {
        const { searchParams } = new URL(window.location.href);
        const target = searchParams.get("target");
        if (target && isValidURL(target)) {
          targetLink.value = target;
        }
      });
      const confirmRedirect = () => {
        window.location.href = targetLink.value;
      };
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).join("center"), "flx-space-y-20"])
          },
          [
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass([Vue.unref(ns).e("header"), "flx-align-center"])
              },
              [
                Vue.unref(frontmatter).logo ? (Vue.openBlock(), Vue.createElementBlock("img", {
                  key: 0,
                  src: Vue.unref(frontmatter).logo,
                  alt: "logo"
                }, null, 8, _hoisted_1$2)) : Vue.createCommentVNode("v-if", true),
                targetLink.value ? (Vue.openBlock(), Vue.createElementBlock(
                  "p",
                  {
                    key: 1,
                    class: Vue.normalizeClass(Vue.unref(ns).e("title"))
                  },
                  Vue.toDisplayString(Vue.unref(frontmatter).desc ? Vue.unref(frontmatter).desc : Vue.unref(t)("tk.riskLink.title", { name: Vue.unref(frontmatter).name || "VitePress Theme Teek" })),
                  3
                  /* TEXT, CLASS */
                )) : (Vue.openBlock(), Vue.createElementBlock(
                  "p",
                  {
                    key: 2,
                    class: Vue.normalizeClass(Vue.unref(ns).e("title"))
                  },
                  Vue.toDisplayString(Vue.unref(frontmatter).linkIllegal ? Vue.unref(frontmatter).linkIllegal : Vue.unref(t)("tk.riskLink.linkIllegal")),
                  3
                  /* TEXT, CLASS */
                ))
              ],
              2
              /* CLASS */
            ),
            targetLink.value ? (Vue.openBlock(), Vue.createElementBlock(
              "p",
              {
                key: 0,
                class: Vue.normalizeClass([Vue.unref(ns).e("link"), "sle"])
              },
              Vue.toDisplayString(targetLink.value),
              3
              /* TEXT, CLASS */
            )) : Vue.createCommentVNode("v-if", true),
            targetLink.value ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$1, [
              Vue.createElementVNode(
                "button",
                {
                  class: "btn",
                  onClick: confirmRedirect
                },
                Vue.toDisplayString(Vue.unref(t)("tk.riskLink.confirmButtonText")),
                1
                /* TEXT */
              )
            ])) : Vue.createCommentVNode("v-if", true)
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  const useRiskLink = (options = {}) => {
    const riskLinks = /* @__PURE__ */ new Set();
    const cleanups = [];
    const { riskLinkPath } = usePagePath();
    const { whitelist = [], blacklist = [] } = options;
    const isSome = (arr, name) => {
      return arr.some(
        (item) => item === name || isString$1(item) && name.startsWith(item) || item instanceof RegExp && item.test(name)
      );
    };
    const isRiskLink = (url, currentDomain) => {
      const link = new URL(url, window.location.origin);
      return link.hostname !== currentDomain && !isSome(whitelist, url);
    };
    const start = async () => {
      await Vue.nextTick();
      if (!isClient) return;
      document.querySelectorAll("a").forEach((link) => {
        const href = link.getAttribute("href");
        const currentDomain = window.location.hostname;
        if (!href || riskLinks.has(link)) return;
        if (blacklist.length && !isSome(blacklist, href)) return;
        if (!isRiskLink(href, currentDomain)) return;
        riskLinks.add(link);
        const stop2 = useEventListener(link, "click", (e) => {
          e.preventDefault();
          const encodedUrl = encodeURIComponent(href);
          window.open(`${riskLinkPath.value}?target=${encodedUrl}`);
        });
        cleanups.push(stop2);
      });
    };
    const stop = () => {
      cleanups.forEach((fn) => fn());
      cleanups.length = 0;
      riskLinks.clear();
    };
    const restart = () => {
      stop();
      start();
    };
    useScopeDispose(stop);
    return { start, stop, restart };
  };

  const _hoisted_1$1 = ["title", "aria-label"];
  var _sfc_main$3 = /* @__PURE__ */ Vue.defineComponent({
    __name: "index",
    setup(__props) {
      const ns = useNamespace("sidebar-trigger");
      const { t } = useLocale();
      const active = Vue.ref(false);
      const isLt960 = useMediaQuery("(max-width: 960px)");
      const toggleSideBar = () => {
        const layoutDom = document.querySelector(`.${ns.join("layout")}`);
        layoutDom && layoutDom.classList.toggle(ns.is("sidebar-collapse"));
        if (!active.value) {
          active.value = true;
          setTimeout(() => {
            active.value = false;
          }, 300);
        }
      };
      Vue.onMounted(async () => {
        await Vue.nextTick();
        const docDom = document.querySelector(".VPContent.has-sidebar");
        docDom?.classList.add("sidebar-trigger-transition");
      });
      return (_ctx, _cache) => {
        return !Vue.unref(isLt960) ? Vue.renderSlot(_ctx.$slots, "default", {
          key: 0,
          active: active.value,
          icon: Vue.unref(autoWidthIcon),
          toggleSideBar
        }, () => [
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass([Vue.unref(ns).b(), Vue.unref(ns).is("active", active.value)]),
            onClick: toggleSideBar,
            title: Vue.unref(t)("tk.sidebarTrigger.label"),
            role: "button",
            "aria-label": Vue.unref(t)("tk.sidebarTrigger.label")
          }, [
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass([Vue.unref(ns).join("right-bottom-button__button")])
              },
              [
                Vue.createVNode(Vue.unref(_sfc_main$1t), {
                  icon: Vue.unref(autoWidthIcon),
                  "aria-hidden": "true"
                }, null, 8, ["icon"])
              ],
              2
              /* CLASS */
            )
          ], 10, _hoisted_1$1)
        ]) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  const _sfc_main$2 = {
    __name: "index",
    props: {
      "modelValue": { default: true },
      "modelModifiers": {}
    },
    emits: ["update:modelValue"],
    setup(__props) {
      const loading = Vue.useModel(__props, "modelValue");
      const ns = useNamespace("route-loading");
      const vpRouter = useVpRouter();
      const { getTeekConfigRef } = useTeekConfig();
      const loadingConfig = getTeekConfigRef("loading", false);
      const handleRouteStart = () => {
        if (!loading.value) loading.value = true;
      };
      const handleRouteComplete = () => {
        setTimeout(
          () => {
            if (loading.value) loading.value = false;
          },
          Math.floor(Math.random() * (500 - 460 + 1)) + 460
        );
      };
      vpRouter.bindBeforeRouteChange(
        "routeLoadingBefore",
        () => {
          handleRouteStart();
        },
        "before"
      );
      vpRouter.bindAfterRouteChange(
        "routeLoadingAfter",
        () => {
          handleRouteComplete();
        },
        "before"
      );
      Vue.watch(
        () => vpRouter.route.path,
        () => {
          handleRouteStart();
          handleRouteComplete();
        }
      );
      Vue.onBeforeMount(handleRouteStart);
      Vue.onMounted(handleRouteComplete);
      vitepress.onContentUpdated(handleRouteComplete);
      return (_ctx, _cache) => {
        return Vue.renderSlot(_ctx.$slots, "default", { loading: loading.value }, () => [
          Vue.createElementVNode(
            "div",
            {
              class: Vue.normalizeClass(Vue.unref(ns).b())
            },
            [
              Vue.createVNode(Vue.Transition, {
                name: Vue.unref(ns).join("fade"),
                mode: "out-in",
                persisted: ""
              }, {
                default: Vue.withCtx(() => [
                  Vue.withDirectives(Vue.createElementVNode(
                    "div",
                    {
                      class: Vue.normalizeClass(Vue.unref(ns).e("mask"))
                    },
                    [
                      Vue.createElementVNode(
                        "div",
                        {
                          class: Vue.normalizeClass(Vue.unref(ns).e("loader"))
                        },
                        [
                          Vue.createElementVNode(
                            "div",
                            {
                              class: Vue.normalizeClass(Vue.unref(ns).e("spinner"))
                            },
                            null,
                            2
                            /* CLASS */
                          ),
                          Vue.createElementVNode(
                            "p",
                            null,
                            Vue.toDisplayString(Vue.unref(isString$1)(Vue.unref(loadingConfig)) ? Vue.unref(loadingConfig) : "Teek \u62FC\u547D\u52A0\u8F7D\u4E2D ..."),
                            1
                            /* TEXT */
                          )
                        ],
                        2
                        /* CLASS */
                      )
                    ],
                    2
                    /* CLASS */
                  ), [
                    [Vue.vShow, loading.value]
                  ])
                ]),
                _: 1
                /* STABLE */
              }, 8, ["name"])
            ],
            2
            /* CLASS */
          )
        ]);
      };
    }
  };

  const _hoisted_1 = ["src"];
  const _hoisted_2 = {
    key: 0,
    class: "categories flx-center"
  };
  const _hoisted_3 = ["href", "title"];
  const _hoisted_4 = {
    key: 1,
    class: "tags flx-center"
  };
  const _hoisted_5 = ["href", "title"];
  var _sfc_main$1 = /* @__PURE__ */ Vue.defineComponent({
    __name: "index",
    setup(__props) {
      const loaded = Vue.ref(false);
      const ns = useNamespace("article-banner");
      const { frontmatter } = vitepress.useData();
      const route = vitepress.useRoute();
      const { hasSidebar } = useSidebar();
      const { isMobile } = useCommon();
      const { getTeekConfigRef } = useTeekConfig();
      const articleBannerConfig = getTeekConfigRef("articleBanner", {
        enabled: false,
        showCategory: true,
        showTag: true,
        defaultCoverImg: "",
        defaultCoverBgColor: ""
      });
      const postConfig = getTeekConfigRef("post", {
        defaultCoverImg: []
      });
      const imgSrc = Vue.computed(() => {
        const imgSrcList = [
          frontmatter.value.coverImg || articleBannerConfig.value.defaultCoverImg || postConfig.value.defaultCoverImg || []
        ].flat();
        if (!imgSrcList.length) return "";
        return imgSrcList[Math.floor(Math.random() * imgSrcList.length)];
      });
      const style = Vue.computed(() => {
        return {
          [ns.cssVarName("article-banner-bg-color")]: frontmatter.value.coverBgColor || articleBannerConfig.value.defaultCoverBgColor
        };
      });
      Vue.watch(
        () => route.path,
        async () => {
          await Vue.nextTick();
          loaded.value = true;
          setTimeout(() => loaded.value = false, 1);
        }
      );
      return (_ctx, _cache) => {
        return !Vue.unref(hasSidebar) && Vue.unref(articleBannerConfig).enabled ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock(
          "div",
          {
            key: 0,
            class: Vue.normalizeClass(Vue.unref(ns).b()),
            style: Vue.normalizeStyle(style.value)
          },
          [
            Vue.createElementVNode(
              "div",
              {
                class: Vue.normalizeClass([Vue.unref(ns).e("wrapper"), "flx-justify-center"])
              },
              [
                imgSrc.value ? (Vue.openBlock(), Vue.createElementBlock(
                  "div",
                  {
                    key: 0,
                    class: Vue.normalizeClass(Vue.unref(ns).e("cover"))
                  },
                  [
                    Vue.createElementVNode("img", {
                      src: imgSrc.value,
                      class: "no-preview",
                      alt: "cover"
                    }, null, 8, _hoisted_1)
                  ],
                  2
                  /* CLASS */
                )) : Vue.createCommentVNode("v-if", true),
                Vue.createElementVNode(
                  "div",
                  {
                    class: Vue.normalizeClass(Vue.unref(ns).e("info"))
                  },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-article-banner-info-top"),
                    !Vue.unref(isMobile) ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$15), { key: 0 })) : Vue.createCommentVNode("v-if", true),
                    Vue.createElementVNode(
                      "div",
                      {
                        class: Vue.normalizeClass([Vue.unref(ns).e("meta"), "flx-center flx-wrap"])
                      },
                      [
                        Vue.unref(frontmatter).categories && Vue.unref(articleBannerConfig).showCategory ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2, [
                          (Vue.openBlock(true), Vue.createElementBlock(
                            Vue.Fragment,
                            null,
                            Vue.renderList(Vue.unref(frontmatter).categories, (category) => {
                              return Vue.openBlock(), Vue.createElementBlock("a", {
                                key: category,
                                href: Vue.unref(vitepress.withBase)(`/categories?category=${category}`),
                                class: "meta-info category",
                                title: category
                              }, Vue.toDisplayString(category), 9, _hoisted_3);
                            }),
                            128
                            /* KEYED_FRAGMENT */
                          ))
                        ])) : Vue.createCommentVNode("v-if", true),
                        Vue.unref(frontmatter).tags && Vue.unref(articleBannerConfig).showTag ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_4, [
                          (Vue.openBlock(true), Vue.createElementBlock(
                            Vue.Fragment,
                            null,
                            Vue.renderList(Vue.unref(frontmatter).tags, (tag) => {
                              return Vue.openBlock(), Vue.createElementBlock("a", {
                                key: tag,
                                href: Vue.unref(vitepress.withBase)(`/tags?tag=${tag}`),
                                class: "meta-info tag",
                                title: tag
                              }, [
                                _cache[0] || (_cache[0] = Vue.createElementVNode(
                                  "span",
                                  null,
                                  "#",
                                  -1
                                  /* CACHED */
                                )),
                                Vue.createElementVNode(
                                  "span",
                                  null,
                                  Vue.toDisplayString(tag),
                                  1
                                  /* TEXT */
                                )
                              ], 8, _hoisted_5);
                            }),
                            128
                            /* KEYED_FRAGMENT */
                          ))
                        ])) : Vue.createCommentVNode("v-if", true)
                      ],
                      2
                      /* CLASS */
                    ),
                    Vue.createElementVNode(
                      "h1",
                      null,
                      Vue.toDisplayString(Vue.unref(frontmatter).title),
                      1
                      /* TEXT */
                    ),
                    Vue.createVNode(Vue.unref(_sfc_main$13), {
                      breadcrumb: false,
                      scope: "article-banner"
                    }),
                    Vue.renderSlot(_ctx.$slots, "teek-article-banner-info-bottom")
                  ],
                  2
                  /* CLASS */
                )
              ],
              2
              /* CLASS */
            ),
            Vue.createVNode(Vue.unref(_sfc_main$B))
          ],
          6
          /* CLASS, STYLE */
        )), [
          [Vue.vShow, !loaded.value]
        ]) : Vue.createCommentVNode("v-if", true);
      };
    }
  });

  var _sfc_main = /* @__PURE__ */ Vue.defineComponent({
    ...{ name: "TeekLayout" },
    __name: "index",
    props: {
      locale: {}
    },
    setup(__props) {
      const props = __props;
      Vue.provide(
        localeContextKey,
        Vue.computed(() => props.locale)
      );
      const { Layout } = DefaultTheme;
      const ns = useNamespace("layout");
      const { getTeekConfigRef } = useTeekConfig();
      const { isHomePage, isArchivesPage, isCataloguePage, isArticleOverviewPage } = usePageState();
      const { frontmatter, localeIndex, page } = vitepress.useData();
      const { hasSidebar } = useSidebar();
      const teekConfig = getTeekConfigRef(null, {
        teekTheme: true,
        teekHome: true,
        vpHome: true,
        sidebarTrigger: false,
        loading: false,
        codeBlock: { enabled: true },
        themeSize: "",
        bodyBgImg: {},
        notice: {},
        comment: { provider: "" },
        articleUpdate: { enabled: true },
        articleTopTip: void 0,
        articleBottomTip: void 0,
        articleShare: {},
        appreciation: {},
        riskLink: { enabled: false },
        themeEnhance: { enabled: true },
        articleBanner: { enabled: false },
        pageStyle: "default"
      });
      const loading = Vue.ref(teekConfig.value.loading);
      const commentConfig = Vue.computed(() => {
        const comment = frontmatter.value.comment ?? teekConfig.value.comment;
        if (isBoolean$1(comment)) return { enabled: comment };
        return {
          enabled: true,
          components: {
            twikoo: _sfc_main$O,
            waline: _sfc_main$N,
            giscus: _sfc_main$P,
            artalk: _sfc_main$Q
          },
          provider: comment.provider,
          options: comment.options
        };
      });
      const topTipConfig = Vue.computed(() => {
        if (isBoolean$1(teekConfig.value.articleTopTip)) return teekConfig.value.articleTopTip;
        return teekConfig.value.articleTopTip?.(frontmatter.value, localeIndex.value, page.value);
      });
      const bottomTipConfig = Vue.computed(() => {
        if (isBoolean$1(teekConfig.value.articleBottomTip)) return teekConfig.value.articleBottomTip;
        return teekConfig.value.articleBottomTip?.(frontmatter.value, localeIndex.value, page.value);
      });
      const showArticleBanner = Vue.computed(
        () => frontmatter.value.articleBanner !== false && teekConfig.value.articleBanner.enabled && !hasSidebar.value && frontmatter.value.article !== false && (!frontmatter.value.layout || frontmatter.value.layout === "doc") && teekConfig.value.pageStyle === "default"
      );
      const themeSizeAttribute = ns.join("theme-size");
      Vue.watch(
        () => teekConfig.value.themeSize,
        (newValue) => {
          if (!isClient) return;
          if (newValue) document.documentElement.setAttribute(themeSizeAttribute, newValue);
          else document.documentElement.removeAttribute(themeSizeAttribute);
        },
        { immediate: true, flush: "post" }
      );
      const { watchSite, watchPages } = useWatchLogin();
      const { restart } = useRiskLink({
        whitelist: teekConfig.value.riskLink.whitelist,
        blacklist: teekConfig.value.riskLink.blacklist
      });
      watchSite();
      watchPages();
      vitepress.onContentUpdated(() => {
        if (teekConfig.value.riskLink.enabled) restart();
      });
      const usedSlots = [
        "home-hero-before",
        "home-features-after",
        "nav-bar-content-after",
        "layout-top",
        "layout-bottom",
        "doc-footer-before",
        "doc-before",
        "doc-after",
        "aside-bottom",
        "page-top",
        "aside-outline-before",
        "sidebar-nav-before"
      ];
      return (_ctx, _cache) => {
        return Vue.unref(teekConfig).teekTheme ? (Vue.openBlock(), Vue.createElementBlock(
          Vue.Fragment,
          { key: 0 },
          [
            Vue.unref(teekConfig).loading ?? false ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$2), {
              key: 0,
              modelValue: loading.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => loading.value = $event)
            }, {
              default: Vue.withCtx((scope) => [
                Vue.renderSlot(_ctx.$slots, "teek-loading", Vue.normalizeProps(Vue.guardReactiveProps(scope)))
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["modelValue"])) : Vue.createCommentVNode("v-if", true),
            Vue.unref(frontmatter).loginPage === true ? Vue.renderSlot(_ctx.$slots, "teek-login-page", { key: 1 }, () => [
              Vue.withDirectives(Vue.createVNode(
                Vue.unref(_sfc_main$5),
                null,
                null,
                512
                /* NEED_PATCH */
              ), [
                [Vue.vShow, !loading.value]
              ])
            ]) : Vue.createCommentVNode("v-if", true),
            Vue.unref(frontmatter).riskLinkPage === true ? Vue.renderSlot(_ctx.$slots, "teek-risk-link-page", { key: 2 }, () => [
              Vue.withDirectives(Vue.createVNode(
                Vue.unref(_sfc_main$4),
                null,
                null,
                512
                /* NEED_PATCH */
              ), [
                [Vue.vShow, !loading.value]
              ])
            ]) : Vue.createCommentVNode("v-if", true),
            Vue.unref(frontmatter).layout !== false ? (Vue.openBlock(), Vue.createElementBlock(
              Vue.Fragment,
              { key: 3 },
              [
                Vue.unref(teekConfig).bodyBgImg?.imgSrc ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$V), { key: 0 })) : Vue.createCommentVNode("v-if", true),
                Vue.createVNode(Vue.unref(_sfc_main$$)),
                Vue.unref(teekConfig).notice?.enabled ? (Vue.openBlock(), Vue.createBlock(
                  Vue.unref(_sfc_main$6),
                  { key: 1 },
                  Vue.createSlots({
                    _: 2
                    /* DYNAMIC */
                  }, [
                    Vue.renderList(_ctx.$slots, (_, name) => {
                      return {
                        name,
                        fn: Vue.withCtx((scope) => [
                          Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(scope)))
                        ])
                      };
                    })
                  ]),
                  1024
                  /* DYNAMIC_SLOTS */
                )) : Vue.createCommentVNode("v-if", true),
                Vue.createVNode(
                  Vue.unref(_sfc_main$7),
                  null,
                  Vue.createSlots({
                    _: 2
                    /* DYNAMIC */
                  }, [
                    Vue.renderList(_ctx.$slots, (_, name) => {
                      return {
                        name,
                        fn: Vue.withCtx((scope) => [
                          Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(scope)))
                        ])
                      };
                    })
                  ]),
                  1024
                  /* DYNAMIC_SLOTS */
                )
              ],
              64
              /* STABLE_FRAGMENT */
            )) : Vue.createCommentVNode("v-if", true),
            Vue.withDirectives(Vue.createVNode(Vue.unref(Layout), {
              class: Vue.normalizeClass([
                Vue.unref(ns).b(),
                { [Vue.unref(ns).m("hide-vp-home")]: !Vue.unref(teekConfig).vpHome },
                Vue.unref(ns).has("sidebar-trigger", Vue.unref(teekConfig).sidebarTrigger)
              ])
            }, Vue.createSlots({
              "home-hero-before": Vue.withCtx(() => [
                Vue.renderSlot(_ctx.$slots, "home-hero-before"),
                Vue.renderSlot(_ctx.$slots, "teek-home-before"),
                Vue.createCommentVNode(" \u81EA\u5B9A\u4E49\u9996\u9875 "),
                Vue.unref(teekConfig).teekHome ? (Vue.openBlock(), Vue.createBlock(
                  Vue.unref(_sfc_main$p),
                  { key: 0 },
                  Vue.createSlots({
                    _: 2
                    /* DYNAMIC */
                  }, [
                    Vue.renderList(_ctx.$slots, (_, name) => {
                      return {
                        name,
                        fn: Vue.withCtx((scope) => [
                          Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(scope)))
                        ])
                      };
                    })
                  ]),
                  1024
                  /* DYNAMIC_SLOTS */
                )) : Vue.createCommentVNode("v-if", true),
                Vue.renderSlot(_ctx.$slots, "teek-home-after")
              ]),
              "home-features-after": Vue.withCtx(() => [
                !Vue.unref(teekConfig).teekHome ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 0 },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-home-features-before"),
                    Vue.createVNode(Vue.unref(_sfc_main$o)),
                    Vue.renderSlot(_ctx.$slots, "teek-home-features-after")
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true),
                Vue.renderSlot(_ctx.$slots, "home-features-after")
              ]),
              "nav-bar-content-after": Vue.withCtx(() => [
                Vue.renderSlot(_ctx.$slots, "nav-bar-content-after"),
                Vue.unref(teekConfig).themeEnhance.enabled ?? true ? (Vue.openBlock(), Vue.createBlock(
                  Vue.unref(_sfc_main$b),
                  { key: 0 },
                  Vue.createSlots({
                    _: 2
                    /* DYNAMIC */
                  }, [
                    Vue.renderList(_ctx.$slots, (_, name) => {
                      return {
                        name,
                        fn: Vue.withCtx((scope) => [
                          Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(scope)))
                        ])
                      };
                    })
                  ]),
                  1024
                  /* DYNAMIC_SLOTS */
                )) : Vue.createCommentVNode("v-if", true)
              ]),
              "layout-top": Vue.withCtx(() => [
                Vue.renderSlot(_ctx.$slots, "layout-top"),
                showArticleBanner.value ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 0 },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-article-banner-before"),
                    Vue.createVNode(
                      Vue.unref(_sfc_main$1),
                      null,
                      Vue.createSlots({
                        _: 2
                        /* DYNAMIC */
                      }, [
                        Vue.renderList(_ctx.$slots, (_, name) => {
                          return {
                            name,
                            fn: Vue.withCtx((scope) => [
                              Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(scope)))
                            ])
                          };
                        })
                      ]),
                      1024
                      /* DYNAMIC_SLOTS */
                    ),
                    Vue.renderSlot(_ctx.$slots, "teek-article-banner-after")
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true)
              ]),
              "layout-bottom": Vue.withCtx(() => [
                Vue.unref(isHomePage) ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 0 },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-footer-group-before"),
                    Vue.createVNode(Vue.unref(_sfc_main$L)),
                    Vue.renderSlot(_ctx.$slots, "teek-footer-group-after"),
                    Vue.renderSlot(_ctx.$slots, "teek-footer-info-before"),
                    Vue.renderSlot(_ctx.$slots, "teek-footer-info", {}, () => [
                      Vue.createVNode(Vue.unref(_sfc_main$K))
                    ]),
                    Vue.renderSlot(_ctx.$slots, "teek-footer-info-after")
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true),
                Vue.renderSlot(_ctx.$slots, "layout-bottom")
              ]),
              "sidebar-nav-before": Vue.withCtx(() => [
                Vue.createVNode(Vue.unref(_sfc_main$x))
              ]),
              "doc-before": Vue.withCtx(() => [
                Vue.renderSlot(_ctx.$slots, "doc-before"),
                Vue.unref(frontmatter).article !== false && !showArticleBanner.value ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 0 },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-article-analyze-before"),
                    Vue.createVNode(Vue.unref(_sfc_main$13)),
                    Vue.renderSlot(_ctx.$slots, "teek-article-analyze-after")
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true),
                Vue.createVNode(Vue.unref(_sfc_main$_)),
                Vue.createVNode(Vue.unref(_sfc_main$Y)),
                Vue.unref(teekConfig).codeBlock.enabled ?? true ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$R), { key: 1 })) : Vue.createCommentVNode("v-if", true),
                topTipConfig.value ? (Vue.openBlock(), Vue.createBlock(
                  Vue.unref(_sfc_main$18),
                  Vue.normalizeProps(Vue.mergeProps({ key: 2 }, Vue.unref(isBoolean$1)(topTipConfig.value) ? {} : topTipConfig.value)),
                  null,
                  16
                  /* FULL_PROPS */
                )) : Vue.createCommentVNode("v-if", true),
                Vue.unref(teekConfig).sidebarTrigger ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$3), { key: 3 }, {
                  default: Vue.withCtx((scope) => [
                    Vue.renderSlot(_ctx.$slots, "teek-sidebar-trigger", Vue.normalizeProps(Vue.guardReactiveProps(scope)))
                  ]),
                  _: 3
                  /* FORWARDED */
                })) : Vue.createCommentVNode("v-if", true)
              ]),
              "doc-footer-before": Vue.withCtx(() => [
                Vue.renderSlot(_ctx.$slots, "doc-footer-before"),
                bottomTipConfig.value ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 0 },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-article-bottom-tip-before"),
                    Vue.createVNode(
                      Vue.unref(_sfc_main$18),
                      Vue.normalizeProps(Vue.guardReactiveProps(Vue.unref(isBoolean$1)(bottomTipConfig.value) ? {} : bottomTipConfig.value)),
                      null,
                      16
                      /* FULL_PROPS */
                    ),
                    Vue.renderSlot(_ctx.$slots, "teek-article-bottom-tip-after")
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true)
              ]),
              "doc-after": Vue.withCtx(() => [
                Vue.renderSlot(_ctx.$slots, "doc-after"),
                (Vue.unref(teekConfig).articleUpdate.enabled ?? true) && Vue.unref(frontmatter).articleUpdate !== false ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 0 },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-doc-update-before"),
                    Vue.createVNode(Vue.unref(_sfc_main$W)),
                    Vue.renderSlot(_ctx.$slots, "teek-doc-update-after")
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true),
                ["doc-after", "doc-after-popper"].includes(Vue.unref(teekConfig).appreciation.position) ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 1 },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-doc-after-appreciation-before"),
                    Vue.unref(teekConfig).appreciation.position === "doc-after" ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$11), { key: 0 })) : Vue.unref(teekConfig).appreciation.position === "doc-after-popper" ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$10), { key: 1 })) : Vue.createCommentVNode("v-if", true),
                    Vue.renderSlot(_ctx.$slots, "teek-doc-after-appreciation-after")
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true),
                Vue.createCommentVNode(" \u8BC4\u8BBA\u533A "),
                commentConfig.value.enabled && commentConfig.value.provider ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 2 },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-comment-before"),
                    commentConfig.value.provider === "render" ? Vue.renderSlot(_ctx.$slots, "teek-comment", { key: 0 }) : (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(commentConfig.value.components?.[commentConfig.value.provider]), {
                      key: 1,
                      id: `${Vue.unref(ns).namespace}-comment`,
                      class: Vue.normalizeClass(Vue.unref(ns).e("comment"))
                    }, null, 8, ["id", "class"])),
                    Vue.renderSlot(_ctx.$slots, "teek-comment-after")
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true)
              ]),
              "aside-bottom": Vue.withCtx(() => [
                Vue.renderSlot(_ctx.$slots, "aside-bottom"),
                Vue.unref(teekConfig).appreciation.position === "aside-bottom" ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 0 },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-aside-bottom-appreciation-before"),
                    Vue.createVNode(Vue.unref(_sfc_main$12)),
                    Vue.renderSlot(_ctx.$slots, "teek-aside-bottom-appreciation-after")
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true)
              ]),
              "page-top": Vue.withCtx(() => [
                Vue.renderSlot(_ctx.$slots, "page-top"),
                Vue.unref(isArchivesPage) || Vue.unref(isCataloguePage) || Vue.unref(isArticleOverviewPage) ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 0 },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-page-top-before"),
                    Vue.unref(isArchivesPage) ? (Vue.openBlock(), Vue.createBlock(
                      Vue.unref(_sfc_main$16),
                      { key: 0 },
                      Vue.createSlots({
                        _: 2
                        /* DYNAMIC */
                      }, [
                        Vue.renderList(_ctx.$slots, (_, name) => {
                          return {
                            name,
                            fn: Vue.withCtx((scope) => [
                              Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(scope)))
                            ])
                          };
                        })
                      ]),
                      1024
                      /* DYNAMIC_SLOTS */
                    )) : Vue.unref(isCataloguePage) ? (Vue.openBlock(), Vue.createBlock(
                      Vue.unref(_sfc_main$T),
                      { key: 1 },
                      Vue.createSlots({
                        _: 2
                        /* DYNAMIC */
                      }, [
                        Vue.renderList(_ctx.$slots, (_, name) => {
                          return {
                            name,
                            fn: Vue.withCtx((scope) => [
                              Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(scope)))
                            ])
                          };
                        })
                      ]),
                      1024
                      /* DYNAMIC_SLOTS */
                    )) : Vue.unref(isArticleOverviewPage) ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$Z), { key: 2 })) : Vue.createCommentVNode("v-if", true),
                    Vue.renderSlot(_ctx.$slots, "teek-page-top-after")
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true)
              ]),
              "aside-outline-before": Vue.withCtx(() => [
                Vue.unref(teekConfig).articleShare.enabled ? (Vue.openBlock(), Vue.createElementBlock(
                  Vue.Fragment,
                  { key: 0 },
                  [
                    Vue.renderSlot(_ctx.$slots, "teek-article-share-before"),
                    Vue.createVNode(Vue.unref(_sfc_main$X)),
                    Vue.renderSlot(_ctx.$slots, "teek-article-share-after")
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : Vue.createCommentVNode("v-if", true),
                Vue.renderSlot(_ctx.$slots, "aside-outline-before")
              ]),
              _: 2
              /* DYNAMIC */
            }, [
              Vue.renderList(Object.keys(_ctx.$slots).filter((name) => !usedSlots.includes(name)), (name) => {
                return {
                  name,
                  fn: Vue.withCtx((slotData) => [
                    Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(slotData)))
                  ])
                };
              })
            ]), 1032, ["class"]), [
              [Vue.vShow, !loading.value]
            ])
          ],
          64
          /* STABLE_FRAGMENT */
        )) : (Vue.openBlock(), Vue.createBlock(
          Vue.unref(Layout),
          { key: 1 },
          Vue.createSlots({
            _: 2
            /* DYNAMIC */
          }, [
            Vue.renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: Vue.withCtx((slotData) => [
                  Vue.renderSlot(_ctx.$slots, name, Vue.normalizeProps(Vue.guardReactiveProps(slotData)))
                ])
              };
            })
          ]),
          1024
          /* DYNAMIC_SLOTS */
        ));
      };
    }
  });

  if (typeof window !== "undefined")
    window._iconfont_svg_string_4999519 = '<svg><symbol id="icon-douban" viewBox="0 0 1024 1024"><path d="M88.217 73.083l847.533 0 0 95.469-847.533 0 0-95.469Z" fill="#4D4D4D" ></path><path d="M862.075 641.362l0-373.22L161.892 268.142l0 373.22L862.075 641.362zM263.428 363.545l498.134 0 0 182.463L263.428 546.008 263.428 363.545z" fill="#4D4D4D" ></path><path d="M710.62 856.486c30.466-46.638 59.218-100.728 85.858-162.12l-101.865-37.128c-26.493 72.754-57.338 139.273-92.437 199.248L424.922 856.486c-29.377-77.73-62.53-144.202-99.722-199.248l-93.688 37.128c38.642 57.963 69.8 111.921 93.688 162.12L64.246 856.486l0 94.431 895.508 0 0-94.431L710.62 856.486z" fill="#4D4D4D" ></path></symbol><symbol id="icon-xiangce" viewBox="0 0 1024 1024"><path d="M513.397 501.102l-61.56-65.869-159.849 187.326-65.53-59.897-95.316 121.795h664.567v-121.795l-156.221-225.054-126.091 163.496zM272.162 399.877c44.245 0 80.11-35.868 80.11-80.127 0-44.244-35.867-80.111-80.11-80.111s-80.111 35.869-80.111 80.111c0.001 44.259 35.869 80.127 80.111 80.127zM892.856 716.212c-0.179-48.454 0-465.122 0-505.692s-22.72-63.382-63.543-63.543-686.469 0-729.94 0-63.751 28.511-63.543 63.543 0 469.455 0 505.692 20.147 63.718 63.543 63.544 688.258 0.922 729.94 0.991 63.721-16.082 63.543-64.535zM99.372 719.207v-508.686h730.746v508.687h-730.746zM988.168 305.835c0.010-50.66-45.982-63.543-63.543-63.543l0.806 484.19c0 0 14.241 87.046-51.287 87.046l-743.002-0.014c0 17.545 12.79 63.461 63.544 63.543s678.355 0.005 729.939 0 63.634-26.251 63.543-65.53-0.008-455.032 0-505.692z" fill="#272636" ></path></symbol><symbol id="icon-telegram" viewBox="0 0 1024 1024"><path d="M417.28 795.733333 429.226667 615.253333 756.906667 320C771.413333 306.773333 753.92 300.373333 734.72 311.893333L330.24 567.466667 155.306667 512C117.76 501.333333 117.333333 475.306667 163.84 456.533333L845.226667 193.706667C876.373333 179.626667 906.24 201.386667 894.293333 249.173333L778.24 795.733333C770.133333 834.56 746.666667 843.946667 714.24 826.026667L537.6 695.466667 452.693333 777.813333C442.88 787.626667 434.773333 795.733333 417.28 795.733333Z"  ></path></symbol><symbol id="icon-rss" viewBox="0 0 1024 1024"><path d="M329.142857 768q0 45.714286-32 77.714286t-77.714286 32-77.714286-32-32-77.714286 32-77.714286 77.714286-32 77.714286 32 32 77.714286zm292.571429 70.285714q1.142857 16-9.714286 27.428571-10.285714 12-26.857143 12l-77.142857 0q-14.285714 0-24.571429-9.428571t-11.428571-23.714286q-12.571429-130.857143-105.428571-223.714286t-223.714286-105.428571q-14.285714-1.142857-23.714286-11.428571t-9.428571-24.571429l0-77.142857q0-16.571429 12-26.857143 9.714286-9.714286 24.571429-9.714286l2.857143 0q91.428571 7.428571 174.857143 46t148 103.714286q65.142857 64.571429 103.714286 148t46 174.857143zm292.571429 1.142857q1.142857 15.428571-10.285714 26.857143-10.285714 11.428571-26.285714 11.428571l-81.714286 0q-14.857143 0-25.428571-10t-11.142857-24.285714q-6.857143-122.857143-57.714286-233.428571t-132.285714-192-192-132.285714-233.428571-58.285714q-14.285714-0.571429-24.285714-11.142857t-10-24.857143l0-81.714286q0-16 11.428571-26.285714 10.285714-10.285714 25.142857-10.285714l1.714286 0q149.714286 7.428571 286.571429 68.571429t243.142857 168q106.857143 106.285714 168 243.142857t68.571429 286.571429z"  ></path></symbol><symbol id="icon-weixin" viewBox="0 0 1024 1024"><path d="M664.250054 368.541681c10.015098 0 19.892049 0.732687 29.67281 1.795902-26.647917-122.810047-159.358451-214.077703-310.826188-214.077703-169.353083 0-308.085774 114.232694-308.085774 259.274068 0 83.708494 46.165436 152.460344 123.281791 205.78483l-30.80868 91.730191 107.688651-53.455469c38.558178 7.53665 69.459978 15.308661 107.924012 15.308661 9.66308 0 19.230993-0.470721 28.752858-1.225921-6.025227-20.36584-9.521864-41.723264-9.521864-63.862493C402.328693 476.632491 517.908058 368.541681 664.250054 368.541681zM498.62897 285.87389c23.200398 0 38.557154 15.120372 38.557154 38.061874 0 22.846334-15.356756 38.156018-38.557154 38.156018-23.107277 0-46.260603-15.309684-46.260603-38.156018C452.368366 300.994262 475.522716 285.87389 498.62897 285.87389zM283.016307 362.090758c-23.107277 0-46.402843-15.309684-46.402843-38.156018 0-22.941502 23.295566-38.061874 46.402843-38.061874 23.081695 0 38.46301 15.120372 38.46301 38.061874C321.479317 346.782098 306.098002 362.090758 283.016307 362.090758zM945.448458 606.151333c0-121.888048-123.258255-221.236753-261.683954-221.236753-146.57838 0-262.015505 99.348706-262.015505 221.236753 0 122.06508 115.437126 221.200938 262.015505 221.200938 30.66644 0 61.617359-7.609305 92.423993-15.262612l84.513836 45.786813-23.178909-76.17082C899.379213 735.776599 945.448458 674.90216 945.448458 606.151333zM598.803483 567.994292c-15.332197 0-30.807656-15.096836-30.807656-30.501688 0-15.190981 15.47546-30.477129 30.807656-30.477129 23.295566 0 38.558178 15.286148 38.558178 30.477129C637.361661 552.897456 622.099049 567.994292 598.803483 567.994292zM768.25071 567.994292c-15.213493 0-30.594809-15.096836-30.594809-30.501688 0-15.190981 15.381315-30.477129 30.594809-30.477129 23.107277 0 38.558178 15.286148 38.558178 30.477129C806.808888 552.897456 791.357987 567.994292 768.25071 567.994292z" fill="#272636" ></path></symbol><symbol id="icon-Youtube" viewBox="0 0 1024 1024"><path d="M960 509.2c0-2.2 0-4.7-0.1-7.6-0.1-8.1-0.3-17.2-0.5-26.9-0.8-27.9-2.2-55.7-4.4-81.9-3-36.1-7.4-66.2-13.4-88.8-12.8-47.9-50.4-85.6-98.3-98.5-28.3-7.6-83.7-12.3-161.7-15.2-37.1-1.4-76.8-2.3-116.5-2.8-13.9-0.2-26.8-0.3-38.4-0.4H497.3c-11.6 0.1-24.5 0.2-38.4 0.4-39.7 0.5-79.4 1.4-116.5 2.8-78 3-133.5 7.7-161.7 15.2-47.8 12.8-85.5 50.5-98.3 98.5-6.1 22.6-10.4 52.7-13.4 88.8-2.2 26.2-3.6 54-4.4 81.9-0.3 9.7-0.4 18.8-0.5 26.9 0 2.9-0.1 5.4-0.1 7.6v5.6c0 2.2 0 4.7 0.1 7.6 0.1 8.1 0.3 17.2 0.5 26.9 0.8 27.9 2.2 55.7 4.4 81.9 3 36.1 7.4 66.2 13.4 88.8 12.8 47.9 50.4 85.7 98.3 98.5 28.2 7.6 83.7 12.3 161.7 15.2 37.1 1.4 76.8 2.3 116.5 2.8 13.9 0.2 26.8 0.3 38.4 0.4H526.7c11.6-0.1 24.5-0.2 38.4-0.4 39.7-0.5 79.4-1.4 116.5-2.8 78-3 133.5-7.7 161.7-15.2 47.9-12.8 85.5-50.5 98.3-98.5 6.1-22.6 10.4-52.7 13.4-88.8 2.2-26.2 3.6-54 4.4-81.9 0.3-9.7 0.4-18.8 0.5-26.9 0-2.9 0.1-5.4 0.1-7.6V512v-2.8z m-72 5.2c0 2.1 0 4.4-0.1 7.1-0.1 7.8-0.3 16.4-0.5 25.7-0.7 26.6-2.1 53.2-4.2 77.9-2.7 32.2-6.5 58.6-11.2 76.3-6.2 23.1-24.4 41.4-47.4 47.5-21 5.6-73.9 10.1-145.8 12.8-36.4 1.4-75.6 2.3-114.7 2.8-13.7 0.2-26.4 0.3-37.8 0.3h-28.6c-11.4-0.1-24.1-0.2-37.8-0.3-39.1-0.5-78.2-1.4-114.7-2.8-71.9-2.8-124.9-7.2-145.8-12.8-23-6.2-41.2-24.4-47.4-47.5-4.7-17.7-8.5-44.1-11.2-76.3-2.1-24.7-3.4-51.3-4.2-77.9-0.3-9.3-0.4-18-0.5-25.7 0-2.7-0.1-5.1-0.1-7.1v-3-1.8c0-2.1 0-4.4 0.1-7.1 0.1-7.8 0.3-16.4 0.5-25.7 0.7-26.6 2.1-53.2 4.2-77.9 2.7-32.2 6.5-58.6 11.2-76.3 6.2-23.1 24.4-41.4 47.4-47.5 21-5.6 73.9-10.1 145.8-12.8 36.4-1.4 75.6-2.3 114.7-2.8 13.7-0.2 26.4-0.3 37.8-0.3h28.6c11.4 0.1 24.1 0.2 37.8 0.3 39.1 0.5 78.2 1.4 114.7 2.8 71.9 2.8 124.9 7.2 145.8 12.8 23 6.2 41.2 24.4 47.4 47.5 4.7 17.7 8.5 44.1 11.2 76.3 2.1 24.7 3.4 51.3 4.2 77.9 0.3 9.3 0.4 18 0.5 25.7 0 2.7 0.1 5.1 0.1 7.1v4.8z"  ></path><path d="M423 646l232-135-232-133z"  ></path></symbol><symbol id="icon-QQ" viewBox="0 0 1024 1024"><path d="M824.8 613.2c-16-51.4-34.4-94.6-62.7-165.3C766.5 262.2 689.3 112 511.5 112 331.7 112 256.2 265.2 261 447.9c-28.4 70.8-46.7 113.7-62.7 165.3-34 109.5-23 154.8-14.6 155.8 18 2.2 70.1-82.4 70.1-82.4 0 49 25.2 112.9 79.8 159-26.4 8.1-85.7 29.9-71.6 53.8 11.4 19.3 196.2 12.3 249.5 6.3 53.3 6 238.1 13 249.5-6.3 14.1-23.8-45.3-45.7-71.6-53.8 54.6-46.2 79.8-110.1 79.8-159 0 0 52.1 84.6 70.1 82.4 8.5-1.1 19.5-46.4-14.5-155.8z"  ></path></symbol><symbol id="icon-weibo" viewBox="0 0 1024 1024"><path d="M457.3 543c-68.1-17.7-145 16.2-174.6 76.2-30.1 61.2-1 129.1 67.8 151.3 71.2 23 155.2-12.2 184.4-78.3 28.7-64.6-7.2-131-77.6-149.2z m-52 156.2c-13.8 22.1-43.5 31.7-65.8 21.6-22-10-28.5-35.7-14.6-57.2 13.7-21.4 42.3-31 64.4-21.7 22.4 9.5 29.6 35 16 57.3z m45.5-58.5c-5 8.6-16.1 12.7-24.7 9.1-8.5-3.5-11.2-13.1-6.4-21.5 5-8.4 15.6-12.4 24.1-9.1 8.7 3.2 11.8 12.9 7 21.5zM785.3 443.5c15 4.8 31-3.4 35.9-18.3 11.8-36.6 4.4-78.4-23.2-109-27.6-30.6-68.4-42.3-106-34.3-15.4 3.3-25.2 18.4-21.9 33.8 3.3 15.3 18.4 25.2 33.8 21.8 18.4-3.9 38.3 1.8 51.9 16.7 13.5 15 17.2 35.4 11.3 53.3-4.9 15.1 3.2 31.1 18.2 36z"  ></path><path d="M885.1 237.5c-56.7-62.9-140.4-86.9-217.7-70.5-17.9 3.8-29.3 21.4-25.4 39.3 3.8 17.9 21.4 29.3 39.3 25.5 55-11.7 114.4 5.4 154.8 50.1 40.3 44.7 51.2 105.7 34 159.1-5.6 17.4 3.9 36 21.3 41.7 17.4 5.6 36-3.9 41.6-21.2v-0.1c24.1-75.4 8.9-161.1-47.9-223.9zM729 499c-12.2-3.6-20.5-6.1-14.1-22.1 13.8-34.7 15.2-64.7 0.3-86-28-40.1-104.8-37.9-192.8-1.1 0 0-27.6 12.1-20.6-9.8 13.5-43.5 11.5-79.9-9.6-101-47.7-47.8-174.6 1.8-283.5 110.6C127.3 471.1 80 557.5 80 632.2 80 775.1 263.2 862 442.5 862c235 0 391.3-136.5 391.3-245 0-65.5-55.2-102.6-104.8-118zM443 810.8c-143 14.1-266.5-50.5-275.8-144.5-9.3-93.9 99.2-181.5 242.2-195.6 143-14.2 266.5 50.5 275.8 144.4C694.4 709 586 796.6 443 810.8z"  ></path></symbol><symbol id="icon-yuque" viewBox="0 0 1024 1024"><path d="M903.542857 350.4c-11.314286-45.028571 11.314286-116.8 83.885714-142.171429l-77.6-4.114285s-29.371429-102.857143-164.114285-112c-134.742857-9.257143-222.857143-3.428571-222.857143-3.428572s99.885714 63.542857 59.885714 176.8c-29.257143 60-75.2 109.257143-124.342857 165.371429-1.485714 1.485714-2.857143 2.971429-4 4.228571C291.885714 618.285714 36.571429 909.714286 36.571429 909.714286c281.028571 73.6 469.371429-7.2 580.8-104.114286 23.428571-0.228571 41.028571-0.342857 52.914285-0.342857 155.2 0 286.4-134.4 281.028572-283.885714-3.657143-102.742857-36.457143-125.942857-47.771429-170.971429z"  ></path></symbol><symbol id="icon-vex" viewBox="0 0 1026 1024"><path d="M511.5 0.5C229.01 0.5 0 229.51 0 512s229.01 511.5 511.5 511.5c282.491 0 511.501-229.01 511.501-511.5S793.991 0.5 511.501 0.5z m-85.03 377.489c22.235 5.844 36.918 17.244 45.324 35.064 9.697 20.382 7.128 46.75-6.27 67.132-8.696 13.4-24.23 27.084-55.876 49.462-6.27 4.56-14.966 11.26-19.244 15.252l-7.837 6.982 48.89 0.146h48.746l-0.283 25.229-0.429 25.37h-188.15l0.43-4.99c0.854-7.554 5.698-22.38 11.26-33.64 10.262-21.376 30.218-41.904 69.843-72.122 35.92-27.51 46.181-42.19 40.194-57.728-3.273-8.835-14.25-15.963-24.513-16.107-6.274 0-14.683 3.137-19.1 7.412-3.564 3.423-8.982 16.393-8.982 21.808 0 1.853-0.426 3.706-0.998 3.992-1.567 0.998-61.574-3.992-62.715-5.13-1.71-1.712 2.422-19.812 6.986-30.79 8.835-21.092 28.218-35.06 54.591-39.338 18.1-2.994 53.167-1.857 68.133 1.996z m-287.788 16.106c2.854 8.836 13.971 44.612 24.802 79.394 10.978 34.778 20.099 62.714 20.528 61.999 0.426-0.708 11.543-36.345 24.802-79.394l23.944-77.966h71.982l-2.85 7.415c-1.567 4.131-20.239 54.734-41.621 112.32l-38.914 104.764-38.341 0.286-38.484 0.426-42.05-111.322c-23.09-61.29-42.19-112.036-42.476-112.605-0.283-0.712 16.25-1.284 36.634-1.284h37.06l4.984 15.967z m542.501 8.267v24.23h-116.88v34.21l53.88 0.282 53.732 0.43 0.433 23.089 0.283 23.235-53.736 0.286-53.883 0.426v42.762l59.441 0.426 59.438 0.29 0.43 20.238 0.425 20.095 34.778-52.309c19.105-28.794 34.782-53.024 34.782-54.022 0-0.998-15.395-25.371-34.352-54.166-18.958-28.933-34.496-52.88-34.496-53.164 0-0.286 17.534-0.572 38.913-0.572h38.77l19.101 33.498c10.548 18.246 19.67 33.069 20.095 32.783 0.573-0.43 9.268-15.392 19.248-33.495l18.385-32.786h38.198c20.957 0 38.205 0.286 38.205 0.715 0 0.426-15.395 24.803-34.213 54.166-18.815 29.216-34.21 53.593-34.21 54.162 0 0.429 16.536 25.94 36.778 56.73 20.238 30.79 37.343 56.73 37.916 57.585 0.854 1.427-7.272 1.853-38.631 1.853h-39.768l-21.237-34.918c-11.829-19.248-21.808-34.782-22.38-34.496-0.709 0.143-10.545 15.677-22.235 34.496l-21.096 34.206-131.417 0.429-131.42 0.283v-225.21h186.723v24.233z" fill="#4D5256" ></path></symbol><symbol id="icon-csdn" viewBox="0 0 1141 1024"><path d="M1141.350889 39.056096l-28.912998 218.474979c-126.144988-19.927998-251.600975-38.376996-377.754963-27.674997-115.459989 9.802999-227.405978 32.180997-309.12497 122.987988C275.539973 519.540049 357.166965 749.305027 583.810943 790.307023c141.114986 25.525998 283.919972 11.784999 425.447958-8.122999-5.451999 112.439989-5.764999 95.302991-10.674999 205.22998-1.074 24.056998 4.277 14.611999-161.648984 31.913996-176.003983 9.003999-351.879966 11.188999-520.549949-52.887994-159.839984-60.717994-285.709972-157.279985-311.20797-335.624968C-21.074998 447.220056 53.979995 299.020071 197.693981 184.687082 413.36896 13.098099 790.802923-47.269895 1141.349889 39.056096z" fill="#5B5C5C" ></path></symbol><symbol id="icon-facebook" viewBox="0 0 1024 1024"><path d="M725.333333 149.333333a21.333333 21.333333 0 0 0-21.333333-21.333333H597.333333a203.52 203.52 0 0 0-213.333333 192v115.2H277.333333a21.333333 21.333333 0 0 0-21.333333 21.333333v110.933334a21.333333 21.333333 0 0 0 21.333333 21.333333H384v285.866667a21.333333 21.333333 0 0 0 21.333333 21.333333h128a21.333333 21.333333 0 0 0 21.333334-21.333333v-285.866667h111.786666a21.333333 21.333333 0 0 0 20.906667-15.786667l30.72-110.933333a21.333333 21.333333 0 0 0-20.48-26.88H554.666667V320a42.666667 42.666667 0 0 1 42.666666-38.4h106.666667a21.333333 21.333333 0 0 0 21.333333-21.333333z"  ></path></symbol><symbol id="icon-youjian" viewBox="0 0 1024 1024"><path d="M128 300.608V736a32 32 0 0 0 32 32h704a32 32 0 0 0 32-32V300.64l-316.96 308.064a96 96 0 0 1-133.76 0L128 300.608zM850.08 256H173.92l315.936 306.816a32 32 0 0 0 44.576 0L850.08 256zM160 192h704a96 96 0 0 1 96 96v448a96 96 0 0 1-96 96H160a96 96 0 0 1-96-96V288a96 96 0 0 1 96-96z" fill="#333333" ></path></symbol><symbol id="icon-sf" viewBox="0 0 1024 1024"><path d="M248.83399566 943.35207538c-37.14984163-5.00781966-73.59961088-14.5226752-99.63004928-26.02532864C109.7137152 899.88113977 72.53832363 875.11798557 72.53832363 866.24699165c0-4.12378567 5.74877241-17.68066731 12.77504853-30.12867528l25.66762837-45.45362375 12.8925787-22.83156707 26.71007176 20.31743772c28.99425053 22.04973397 69.56780544 39.38803029 102.84936306 43.94616832 49.36278813 6.76566585 89.93634304-20.47584825 89.93634304-60.38510137 0-27.66564579-18.15589888-44.08413867-72.6849172-65.74040064-57.69722994-22.90821689-89.05231019-38.76971747-117.1829669-59.27111566-83.37507783-60.75813205-84.02405035-195.09032391-1.25195491-258.70495744 69.11301405-53.11354311 209.25529771-58.94407509 309.9277915-12.89768846 24.68139463 11.28803328 34.49263104 18.49827101 34.49263218 25.34058667 0 12.16184661-45.22367203 102.67562211-50.04753123 100.17171228-60.60994105-31.48282994-104.03999744-43.05191367-140.86279738-37.52798322-41.86127929 6.27510386-60.94209251 33.52172771-46.940639 67.03323591 8.47241216 20.27655737 19.60203491 27.04222322 87.10539264 52.96024121 92.44025287 35.48908544 125.18014749 58.48928256 149.77467051 105.22041116 11.78370503 22.38188544 13.45468189 31.56970041 13.47512206 74.09528264 0.02044018 39.63842105-2.11043783 53.23107328-11.59974457 74.09528263-21.46208199 47.1552603-66.17986275 81.85740174-125.89555029 97.67802311-27.36415403 7.25622784-97.98973326 12.5348773-122.84486884 9.18781497z m390.91649195-237.04358457V481.33988352h-71.54027292V358.69941533h70.6766791l1.79872655-85.59282632c2.10532807-100.37100317 9.21336491-123.44274034 49.69493959-161.30798592 34.0480603-31.8456411 66.19519203-41.87149995 133.33062884-41.58533859 63.87524381 0.27594069 127.75048761 16.35206258 127.7504876 32.15224263 0 5.00781966-6.98028715 28.50879829-15.50890894 52.23462002-8.53373269 23.72071083-16.47981341 45.93396509-17.66022713 49.35256746-1.64542578 4.75231801-6.39774493 4.44571648-20.09770667-1.27750485-9.86744718-4.12378567-28.36571819-7.49639907-41.10499726-7.49639794-41.65687865 0-53.74207545 24.97266574-53.78806556 111.14292338L803.27111111 358.69941533h112.42042937v122.64046819h-112.25179819l1.19063438 223.56335275 1.19574415 223.56335274-83.03781661 1.40525454-83.0378166 1.40525568z"  ></path></symbol><symbol id="icon-juejin" viewBox="0 0 1024 1024"><path d="M605.8 73.28L512 0 410.38 81.1 512 162.2l102.6-81.1-8.8-7.82zM958.53 358.6L512 710.35 66.44 358.6 0 411.36 512 814.9l512-403.54-65.47-52.76zM512 386.93L268.7 195.42l-65.46 52.76L512 491.48l308.76-243.3-65.46-52.76L512 386.93z" fill="#666666" ></path></symbol><symbol id="icon-douyin" viewBox="0 0 1024 1024"><path d="M937.4 423.9c-84 0-165.7-27.3-232.9-77.8v352.3c0 179.9-138.6 325.6-309.6 325.6S85.3 878.3 85.3 698.4c0-179.9 138.6-325.6 309.6-325.6 17.1 0 33.7 1.5 49.9 4.3v186.6c-15.5-6.1-32-9.2-48.6-9.2-76.3 0-138.2 65-138.2 145.3 0 80.2 61.9 145.3 138.2 145.3 76.2 0 138.1-65.1 138.1-145.3V0H707c0 134.5 103.7 243.5 231.6 243.5v180.3l-1.2 0.1"  ></path></symbol><symbol id="icon-cnblogs-grey" viewBox="0 0 1024 1024"><path d="M851.40363594 172.59636406c-187.46181844-187.46181844-491.34545437-187.46181844-678.80727188 0-187.46181844 187.46181844-187.46181844 491.34545437 0 678.80727188 187.46181844 187.46181844 491.34545437 187.46181844 678.80727188 0 187.46181844-187.46181844 187.46181844-491.34545437 0-678.80727188zM387.33090875 728.08727281a47.08363594 47.08363594 0 1 1-66.63272719-66.50181843 47.08363594 47.08363594 0 0 1 66.63272719 66.50181843z m205.52727281 1.39636313a38.74909125 38.74909125 0 0 1-76.62545437-11.52h-0.04363594a6.54545437 6.54545437 0 0 0-0.04363688 0.30545531v-0.34909125c0.30545438-2.61818156 2.05090875-20.72727281-2.96727281-44.98909125a174.24 174.24 0 0 0-48.56727281-89.28 172.10181844 172.10181844 0 0 0-88.8-48.30545438 156.69818156 156.69818156 0 0 0-42.45818156-2.92363593 38.66181844 38.66181844 0 0 1-35.38909125-65.32363688 38.61818156 38.61818156 0 0 1 21.12-10.8218175v-0.2181825c4.45090875-0.74181844 111.14181844-16.45090875 200.33454562 72.74181844 89.01818156 89.01818156 74.18181844 196.14545438 73.44 200.72727281z m175.2 7.59272812a38.74909125 38.74909125 0 0 1-65.67272719 21.3818175 39.49090875 39.49090875 0 0 1-11.65090875-33.73090875c0.08727281-0.34909125 5.10545437-37.48363594-5.06181843-88.97454562-13.30909125-67.37454562-45.29454563-126.89454563-94.95272719-176.90181844-50.00727281-49.70181844-109.52727281-81.64363594-176.94545438-94.95272719-51.49090875-10.16727281-88.58181844-5.19272719-89.01818156-5.14909031h0.21818156-0.04363687a39.92727281 39.92727281 0 0 1-44.68363594-32.90181844 38.83636406 38.83636406 0 0 1 32.20363594-44.37818156c1.92-0.30545438 47.86909125-7.33090875 111.27272719 4.36363594a411.75272719 411.75272719 0 0 1 106.25454562 34.95272718 425.76 425.76 0 0 1 114.63272719 82.25454563l0.91636406 0.96 0.96 0.87272719a425.89090875 425.89090875 0 0 1 82.25454563 114.72c16.40727281 33.6 28.14545437 69.29454562 34.99636312 106.21090875 11.65090875 63.40363594 4.66909125 109.35272719 4.32 111.27272812z" fill="#515151" ></path></symbol><symbol id="icon-github" viewBox="0 0 1024 1024"><path d="M20.48 503.72608c0 214.4256 137.4208 396.73856 328.94976 463.6672 25.8048 6.5536 21.87264-11.8784 21.87264-24.33024v-85.07392c-148.93056 17.44896-154.86976-81.1008-164.94592-97.52576-20.23424-34.52928-67.91168-43.33568-53.69856-59.76064 33.91488-17.44896 68.48512 4.42368 108.46208 63.61088 28.95872 42.88512 85.44256 35.6352 114.15552 28.4672a138.8544 138.8544 0 0 1 38.0928-66.7648c-154.25536-27.60704-218.60352-121.77408-218.60352-233.79968 0-54.31296 17.94048-104.2432 53.0432-144.54784-22.36416-66.43712 2.08896-123.24864 5.3248-131.6864 63.81568-5.7344 130.00704 45.6704 135.168 49.68448 36.2496-9.78944 77.57824-14.9504 123.82208-14.9504 46.4896 0 88.064 5.3248 124.5184 15.23712 12.288-9.4208 73.80992-53.53472 133.12-48.128 3.15392 8.43776 27.0336 63.93856 6.02112 129.4336 35.59424 40.38656 53.69856 90.76736 53.69856 145.24416 0 112.18944-64.7168 206.4384-219.42272 233.71776a140.0832 140.0832 0 0 1 41.7792 99.9424v123.4944c0.86016 9.87136 0 19.6608 16.50688 19.6608 194.31424-65.49504 334.2336-249.15968 334.2336-465.5104C1002.57792 232.48896 782.66368 12.77952 511.5904 12.77952 240.18944 12.65664 20.48 232.40704 20.48 503.72608z" fill="#000000" opacity=".65" ></path></symbol><symbol id="icon-jianshu" viewBox="0 0 1024 1024"><path d="M128.136693 85.066578c-15.031766 32.141093-39.341675 73.086156-58.50901 98.53017l-38.862614 51.606618c-5.313668 7.049043-0.459508 11.678338 38.535093 36.750834l44.616236 28.680121 13.824336-16.737811c7.60143-9.204818 25.458678-34.810148 39.678974-56.895844L193.269457 186.842631l27.780658-0.171093L248.830774 186.500445l24.177923 40.329128c13.30128 22.183464 28.025077 48.028325 32.72281 57.438454 4.702621 9.41013 9.033725 17.691044 9.625218 18.399859 0.591494 0.713703 22.242125-6.711745 48.111427-16.493391l47.035984-17.783923-12.9982-22.613642c-7.151699-12.436036-18.116333-30.312839-24.363681-39.722969l-11.360594-17.109327 63.617366-1.363857L489.016393 186.216919V93.621242H240.144124l7.166364-20.316104c3.944922-11.174835 6.535763-20.946705 5.768287-21.71418C251.631815 50.143998 161.714969 30.072313 156.684827 30.072313c-1.554505 0-14.401165 24.749863-28.548134 54.994265m449.48646-35.567846c-8.813748 29.423154-51.015124 111.049308-75.676997 146.392289l-21.904827 31.383394 10.598006 7.928951C506.619446 247.16523 565.113791 284.268027 567.983269 284.268027c3.182335 0 33.006336-44.078515 50.438296-74.547781L631.70818 186.500445h65.259861l20.149899 32.996559c11.081955 18.150552 24.828078 42.348028 30.552369 53.77217 5.724292 11.42903 11.531686 20.775611 12.910209 20.775611 5.396771 0 83.102445-30.796788 87.223349-34.565728 2.493073-2.282873-4.350657-17.925686-15.887232-36.330434-11.145504-17.779035-20.26722-33.299639-20.26722-34.487515 0-1.187876 31.896674-2.160664 70.881497-2.160663H953.412409V93.621242h-283.657975l7.401006-17.70571c4.067131-9.737651 7.396118-19.441084 7.396118-21.56264C684.551558 50.789264 603.575558 30.072313 589.633901 30.072313c-3.4072 0-8.808859 8.740422-12.010748 19.426419M182.109287 288.476922l-35.606954 23.31268 10.607783 9.459013c13.227954 11.795659 80.844014 87.06692 97.396066 108.419361l12.294273 15.86279 36.560188-24.740087c20.105903-13.604359 37.181012-26.446131 37.933822-28.538357 3.182335-8.794194-110.394266-128.129305-121.138923-127.283616-1.344304 0.107544-18.463408 10.685997-38.046255 23.508216M420.579086 352.646674v48.825131l186.980501 1.280755 186.980501 1.280756v225.085416c0 274.937107 6.535763 251.531548-70.246008 251.531548h-52.906927l12.582688 46.439601 12.587576 46.439602 63.656473-0.371517c82.330081-0.479061 102.978595-8.080491 125.499357-46.190294l11.482803-19.431307 1.363857-301.857411 1.368746-301.85741H420.579086v48.82513M92.568847 690.003494c-0.268861 145.18486-0.713703 270.024286-0.987453 277.415515l-0.498615 13.443043 52.315434 1.388299 52.315433 1.3883V426.031022H93.057685l-0.488838 263.972472m207.844103-220.382796c-1.124327 1.119439-2.043342 91.857532-2.043342 201.645639V870.873521h196.757259l196.75726 0.004889V467.582244h-194.713917c-107.09461 0-195.632932 0.919015-196.75726 2.038454M591.672355 589.791722v36.662844H401.025569v-73.325687h190.646786v36.662843m0 156.428132v36.662843H401.025569v-73.325686h190.646786v36.662843"  ></path></symbol><symbol id="icon-npm" viewBox="0 0 1024 1024"><path d="M116 116v792h792V116H116z m643.008 643.008h-99.008V364H512v395.008H264.992V264.992h494.016v494.016z"  ></path></symbol><symbol id="icon-bilibili" viewBox="0 0 1024 1024"><path d="M977.2 208.2c33.4 36.2 48.8 79.4 46.6 131.4v404.8c-0.8 52.8-18.4 96.2-53 130.2-34.4 34-78.2 51.8-131 53.4H184.04c-52.9-1.6-96.42-19.6-130.56-54.4C19.364 838.8 1.534 793 0 736.4V339.6c1.534-52 19.364-95.2 53.48-131.4C87.62 175.5 131.14 157.54 184.04 156h58.76L192.1 104.38c-11.5-11.46-17.26-26-17.26-43.58 0-17.6 5.76-32.12 17.26-43.594C203.6 5.736 218.2 0 235.8 0s32.2 5.736 43.8 17.206L426.2 156h176l149-138.794C763.4 5.736 778.4 0 796 0c17.6 0 32.2 5.736 43.8 17.206 11.4 11.474 17.2 25.994 17.2 43.594 0 17.58-5.8 32.12-17.2 43.58L789.2 156h58.6c52.8 1.54 96 19.5 129.4 52.2z m-77.6 139.4c-0.8-19.2-7.4-34.8-21.4-47-10.4-12.2-28-18.8-45.4-19.6H192.1c-19.18 0.8-34.9 7.4-47.16 19.6-12.28 12.2-18.8 27.8-19.56 47v388.8c0 18.4 6.52 34 19.56 47s28.76 19.6 47.16 19.6H832.8c18.4 0 34-6.6 46.6-19.6 12.6-13 19.4-28.6 20.2-47V347.6z m-528.6 85.4c12.6 12.6 19.4 28.2 20.2 46.4V546c-0.8 18.4-7.4 33.8-19.6 46.4-12.4 12.6-28 19-47.2 19-19.2 0-35-6.4-47.2-19-12.2-12.6-18.8-28-19.6-46.4v-66.6c0.8-18.2 7.6-33.8 20.2-46.4 12.6-12.6 26.4-19.2 46.6-20 18.4 0.8 34 7.4 46.6 20z m383 0c12.6 12.6 19.4 28.2 20.2 46.4V546c-0.8 18.4-7.4 33.8-19.6 46.4-12.2 12.6-28 19-47.2 19-19.2 0-34.8-6.4-47.2-19-14-12.6-18.8-28-19.4-46.4v-66.6c0.6-18.2 7.4-33.8 20-46.4 12.6-12.6 28.2-19.2 46.6-20 18.4 0.8 34 7.4 46.6 20z"  ></path></symbol><symbol id="icon-zhihu" viewBox="0 0 1024 1024"><path d="M371.19130859 535.02506511h169.58144532c0-39.87421875-18.79804688-63.22851562-18.79804688-63.22851563H374.80097656c3.49541016-72.23115234 6.62783203-164.93466797 7.74931641-199.36669922h139.99394531s-0.75849609-59.24003906-16.32832031-59.24003906H260.140625s14.81044922-77.46855469 34.55771484-111.66855469c0 0-73.48095703-3.96386719-98.54472656 94.00957032s-62.65810547 157.21523437-66.64570312 168.03808593c-3.98671875 10.82197266 21.64570313 5.12578125 32.46855468 0 10.82197266-5.12666016 59.80957031-22.78564453 74.05048829-91.1390625h76.08691406c1.02480469 43.31777344 4.04033203 176.07568359 3.08935547 199.36669922H158.55751953c-22.21523437 15.94951172-29.62001953 63.22851562-29.62001953 63.22851563h179.04023438c-7.46806641 49.44287109-20.58134766 113.17060547-38.91357422 146.96191406C240.01367187 735.52994792 224.6328125 784.51842448 119.82324219 868.82135417c0 0-17.08769531 12.53144531 35.88574219 7.97519531 52.97519531-4.55712891 103.10097656-18.22851563 137.84765625-87.72099609 18.06503906-36.12919922 36.74355469-81.95888672 51.31669921-128.44248047l-0.04833984 0.16347656 147.5296875 169.8600586s19.36757813-45.56953125 5.12666016-95.6953125L388.11464844 612.49186198l-37.02392578 27.38496094-0.03955078 0.13271484c10.28320313-36.05273438 17.6765625-71.69677734 19.97490234-102.70810547 0.05449219-0.74619141 0.11074219-1.50820312 0.16523437-2.27812499zM576.08896484 200.65748698v587.84765625h61.80292969l25.31865235 70.76337891 107.11757812-70.76337891h135v-587.84765625H576.08984375z m265.63271485 524.61914063h-70.16923828l-87.52148438 57.81708984-20.6859375-57.81621094h-21.84521484V266.25904948h200.22099609v459.01757813z" fill="#515151" ></path></symbol><symbol id="icon-tuite" viewBox="0 0 1024 1024"><path d="M761.759375 122h132.320625L605 452.4003125 945.08 902H678.8L470.24 629.3196875 231.599375 902H99.2l309.1996875-353.4L82.16 122h273.0403125l188.52 249.24z m-46.4390625 700.8h73.32L315.359375 197.0403125h-78.680625z" fill="#2c2c2c" ></path></symbol><symbol id="icon-gitee" viewBox="0 0 1024 1024"><path d="M512 1024q-104 0-199-40-92-39-163-110T40 711Q0 616 0 512t40-199Q79 221 150 150T313 40q95-40 199-40t199 40q92 39 163 110t110 163q40 95 40 199t-40 199q-39 92-110 163T711 984q-95 40-199 40z m259-569H480q-10 0-17.5 7.5T455 480v64q0 10 7.5 17.5T480 569h177q11 0 18.5 7.5T683 594v13q0 31-22.5 53.5T607 683H367q-11 0-18.5-7.5T341 657V417q0-31 22.5-53.5T417 341h354q11 0 18-7t7-18v-63q0-11-7-18t-18-7H417q-38 0-72.5 14T283 283q-27 27-41 61.5T228 417v354q0 11 7 18t18 7h373q46 0 85.5-22.5t62-62Q796 672 796 626V480q0-10-7-17.5t-18-7.5z"  ></path></symbol></svg>', ((l) => {
      var c = (t = (t = document.getElementsByTagName("script"))[t.length - 1]).getAttribute("data-injectcss"), t = t.getAttribute("data-disable-injectsvg");
      if (!t) {
        var o, i, e, a, h, n = function(c2, t2) {
          t2.parentNode.insertBefore(c2, t2);
        };
        if (c && !l.__iconfont__svg__cssinject__) {
          l.__iconfont__svg__cssinject__ = true;
          try {
            document.write(
              "<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>"
            );
          } catch (c2) {
            console && console.log(c2);
          }
        }
        o = function() {
          var c2, t2 = document.createElement("div");
          t2.innerHTML = l._iconfont_svg_string_4999519, (t2 = t2.getElementsByTagName("svg")[0]) && (t2.setAttribute("aria-hidden", "true"), t2.style.position = "absolute", t2.style.width = 0, t2.style.height = 0, t2.style.overflow = "hidden", t2 = t2, (c2 = document.body).firstChild ? n(t2, c2.firstChild) : c2.appendChild(t2));
        }, document.addEventListener ? ~["complete", "loaded", "interactive"].indexOf(document.readyState) ? setTimeout(o, 0) : (i = function() {
          document.removeEventListener("DOMContentLoaded", i, false), o();
        }, document.addEventListener("DOMContentLoaded", i, false)) : document.attachEvent && (e = o, a = l.document, h = false, d(), a.onreadystatechange = function() {
          "complete" == a.readyState && (a.onreadystatechange = null, s());
        });
      }
      function s() {
        h || (h = true, e());
      }
      function d() {
        try {
          a.documentElement.doScroll("left");
        } catch (c2) {
          return void setTimeout(d, 50);
        }
        s();
      }
    })(window);

  // Process block-level custom containers
  //
  function container_plugin (md, name, options) {
    // Second param may be useful if you decide
    // to increase minimal allowed marker length
    function validateDefault (params/*, markup */) {
      return params.trim().split(' ', 2)[0] === name
    }

    function renderDefault (tokens, idx, _options, env, slf) {
      // add a class to the opening tag
      if (tokens[idx].nesting === 1) {
        tokens[idx].attrJoin('class', name);
      }

      return slf.renderToken(tokens, idx, _options, env, slf)
    }

    options = options || {};

    const min_markers = 3;
    const marker_str  = options.marker || ':';
    const marker_char = marker_str.charCodeAt(0);
    const marker_len  = marker_str.length;
    const validate    = options.validate || validateDefault;
    const render      = options.render || renderDefault;

    function container (state, startLine, endLine, silent) {
      let pos;
      let auto_closed = false;
      let start = state.bMarks[startLine] + state.tShift[startLine];
      let max = state.eMarks[startLine];

      // Check out the first character quickly,
      // this should filter out most of non-containers
      //
      if (marker_char !== state.src.charCodeAt(start)) { return false }

      // Check out the rest of the marker string
      //
      for (pos = start + 1; pos <= max; pos++) {
        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {
          break
        }
      }

      const marker_count = Math.floor((pos - start) / marker_len);
      if (marker_count < min_markers) { return false }
      pos -= (pos - start) % marker_len;

      const markup = state.src.slice(start, pos);
      const params = state.src.slice(pos, max);
      if (!validate(params, markup)) { return false }

      // Since start is found, we can report success here in validation mode
      //
      if (silent) { return true }

      // Search for the end of the block
      //
      let nextLine = startLine;

      for (;;) {
        nextLine++;
        if (nextLine >= endLine) {
          // unclosed block should be autoclosed by end of document.
          // also block seems to be autoclosed by end of parent
          break
        }

        start = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];

        if (start < max && state.sCount[nextLine] < state.blkIndent) {
          // non-empty line with negative indent should stop the list:
          // - ```
          //  test
          break
        }

        if (marker_char !== state.src.charCodeAt(start)) { continue }

        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          // closing fence should be indented less than 4 spaces
          continue
        }

        for (pos = start + 1; pos <= max; pos++) {
          if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {
            break
          }
        }

        // closing code fence must be at least as long as the opening one
        if (Math.floor((pos - start) / marker_len) < marker_count) { continue }

        // make sure tail has spaces only
        pos -= (pos - start) % marker_len;
        pos = state.skipSpaces(pos);

        if (pos < max) { continue }

        // found!
        auto_closed = true;
        break
      }

      const old_parent = state.parentType;
      const old_line_max = state.lineMax;
      state.parentType = 'container';

      // this will prevent lazy continuations from ever going past our end marker
      state.lineMax = nextLine;

      const token_o  = state.push('container_' + name + '_open', 'div', 1);
      token_o.markup = markup;
      token_o.block  = true;
      token_o.info   = params;
      token_o.map    = [startLine, nextLine];

      state.md.block.tokenize(state, startLine + 1, nextLine);

      const token_c  = state.push('container_' + name + '_close', 'div', -1);
      token_c.markup = state.src.slice(start, pos);
      token_c.block  = true;

      state.parentType = old_parent;
      state.lineMax = old_line_max;
      state.line = nextLine + (auto_closed ? 1 : 0);

      return true
    }

    md.block.ruler.before('fence', 'container_' + name, container, {
      alt: ['paragraph', 'reference', 'blockquote', 'list']
    });
    md.renderer.rules['container_' + name + '_open'] = render;
    md.renderer.rules['container_' + name + '_close'] = render;
  }

  const createContainerThenUse = (md, option) => {
    md.use(...createContainerThenGet(md, option));
  };
  const createContainerThenGet = (md, option) => {
    const { type, useTitle, defaultTitle, className } = option;
    return [
      container_plugin,
      type,
      {
        render(tokens, idx) {
          const token = tokens[idx];
          const info = token.info.trim().slice(type.length).trim();
          if (token.nesting === 1) {
            const title = useTitle ? md.renderInline(info || defaultTitle || "") : "";
            return `<div class="${type} ${className}">${useTitle ? `<p class="title ${type}-title ${className ? `${className}-title` : ""}">${title}</p>` : ""}
`;
          } else return `</div>
`;
        }
      }
    ];
  };
  const createContainersThenUse = (md, options) => {
    options.forEach((option) => {
      md.use(...createContainerThenGet(md, option));
    });
  };
  const createContainersThenGet = (md, options) => {
    const containers = [];
    options.forEach((option) => {
      containers.push(createContainerThenGet(md, option));
    });
    return containers;
  };

  /*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
  function isNothing(subject) {
    return (typeof subject === 'undefined') || (subject === null);
  }


  function isObject(subject) {
    return (typeof subject === 'object') && (subject !== null);
  }


  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];

    return [ sequence ];
  }


  function extend(target, source) {
    var index, length, key, sourceKeys;

    if (source) {
      sourceKeys = Object.keys(source);

      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }

    return target;
  }


  function repeat(string, count) {
    var result = '', cycle;

    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }

    return result;
  }


  function isNegativeZero(number) {
    return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
  }


  var isNothing_1      = isNothing;
  var isObject_1       = isObject;
  var toArray_1        = toArray;
  var repeat_1         = repeat;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1         = extend;

  var common = {
  	isNothing: isNothing_1,
  	isObject: isObject_1,
  	toArray: toArray_1,
  	repeat: repeat_1,
  	isNegativeZero: isNegativeZero_1,
  	extend: extend_1
  };

  // YAML error class. http://stackoverflow.com/questions/8458984


  function formatError(exception, compact) {
    var where = '', message = exception.reason || '(unknown reason)';

    if (!exception.mark) return message;

    if (exception.mark.name) {
      where += 'in "' + exception.mark.name + '" ';
    }

    where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

    if (!compact && exception.mark.snippet) {
      where += '\n\n' + exception.mark.snippet;
    }

    return message + ' ' + where;
  }


  function YAMLException$1(reason, mark) {
    // Super constructor
    Error.call(this);

    this.name = 'YAMLException';
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);

    // Include stack trace in error object
    if (Error.captureStackTrace) {
      // Chrome and NodeJS
      Error.captureStackTrace(this, this.constructor);
    } else {
      // FF, IE 10+ and Safari 6+. Fallback for others
      this.stack = (new Error()).stack || '';
    }
  }


  // Inherit from Error
  YAMLException$1.prototype = Object.create(Error.prototype);
  YAMLException$1.prototype.constructor = YAMLException$1;


  YAMLException$1.prototype.toString = function toString(compact) {
    return this.name + ': ' + formatError(this, compact);
  };


  var exception = YAMLException$1;

  // get snippet for a single line, respecting maxLength
  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = '';
    var tail = '';
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

    if (position - lineStart > maxHalfLength) {
      head = ' ... ';
      lineStart = position - maxHalfLength + head.length;
    }

    if (lineEnd - position > maxHalfLength) {
      tail = ' ...';
      lineEnd = position + maxHalfLength - tail.length;
    }

    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, '→') + tail,
      pos: position - lineStart + head.length // relative position
    };
  }


  function padStart(string, max) {
    return common.repeat(' ', max - string.length) + string;
  }


  function makeSnippet(mark, options) {
    options = Object.create(options || null);

    if (!mark.buffer) return null;

    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent      !== 'number') options.indent      = 1;
    if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
    if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;

    var re = /\r?\n|\r|\0/g;
    var lineStarts = [ 0 ];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;

    while ((match = re.exec(mark.buffer))) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);

      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }

    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;

    var result = '', i, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

    for (i = 1; i <= options.linesBefore; i++) {
      if (foundLineNo - i < 0) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo - i],
        lineEnds[foundLineNo - i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
        maxLineLength
      );
      result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +
        ' | ' + line.str + '\n' + result;
    }

    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n';
    result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

    for (i = 1; i <= options.linesAfter; i++) {
      if (foundLineNo + i >= lineEnds.length) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo + i],
        lineEnds[foundLineNo + i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
        maxLineLength
      );
      result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +
        ' | ' + line.str + '\n';
    }

    return result.replace(/\n$/, '');
  }


  var snippet = makeSnippet;

  var TYPE_CONSTRUCTOR_OPTIONS = [
    'kind',
    'multi',
    'resolve',
    'construct',
    'instanceOf',
    'predicate',
    'represent',
    'representName',
    'defaultStyle',
    'styleAliases'
  ];

  var YAML_NODE_KINDS = [
    'scalar',
    'sequence',
    'mapping'
  ];

  function compileStyleAliases(map) {
    var result = {};

    if (map !== null) {
      Object.keys(map).forEach(function (style) {
        map[style].forEach(function (alias) {
          result[String(alias)] = style;
        });
      });
    }

    return result;
  }

  function Type$1(tag, options) {
    options = options || {};

    Object.keys(options).forEach(function (name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });

    // TODO: Add tag format check.
    this.options       = options; // keep original options in case user wants to extend this type later
    this.tag           = tag;
    this.kind          = options['kind']          || null;
    this.resolve       = options['resolve']       || function () { return true; };
    this.construct     = options['construct']     || function (data) { return data; };
    this.instanceOf    = options['instanceOf']    || null;
    this.predicate     = options['predicate']     || null;
    this.represent     = options['represent']     || null;
    this.representName = options['representName'] || null;
    this.defaultStyle  = options['defaultStyle']  || null;
    this.multi         = options['multi']         || false;
    this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);

    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }

  var type = Type$1;

  /*eslint-disable max-len*/





  function compileList(schema, name) {
    var result = [];

    schema[name].forEach(function (currentType) {
      var newIndex = result.length;

      result.forEach(function (previousType, previousIndex) {
        if (previousType.tag === currentType.tag &&
            previousType.kind === currentType.kind &&
            previousType.multi === currentType.multi) {

          newIndex = previousIndex;
        }
      });

      result[newIndex] = currentType;
    });

    return result;
  }


  function compileMap(/* lists... */) {
    var result = {
          scalar: {},
          sequence: {},
          mapping: {},
          fallback: {},
          multi: {
            scalar: [],
            sequence: [],
            mapping: [],
            fallback: []
          }
        }, index, length;

    function collectType(type) {
      if (type.multi) {
        result.multi[type.kind].push(type);
        result.multi['fallback'].push(type);
      } else {
        result[type.kind][type.tag] = result['fallback'][type.tag] = type;
      }
    }

    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }


  function Schema$1(definition) {
    return this.extend(definition);
  }


  Schema$1.prototype.extend = function extend(definition) {
    var implicit = [];
    var explicit = [];

    if (definition instanceof type) {
      // Schema.extend(type)
      explicit.push(definition);

    } else if (Array.isArray(definition)) {
      // Schema.extend([ type1, type2, ... ])
      explicit = explicit.concat(definition);

    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
      if (definition.implicit) implicit = implicit.concat(definition.implicit);
      if (definition.explicit) explicit = explicit.concat(definition.explicit);

    } else {
      throw new exception('Schema.extend argument should be a Type, [ Type ], ' +
        'or a schema definition ({ implicit: [...], explicit: [...] })');
    }

    implicit.forEach(function (type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
      }

      if (type$1.loadKind && type$1.loadKind !== 'scalar') {
        throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
      }

      if (type$1.multi) {
        throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
      }
    });

    explicit.forEach(function (type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
      }
    });

    var result = Object.create(Schema$1.prototype);

    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);

    result.compiledImplicit = compileList(result, 'implicit');
    result.compiledExplicit = compileList(result, 'explicit');
    result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

    return result;
  };


  var schema = Schema$1;

  var str = new type('tag:yaml.org,2002:str', {
    kind: 'scalar',
    construct: function (data) { return data !== null ? data : ''; }
  });

  var seq = new type('tag:yaml.org,2002:seq', {
    kind: 'sequence',
    construct: function (data) { return data !== null ? data : []; }
  });

  var map = new type('tag:yaml.org,2002:map', {
    kind: 'mapping',
    construct: function (data) { return data !== null ? data : {}; }
  });

  var failsafe = new schema({
    explicit: [
      str,
      seq,
      map
    ]
  });

  function resolveYamlNull(data) {
    if (data === null) return true;

    var max = data.length;

    return (max === 1 && data === '~') ||
           (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
  }

  function constructYamlNull() {
    return null;
  }

  function isNull(object) {
    return object === null;
  }

  var _null = new type('tag:yaml.org,2002:null', {
    kind: 'scalar',
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function () { return '~';    },
      lowercase: function () { return 'null'; },
      uppercase: function () { return 'NULL'; },
      camelcase: function () { return 'Null'; },
      empty:     function () { return '';     }
    },
    defaultStyle: 'lowercase'
  });

  function resolveYamlBoolean(data) {
    if (data === null) return false;

    var max = data.length;

    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
           (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
  }

  function constructYamlBoolean(data) {
    return data === 'true' ||
           data === 'True' ||
           data === 'TRUE';
  }

  function isBoolean(object) {
    return Object.prototype.toString.call(object) === '[object Boolean]';
  }

  var bool = new type('tag:yaml.org,2002:bool', {
    kind: 'scalar',
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function (object) { return object ? 'true' : 'false'; },
      uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
      camelcase: function (object) { return object ? 'True' : 'False'; }
    },
    defaultStyle: 'lowercase'
  });

  function isHexCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
           ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
           ((0x61/* a */ <= c) && (c <= 0x66/* f */));
  }

  function isOctCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
  }

  function isDecCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
  }

  function resolveYamlInteger(data) {
    if (data === null) return false;

    var max = data.length,
        index = 0,
        hasDigits = false,
        ch;

    if (!max) return false;

    ch = data[index];

    // sign
    if (ch === '-' || ch === '+') {
      ch = data[++index];
    }

    if (ch === '0') {
      // 0
      if (index + 1 === max) return true;
      ch = data[++index];

      // base 2, base 8, base 16

      if (ch === 'b') {
        // base 2
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (ch !== '0' && ch !== '1') return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }


      if (ch === 'x') {
        // base 16
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }


      if (ch === 'o') {
        // base 8
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }
    }

    // base 10 (except 0)

    // value should not start with `_`;
    if (ch === '_') return false;

    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }

    // Should have digits and should not end with `_`
    if (!hasDigits || ch === '_') return false;

    return true;
  }

  function constructYamlInteger(data) {
    var value = data, sign = 1, ch;

    if (value.indexOf('_') !== -1) {
      value = value.replace(/_/g, '');
    }

    ch = value[0];

    if (ch === '-' || ch === '+') {
      if (ch === '-') sign = -1;
      value = value.slice(1);
      ch = value[0];
    }

    if (value === '0') return 0;

    if (ch === '0') {
      if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
      if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
      if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
    }

    return sign * parseInt(value, 10);
  }

  function isInteger(object) {
    return (Object.prototype.toString.call(object)) === '[object Number]' &&
           (object % 1 === 0 && !common.isNegativeZero(object));
  }

  var int = new type('tag:yaml.org,2002:int', {
    kind: 'scalar',
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
      octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },
      decimal:     function (obj) { return obj.toString(10); },
      /* eslint-disable max-len */
      hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
    },
    defaultStyle: 'decimal',
    styleAliases: {
      binary:      [ 2,  'bin' ],
      octal:       [ 8,  'oct' ],
      decimal:     [ 10, 'dec' ],
      hexadecimal: [ 16, 'hex' ]
    }
  });

  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
    // .2e4, .2
    // special case, seems not from spec
    '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
    // .inf
    '|[-+]?\\.(?:inf|Inf|INF)' +
    // .nan
    '|\\.(?:nan|NaN|NAN))$');

  function resolveYamlFloat(data) {
    if (data === null) return false;

    if (!YAML_FLOAT_PATTERN.test(data) ||
        // Quick hack to not allow integers end with `_`
        // Probably should update regexp & check speed
        data[data.length - 1] === '_') {
      return false;
    }

    return true;
  }

  function constructYamlFloat(data) {
    var value, sign;

    value  = data.replace(/_/g, '').toLowerCase();
    sign   = value[0] === '-' ? -1 : 1;

    if ('+-'.indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }

    if (value === '.inf') {
      return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

    } else if (value === '.nan') {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }


  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

  function representYamlFloat(object, style) {
    var res;

    if (isNaN(object)) {
      switch (style) {
        case 'lowercase': return '.nan';
        case 'uppercase': return '.NAN';
        case 'camelcase': return '.NaN';
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase': return '.inf';
        case 'uppercase': return '.INF';
        case 'camelcase': return '.Inf';
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase': return '-.inf';
        case 'uppercase': return '-.INF';
        case 'camelcase': return '-.Inf';
      }
    } else if (common.isNegativeZero(object)) {
      return '-0.0';
    }

    res = object.toString(10);

    // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack

    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
  }

  function isFloat(object) {
    return (Object.prototype.toString.call(object) === '[object Number]') &&
           (object % 1 !== 0 || common.isNegativeZero(object));
  }

  var float = new type('tag:yaml.org,2002:float', {
    kind: 'scalar',
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: 'lowercase'
  });

  var json = failsafe.extend({
    implicit: [
      _null,
      bool,
      int,
      float
    ]
  });

  var core = json;

  var YAML_DATE_REGEXP = new RegExp(
    '^([0-9][0-9][0-9][0-9])'          + // [1] year
    '-([0-9][0-9])'                    + // [2] month
    '-([0-9][0-9])$');                   // [3] day

  var YAML_TIMESTAMP_REGEXP = new RegExp(
    '^([0-9][0-9][0-9][0-9])'          + // [1] year
    '-([0-9][0-9]?)'                   + // [2] month
    '-([0-9][0-9]?)'                   + // [3] day
    '(?:[Tt]|[ \\t]+)'                 + // ...
    '([0-9][0-9]?)'                    + // [4] hour
    ':([0-9][0-9])'                    + // [5] minute
    ':([0-9][0-9])'                    + // [6] second
    '(?:\\.([0-9]*))?'                 + // [7] fraction
    '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
    '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }

  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0,
        delta = null, tz_hour, tz_minute, date;

    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

    if (match === null) throw new Error('Date resolve error');

    // match: [1] year [2] month [3] day

    year = +(match[1]);
    month = +(match[2]) - 1; // JS month starts with 0
    day = +(match[3]);

    if (!match[4]) { // no hour
      return new Date(Date.UTC(year, month, day));
    }

    // match: [4] hour [5] minute [6] second [7] fraction

    hour = +(match[4]);
    minute = +(match[5]);
    second = +(match[6]);

    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) { // milli-seconds
        fraction += '0';
      }
      fraction = +fraction;
    }

    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

    if (match[9]) {
      tz_hour = +(match[10]);
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
      if (match[9] === '-') delta = -delta;
    }

    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

    if (delta) date.setTime(date.getTime() - delta);

    return date;
  }

  function representYamlTimestamp(object /*, style*/) {
    return object.toISOString();
  }

  var timestamp = new type('tag:yaml.org,2002:timestamp', {
    kind: 'scalar',
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });

  function resolveYamlMerge(data) {
    return data === '<<' || data === null;
  }

  var merge = new type('tag:yaml.org,2002:merge', {
    kind: 'scalar',
    resolve: resolveYamlMerge
  });

  /*eslint-disable no-bitwise*/





  // [ 64, 65, 66 ] -> [ padding, CR, LF ]
  var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


  function resolveYamlBinary(data) {
    if (data === null) return false;

    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

    // Convert one by one.
    for (idx = 0; idx < max; idx++) {
      code = map.indexOf(data.charAt(idx));

      // Skip CR/LF
      if (code > 64) continue;

      // Fail on illegal characters
      if (code < 0) return false;

      bitlen += 6;
    }

    // If there are any bits left, source was corrupted
    return (bitlen % 8) === 0;
  }

  function constructYamlBinary(data) {
    var idx, tailbits,
        input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
        max = input.length,
        map = BASE64_MAP,
        bits = 0,
        result = [];

    // Collect by 6*4 bits (3 bytes)

    for (idx = 0; idx < max; idx++) {
      if ((idx % 4 === 0) && idx) {
        result.push((bits >> 16) & 0xFF);
        result.push((bits >> 8) & 0xFF);
        result.push(bits & 0xFF);
      }

      bits = (bits << 6) | map.indexOf(input.charAt(idx));
    }

    // Dump tail

    tailbits = (max % 4) * 6;

    if (tailbits === 0) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    } else if (tailbits === 18) {
      result.push((bits >> 10) & 0xFF);
      result.push((bits >> 2) & 0xFF);
    } else if (tailbits === 12) {
      result.push((bits >> 4) & 0xFF);
    }

    return new Uint8Array(result);
  }

  function representYamlBinary(object /*, style*/) {
    var result = '', bits = 0, idx, tail,
        max = object.length,
        map = BASE64_MAP;

    // Convert every three bytes to 4 ASCII characters.

    for (idx = 0; idx < max; idx++) {
      if ((idx % 3 === 0) && idx) {
        result += map[(bits >> 18) & 0x3F];
        result += map[(bits >> 12) & 0x3F];
        result += map[(bits >> 6) & 0x3F];
        result += map[bits & 0x3F];
      }

      bits = (bits << 8) + object[idx];
    }

    // Dump tail

    tail = max % 3;

    if (tail === 0) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    } else if (tail === 2) {
      result += map[(bits >> 10) & 0x3F];
      result += map[(bits >> 4) & 0x3F];
      result += map[(bits << 2) & 0x3F];
      result += map[64];
    } else if (tail === 1) {
      result += map[(bits >> 2) & 0x3F];
      result += map[(bits << 4) & 0x3F];
      result += map[64];
      result += map[64];
    }

    return result;
  }

  function isBinary(obj) {
    return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';
  }

  var binary = new type('tag:yaml.org,2002:binary', {
    kind: 'scalar',
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });

  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2       = Object.prototype.toString;

  function resolveYamlOmap(data) {
    if (data === null) return true;

    var objectKeys = [], index, length, pair, pairKey, pairHasKey,
        object = data;

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;

      if (_toString$2.call(pair) !== '[object Object]') return false;

      for (pairKey in pair) {
        if (_hasOwnProperty$3.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }

      if (!pairHasKey) return false;

      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }

    return true;
  }

  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }

  var omap = new type('tag:yaml.org,2002:omap', {
    kind: 'sequence',
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });

  var _toString$1 = Object.prototype.toString;

  function resolveYamlPairs(data) {
    if (data === null) return true;

    var index, length, pair, keys, result,
        object = data;

    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];

      if (_toString$1.call(pair) !== '[object Object]') return false;

      keys = Object.keys(pair);

      if (keys.length !== 1) return false;

      result[index] = [ keys[0], pair[keys[0]] ];
    }

    return true;
  }

  function constructYamlPairs(data) {
    if (data === null) return [];

    var index, length, pair, keys, result,
        object = data;

    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];

      keys = Object.keys(pair);

      result[index] = [ keys[0], pair[keys[0]] ];
    }

    return result;
  }

  var pairs = new type('tag:yaml.org,2002:pairs', {
    kind: 'sequence',
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });

  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

  function resolveYamlSet(data) {
    if (data === null) return true;

    var key, object = data;

    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }

    return true;
  }

  function constructYamlSet(data) {
    return data !== null ? data : {};
  }

  var set = new type('tag:yaml.org,2002:set', {
    kind: 'mapping',
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });

  var _default = core.extend({
    implicit: [
      timestamp,
      merge
    ],
    explicit: [
      binary,
      omap,
      pairs,
      set
    ]
  });

  /*eslint-disable max-len,no-use-before-define*/







  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;


  var CONTEXT_FLOW_IN   = 1;
  var CONTEXT_FLOW_OUT  = 2;
  var CONTEXT_BLOCK_IN  = 3;
  var CONTEXT_BLOCK_OUT = 4;


  var CHOMPING_CLIP  = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP  = 3;


  var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


  function _class(obj) { return Object.prototype.toString.call(obj); }

  function is_EOL(c) {
    return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
  }

  function is_WHITE_SPACE(c) {
    return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
  }

  function is_WS_OR_EOL(c) {
    return (c === 0x09/* Tab */) ||
           (c === 0x20/* Space */) ||
           (c === 0x0A/* LF */) ||
           (c === 0x0D/* CR */);
  }

  function is_FLOW_INDICATOR(c) {
    return c === 0x2C/* , */ ||
           c === 0x5B/* [ */ ||
           c === 0x5D/* ] */ ||
           c === 0x7B/* { */ ||
           c === 0x7D/* } */;
  }

  function fromHexCode(c) {
    var lc;

    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
      return c - 0x30;
    }

    /*eslint-disable no-bitwise*/
    lc = c | 0x20;

    if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
      return lc - 0x61 + 10;
    }

    return -1;
  }

  function escapedHexLen(c) {
    if (c === 0x78/* x */) { return 2; }
    if (c === 0x75/* u */) { return 4; }
    if (c === 0x55/* U */) { return 8; }
    return 0;
  }

  function fromDecimalCode(c) {
    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
      return c - 0x30;
    }

    return -1;
  }

  function simpleEscapeSequence(c) {
    /* eslint-disable indent */
    return (c === 0x30/* 0 */) ? '\x00' :
          (c === 0x61/* a */) ? '\x07' :
          (c === 0x62/* b */) ? '\x08' :
          (c === 0x74/* t */) ? '\x09' :
          (c === 0x09/* Tab */) ? '\x09' :
          (c === 0x6E/* n */) ? '\x0A' :
          (c === 0x76/* v */) ? '\x0B' :
          (c === 0x66/* f */) ? '\x0C' :
          (c === 0x72/* r */) ? '\x0D' :
          (c === 0x65/* e */) ? '\x1B' :
          (c === 0x20/* Space */) ? ' ' :
          (c === 0x22/* " */) ? '\x22' :
          (c === 0x2F/* / */) ? '/' :
          (c === 0x5C/* \ */) ? '\x5C' :
          (c === 0x4E/* N */) ? '\x85' :
          (c === 0x5F/* _ */) ? '\xA0' :
          (c === 0x4C/* L */) ? '\u2028' :
          (c === 0x50/* P */) ? '\u2029' : '';
  }

  function charFromCodepoint(c) {
    if (c <= 0xFFFF) {
      return String.fromCharCode(c);
    }
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode(
      ((c - 0x010000) >> 10) + 0xD800,
      ((c - 0x010000) & 0x03FF) + 0xDC00
    );
  }

  var simpleEscapeCheck = new Array(256); // integer, for fast access
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }


  function State$1(input, options) {
    this.input = input;

    this.filename  = options['filename']  || null;
    this.schema    = options['schema']    || _default;
    this.onWarning = options['onWarning'] || null;
    // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
    // if such documents have no explicit %YAML directive
    this.legacy    = options['legacy']    || false;

    this.json      = options['json']      || false;
    this.listener  = options['listener']  || null;

    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap       = this.schema.compiledTypeMap;

    this.length     = input.length;
    this.position   = 0;
    this.line       = 0;
    this.lineStart  = 0;
    this.lineIndent = 0;

    // position of first leading tab in the current line,
    // used to make sure there are no tabs in the indentation
    this.firstTabInLine = -1;

    this.documents = [];

    /*
    this.version;
    this.checkLineBreaks;
    this.tagMap;
    this.anchorMap;
    this.tag;
    this.anchor;
    this.kind;
    this.result;*/

  }


  function generateError(state, message) {
    var mark = {
      name:     state.filename,
      buffer:   state.input.slice(0, -1), // omit trailing \0
      position: state.position,
      line:     state.line,
      column:   state.position - state.lineStart
    };

    mark.snippet = snippet(mark);

    return new exception(message, mark);
  }

  function throwError(state, message) {
    throw generateError(state, message);
  }

  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }


  var directiveHandlers = {

    YAML: function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (state.version !== null) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (args.length !== 1) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (match === null) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (major !== 1) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (minor !== 1 && minor !== 2) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

    TAG: function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (args.length !== 2) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty$1.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError(state, 'tag prefix is malformed: ' + prefix);
      }

      state.tagMap[handle] = prefix;
    }
  };


  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;

    if (start < end) {
      _result = state.input.slice(start, end);

      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 0x09 ||
                (0x20 <= _character && _character <= 0x10FFFF))) {
            throwError(state, 'expected valid JSON character');
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, 'the stream contains non-printable characters');
      }

      state.result += _result;
    }
  }

  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;

    if (!common.isObject(source)) {
      throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
    }

    sourceKeys = Object.keys(source);

    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];

      if (!_hasOwnProperty$1.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }

  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
    startLine, startLineStart, startPos) {

    var index, quantity;

    // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);

      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, 'nested arrays are not supported inside keys');
        }

        if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
          keyNode[index] = '[object Object]';
        }
      }
    }

    // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)
    if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
      keyNode = '[object Object]';
    }


    keyNode = String(keyNode);

    if (_result === null) {
      _result = {};
    }

    if (keyTag === 'tag:yaml.org,2002:merge') {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json &&
          !_hasOwnProperty$1.call(overridableKeys, keyNode) &&
          _hasOwnProperty$1.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, 'duplicated mapping key');
      }

      // used for this specific key only because Object.defineProperty is slow
      if (keyNode === '__proto__') {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }

    return _result;
  }

  function readLineBreak(state) {
    var ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x0A/* LF */) {
      state.position++;
    } else if (ch === 0x0D/* CR */) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
        state.position++;
      }
    } else {
      throwError(state, 'a line break is expected');
    }

    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }

  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0,
        ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch = state.input.charCodeAt(++state.position);
      }

      if (allowComments && ch === 0x23/* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
      }

      if (is_EOL(ch)) {
        readLineBreak(state);

        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;

        while (ch === 0x20/* Space */) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }

    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, 'deficient indentation');
    }

    return lineBreaks;
  }

  function testDocumentSeparator(state) {
    var _position = state.position,
        ch;

    ch = state.input.charCodeAt(_position);

    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
        ch === state.input.charCodeAt(_position + 1) &&
        ch === state.input.charCodeAt(_position + 2)) {

      _position += 3;

      ch = state.input.charCodeAt(_position);

      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }

    return false;
  }

  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += ' ';
    } else if (count > 1) {
      state.result += common.repeat('\n', count - 1);
    }
  }


  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding,
        following,
        captureStart,
        captureEnd,
        hasPendingContent,
        _line,
        _lineStart,
        _lineIndent,
        _kind = state.kind,
        _result = state.result,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (is_WS_OR_EOL(ch)      ||
        is_FLOW_INDICATOR(ch) ||
        ch === 0x23/* # */    ||
        ch === 0x26/* & */    ||
        ch === 0x2A/* * */    ||
        ch === 0x21/* ! */    ||
        ch === 0x7C/* | */    ||
        ch === 0x3E/* > */    ||
        ch === 0x27/* ' */    ||
        ch === 0x22/* " */    ||
        ch === 0x25/* % */    ||
        ch === 0x40/* @ */    ||
        ch === 0x60/* ` */) {
      return false;
    }

    if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }

    state.kind = 'scalar';
    state.result = '';
    captureStart = captureEnd = state.position;
    hasPendingContent = false;

    while (ch !== 0) {
      if (ch === 0x3A/* : */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) ||
            withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }

      } else if (ch === 0x23/* # */) {
        preceding = state.input.charCodeAt(state.position - 1);

        if (is_WS_OR_EOL(preceding)) {
          break;
        }

      } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
                 withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;

      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);

        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }

      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }

      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }

      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, captureEnd, false);

    if (state.result) {
      return true;
    }

    state.kind = _kind;
    state.result = _result;
    return false;
  }

  function readSingleQuotedScalar(state, nodeIndent) {
    var ch,
        captureStart, captureEnd;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x27/* ' */) {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x27/* ' */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (ch === 0x27/* ' */) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }

      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;

      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a single quoted scalar');

      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, 'unexpected end of the stream within a single quoted scalar');
  }

  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart,
        captureEnd,
        hexLength,
        hexResult,
        tmp,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x22/* " */) {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x22/* " */) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;

      } else if (ch === 0x5C/* \ */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);

          // TODO: rework to inline fn with no type cast?
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;

        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;

          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);

            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;

            } else {
              throwError(state, 'expected hexadecimal character');
            }
          }

          state.result += charFromCodepoint(hexResult);

          state.position++;

        } else {
          throwError(state, 'unknown escape sequence');
        }

        captureStart = captureEnd = state.position;

      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;

      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a double quoted scalar');

      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, 'unexpected end of the stream within a double quoted scalar');
  }

  function readFlowCollection(state, nodeIndent) {
    var readNext = true,
        _line,
        _lineStart,
        _pos,
        _tag     = state.tag,
        _result,
        _anchor  = state.anchor,
        following,
        terminator,
        isPair,
        isExplicitPair,
        isMapping,
        overridableKeys = Object.create(null),
        keyNode,
        keyTag,
        valueNode,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x5B/* [ */) {
      terminator = 0x5D;/* ] */
      isMapping = false;
      _result = [];
    } else if (ch === 0x7B/* { */) {
      terminator = 0x7D;/* } */
      isMapping = true;
      _result = {};
    } else {
      return false;
    }

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(++state.position);

    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? 'mapping' : 'sequence';
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, 'missed comma between flow collection entries');
      } else if (ch === 0x2C/* , */) {
        // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
        throwError(state, "expected the node content, but found ','");
      }

      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;

      if (ch === 0x3F/* ? */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }

      _line = state.line; // Save the current line.
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }

      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }

      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if (ch === 0x2C/* , */) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }

    throwError(state, 'unexpected end of the stream within a flow collection');
  }

  function readBlockScalar(state, nodeIndent) {
    var captureStart,
        folding,
        chomping       = CHOMPING_CLIP,
        didReadContent = false,
        detectedIndent = false,
        textIndent     = nodeIndent,
        emptyLines     = 0,
        atMoreIndented = false,
        tmp,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x7C/* | */) {
      folding = false;
    } else if (ch === 0x3E/* > */) {
      folding = true;
    } else {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';

    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
        if (CHOMPING_CLIP === chomping) {
          chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, 'repeat of a chomping mode identifier');
        }

      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, 'repeat of an indentation width identifier');
        }

      } else {
        break;
      }
    }

    if (is_WHITE_SPACE(ch)) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (is_WHITE_SPACE(ch));

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (!is_EOL(ch) && (ch !== 0));
      }
    }

    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;

      ch = state.input.charCodeAt(state.position);

      while ((!detectedIndent || state.lineIndent < textIndent) &&
             (ch === 0x20/* Space */)) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }

      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }

      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }

      // End of the scalar.
      if (state.lineIndent < textIndent) {

        // Perform the chomping.
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) { // i.e. only if the scalar is not empty.
            state.result += '\n';
          }
        }

        // Break this `while` cycle and go to the funciton's epilogue.
        break;
      }

      // Folded style: use fancy rules to handle line breaks.
      if (folding) {

        // Lines starting with white space characters (more-indented lines) are not folded.
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          // except for the first content line (cf. Example 8.1)
          state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

        // End of more-indented block.
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat('\n', emptyLines + 1);

        // Just one line break - perceive as the same line.
        } else if (emptyLines === 0) {
          if (didReadContent) { // i.e. only if we have already read some scalar content.
            state.result += ' ';
          }

        // Several line breaks - perceive as different lines.
        } else {
          state.result += common.repeat('\n', emptyLines);
        }

      // Literal style: just add exact number of line breaks between content lines.
      } else {
        // Keep all line breaks except the header line break.
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      }

      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;

      while (!is_EOL(ch) && (ch !== 0)) {
        ch = state.input.charCodeAt(++state.position);
      }

      captureSegment(state, captureStart, state.position, false);
    }

    return true;
  }

  function readBlockSequence(state, nodeIndent) {
    var _line,
        _tag      = state.tag,
        _anchor   = state.anchor,
        _result   = [],
        following,
        detected  = false,
        ch;

    // there is a leading tab before this token, so it can't be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar
    if (state.firstTabInLine !== -1) return false;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, 'tab characters must not be used in indentation');
      }

      if (ch !== 0x2D/* - */) {
        break;
      }

      following = state.input.charCodeAt(state.position + 1);

      if (!is_WS_OR_EOL(following)) {
        break;
      }

      detected = true;
      state.position++;

      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }

      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);

      ch = state.input.charCodeAt(state.position);

      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
        throwError(state, 'bad indentation of a sequence entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }

    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'sequence';
      state.result = _result;
      return true;
    }
    return false;
  }

  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following,
        allowCompact,
        _line,
        _keyLine,
        _keyLineStart,
        _keyPos,
        _tag          = state.tag,
        _anchor       = state.anchor,
        _result       = {},
        overridableKeys = Object.create(null),
        keyTag        = null,
        keyNode       = null,
        valueNode     = null,
        atExplicitKey = false,
        detected      = false,
        ch;

    // there is a leading tab before this token, so it can't be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar
    if (state.firstTabInLine !== -1) return false;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, 'tab characters must not be used in indentation');
      }

      following = state.input.charCodeAt(state.position + 1);
      _line = state.line; // Save the current line.

      //
      // Explicit notation case. There are two separate blocks:
      // first for the key (denoted by "?") and second for the value (denoted by ":")
      //
      if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

        if (ch === 0x3F/* ? */) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;

        } else if (atExplicitKey) {
          // i.e. 0x3A/* : */ === character after the explicit key.
          atExplicitKey = false;
          allowCompact = true;

        } else {
          throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
        }

        state.position += 1;
        ch = following;

      //
      // Implicit notation case. Flow-style node as the key first, then ":", and the value.
      //
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;

        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          // Neither implicit nor explicit notation.
          // Reading is done. Go to the epilogue.
          break;
        }

        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);

          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }

          if (ch === 0x3A/* : */) {
            ch = state.input.charCodeAt(++state.position);

            if (!is_WS_OR_EOL(ch)) {
              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
            }

            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;

          } else if (detected) {
            throwError(state, 'can not read an implicit mapping pair; a colon is missed');

          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true; // Keep the result of `composeNode`.
          }

        } else if (detected) {
          throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }
      }

      //
      // Common reading code for both explicit and implicit notations.
      //
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }

        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }

        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }

        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }

      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
        throwError(state, 'bad indentation of a mapping entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }

    //
    // Epilogue.
    //

    // Special case: last mapping's node contains only the key in explicit notation.
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }

    // Expose the resulting mapping.
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'mapping';
      state.result = _result;
    }

    return detected;
  }

  function readTagProperty(state) {
    var _position,
        isVerbatim = false,
        isNamed    = false,
        tagHandle,
        tagName,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x21/* ! */) return false;

    if (state.tag !== null) {
      throwError(state, 'duplication of a tag property');
    }

    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x3C/* < */) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);

    } else if (ch === 0x21/* ! */) {
      isNamed = true;
      tagHandle = '!!';
      ch = state.input.charCodeAt(++state.position);

    } else {
      tagHandle = '!';
    }

    _position = state.position;

    if (isVerbatim) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (ch !== 0 && ch !== 0x3E/* > */);

      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, 'unexpected end of the stream within a verbatim tag');
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {

        if (ch === 0x21/* ! */) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);

            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, 'named tag handle cannot contain such characters');
            }

            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, 'tag suffix cannot contain exclamation marks');
          }
        }

        ch = state.input.charCodeAt(++state.position);
      }

      tagName = state.input.slice(_position, state.position);

      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, 'tag suffix cannot contain flow indicator characters');
      }
    }

    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, 'tag name cannot contain such characters: ' + tagName);
    }

    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state, 'tag name is malformed: ' + tagName);
    }

    if (isVerbatim) {
      state.tag = tagName;

    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;

    } else if (tagHandle === '!') {
      state.tag = '!' + tagName;

    } else if (tagHandle === '!!') {
      state.tag = 'tag:yaml.org,2002:' + tagName;

    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }

    return true;
  }

  function readAnchorProperty(state) {
    var _position,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x26/* & */) return false;

    if (state.anchor !== null) {
      throwError(state, 'duplication of an anchor property');
    }

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, 'name of an anchor node must contain at least one character');
    }

    state.anchor = state.input.slice(_position, state.position);
    return true;
  }

  function readAlias(state) {
    var _position, alias,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x2A/* * */) return false;

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, 'name of an alias node must contain at least one character');
    }

    alias = state.input.slice(_position, state.position);

    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }

    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }

  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles,
        allowBlockScalars,
        allowBlockCollections,
        indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
        atNewLine  = false,
        hasContent = false,
        typeIndex,
        typeQuantity,
        typeList,
        type,
        flowIndent,
        blockIndent;

    if (state.listener !== null) {
      state.listener('open', state);
    }

    state.tag    = null;
    state.anchor = null;
    state.kind   = null;
    state.result = null;

    allowBlockStyles = allowBlockScalars = allowBlockCollections =
      CONTEXT_BLOCK_OUT === nodeContext ||
      CONTEXT_BLOCK_IN  === nodeContext;

    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }

    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;

          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }

    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }

    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }

      blockIndent = state.position - state.lineStart;

      if (indentStatus === 1) {
        if (allowBlockCollections &&
            (readBlockSequence(state, blockIndent) ||
             readBlockMapping(state, blockIndent, flowIndent)) ||
            readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
              readSingleQuotedScalar(state, flowIndent) ||
              readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;

          } else if (readAlias(state)) {
            hasContent = true;

            if (state.tag !== null || state.anchor !== null) {
              throwError(state, 'alias node should not have any properties');
            }

          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;

            if (state.tag === null) {
              state.tag = '?';
            }
          }

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        // Special case: block sequences are allowed to have same indentation level as the parent.
        // http://www.yaml.org/spec/1.2/spec.html#id2799784
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }

    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }

    } else if (state.tag === '?') {
      // Implicit resolving is not allowed for non-scalar types, and '?'
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns '?'
      // tag, for example like this: "!<?> [0]"
      //
      if (state.result !== null && state.kind !== 'scalar') {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== '!') {
      if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
        type = state.typeMap[state.kind || 'fallback'][state.tag];
      } else {
        // looking for multi type
        type = null;
        typeList = state.typeMap.multi[state.kind || 'fallback'];

        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type = typeList[typeIndex];
            break;
          }
        }
      }

      if (!type) {
        throwError(state, 'unknown tag !<' + state.tag + '>');
      }

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }

    if (state.listener !== null) {
      state.listener('close', state);
    }
    return state.tag !== null ||  state.anchor !== null || hasContent;
  }

  function readDocument(state) {
    var documentStart = state.position,
        _position,
        directiveName,
        directiveArgs,
        hasDirectives = false,
        ch;

    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = Object.create(null);
    state.anchorMap = Object.create(null);

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);

      ch = state.input.charCodeAt(state.position);

      if (state.lineIndent > 0 || ch !== 0x25/* % */) {
        break;
      }

      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];

      if (directiveName.length < 1) {
        throwError(state, 'directive name must not be less than one character in length');
      }

      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x23/* # */) {
          do { ch = state.input.charCodeAt(++state.position); }
          while (ch !== 0 && !is_EOL(ch));
          break;
        }

        if (is_EOL(ch)) break;

        _position = state.position;

        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        directiveArgs.push(state.input.slice(_position, state.position));
      }

      if (ch !== 0) readLineBreak(state);

      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }

    skipSeparationSpace(state, true, -1);

    if (state.lineIndent === 0 &&
        state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
        state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
        state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);

    } else if (hasDirectives) {
      throwError(state, 'directives end mark is expected');
    }

    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);

    if (state.checkLineBreaks &&
        PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, 'non-ASCII line breaks are interpreted as content');
    }

    state.documents.push(state.result);

    if (state.position === state.lineStart && testDocumentSeparator(state)) {

      if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }

    if (state.position < (state.length - 1)) {
      throwError(state, 'end of the stream or a document separator is expected');
    } else {
      return;
    }
  }


  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};

    if (input.length !== 0) {

      // Add tailing `\n` if not exists
      if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
          input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
        input += '\n';
      }

      // Strip BOM
      if (input.charCodeAt(0) === 0xFEFF) {
        input = input.slice(1);
      }
    }

    var state = new State$1(input, options);

    var nullpos = input.indexOf('\0');

    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, 'null byte is not allowed in input');
    }

    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += '\0';

    while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
      state.lineIndent += 1;
      state.position += 1;
    }

    while (state.position < (state.length - 1)) {
      readDocument(state);
    }

    return state.documents;
  }


  function loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
      options = iterator;
      iterator = null;
    }

    var documents = loadDocuments(input, options);

    if (typeof iterator !== 'function') {
      return documents;
    }

    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }


  function load$1(input, options) {
    var documents = loadDocuments(input, options);

    if (documents.length === 0) {
      /*eslint-disable no-undefined*/
      return undefined;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new exception('expected a single document in the stream, but found more');
  }


  var loadAll_1 = loadAll$1;
  var load_1    = load$1;

  var loader = {
  	loadAll: loadAll_1,
  	load: load_1
  };

  /*eslint-disable no-use-before-define*/





  var _toString       = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;

  var CHAR_BOM                  = 0xFEFF;
  var CHAR_TAB                  = 0x09; /* Tab */
  var CHAR_LINE_FEED            = 0x0A; /* LF */
  var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
  var CHAR_SPACE                = 0x20; /* Space */
  var CHAR_EXCLAMATION          = 0x21; /* ! */
  var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
  var CHAR_SHARP                = 0x23; /* # */
  var CHAR_PERCENT              = 0x25; /* % */
  var CHAR_AMPERSAND            = 0x26; /* & */
  var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
  var CHAR_ASTERISK             = 0x2A; /* * */
  var CHAR_COMMA                = 0x2C; /* , */
  var CHAR_MINUS                = 0x2D; /* - */
  var CHAR_COLON                = 0x3A; /* : */
  var CHAR_EQUALS               = 0x3D; /* = */
  var CHAR_GREATER_THAN         = 0x3E; /* > */
  var CHAR_QUESTION             = 0x3F; /* ? */
  var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
  var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
  var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
  var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
  var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
  var CHAR_VERTICAL_LINE        = 0x7C; /* | */
  var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

  var ESCAPE_SEQUENCES = {};

  ESCAPE_SEQUENCES[0x00]   = '\\0';
  ESCAPE_SEQUENCES[0x07]   = '\\a';
  ESCAPE_SEQUENCES[0x08]   = '\\b';
  ESCAPE_SEQUENCES[0x09]   = '\\t';
  ESCAPE_SEQUENCES[0x0A]   = '\\n';
  ESCAPE_SEQUENCES[0x0B]   = '\\v';
  ESCAPE_SEQUENCES[0x0C]   = '\\f';
  ESCAPE_SEQUENCES[0x0D]   = '\\r';
  ESCAPE_SEQUENCES[0x1B]   = '\\e';
  ESCAPE_SEQUENCES[0x22]   = '\\"';
  ESCAPE_SEQUENCES[0x5C]   = '\\\\';
  ESCAPE_SEQUENCES[0x85]   = '\\N';
  ESCAPE_SEQUENCES[0xA0]   = '\\_';
  ESCAPE_SEQUENCES[0x2028] = '\\L';
  ESCAPE_SEQUENCES[0x2029] = '\\P';

  var DEPRECATED_BOOLEANS_SYNTAX = [
    'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
    'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
  ];

  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

  function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;

    if (map === null) return {};

    result = {};
    keys = Object.keys(map);

    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);

      if (tag.slice(0, 2) === '!!') {
        tag = 'tag:yaml.org,2002:' + tag.slice(2);
      }
      type = schema.compiledTypeMap['fallback'][tag];

      if (type && _hasOwnProperty.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }

      result[tag] = style;
    }

    return result;
  }

  function encodeHex(character) {
    var string, handle, length;

    string = character.toString(16).toUpperCase();

    if (character <= 0xFF) {
      handle = 'x';
      length = 2;
    } else if (character <= 0xFFFF) {
      handle = 'u';
      length = 4;
    } else if (character <= 0xFFFFFFFF) {
      handle = 'U';
      length = 8;
    } else {
      throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
    }

    return '\\' + handle + common.repeat('0', length - string.length) + string;
  }


  var QUOTING_TYPE_SINGLE = 1,
      QUOTING_TYPE_DOUBLE = 2;

  function State(options) {
    this.schema        = options['schema'] || _default;
    this.indent        = Math.max(1, (options['indent'] || 2));
    this.noArrayIndent = options['noArrayIndent'] || false;
    this.skipInvalid   = options['skipInvalid'] || false;
    this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
    this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
    this.sortKeys      = options['sortKeys'] || false;
    this.lineWidth     = options['lineWidth'] || 80;
    this.noRefs        = options['noRefs'] || false;
    this.noCompatMode  = options['noCompatMode'] || false;
    this.condenseFlow  = options['condenseFlow'] || false;
    this.quotingType   = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes   = options['forceQuotes'] || false;
    this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;

    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;

    this.tag = null;
    this.result = '';

    this.duplicates = [];
    this.usedDuplicates = null;
  }

  // Indents every line in a string. Empty lines (\n only) are not indented.
  function indentString(string, spaces) {
    var ind = common.repeat(' ', spaces),
        position = 0,
        next = -1,
        result = '',
        line,
        length = string.length;

    while (position < length) {
      next = string.indexOf('\n', position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }

      if (line.length && line !== '\n') result += ind;

      result += line;
    }

    return result;
  }

  function generateNextLine(state, level) {
    return '\n' + common.repeat(' ', state.indent * level);
  }

  function testImplicitResolving(state, str) {
    var index, length, type;

    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type = state.implicitTypes[index];

      if (type.resolve(str)) {
        return true;
      }
    }

    return false;
  }

  // [33] s-white ::= s-space | s-tab
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }

  // Returns true if the character can be printed without escaping.
  // From YAML 1.2: "any allowed characters known to be non-printable
  // should also be escaped. [However,] This isn’t mandatory"
  // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
  function isPrintable(c) {
    return  (0x00020 <= c && c <= 0x00007E)
        || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
        || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)
        ||  (0x10000 <= c && c <= 0x10FFFF);
  }

  // [34] ns-char ::= nb-char - s-white
  // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
  // [26] b-char  ::= b-line-feed | b-carriage-return
  // Including s-white (for some reason, examples doesn't match specs in this aspect)
  // ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
  function isNsCharOrWhitespace(c) {
    return isPrintable(c)
      && c !== CHAR_BOM
      // - b-char
      && c !== CHAR_CARRIAGE_RETURN
      && c !== CHAR_LINE_FEED;
  }

  // [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out
  //                             c = flow-in   ⇒ ns-plain-safe-in
  //                             c = block-key ⇒ ns-plain-safe-out
  //                             c = flow-key  ⇒ ns-plain-safe-in
  // [128] ns-plain-safe-out ::= ns-char
  // [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
  // [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )
  //                            | ( /* An ns-char preceding */ “#” )
  //                            | ( “:” /* Followed by an ns-plain-safe(c) */ )
  function isPlainSafe(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return (
      // ns-plain-safe
      inblock ? // c = flow-in
        cIsNsCharOrWhitespace
        : cIsNsCharOrWhitespace
          // - c-flow-indicator
          && c !== CHAR_COMMA
          && c !== CHAR_LEFT_SQUARE_BRACKET
          && c !== CHAR_RIGHT_SQUARE_BRACKET
          && c !== CHAR_LEFT_CURLY_BRACKET
          && c !== CHAR_RIGHT_CURLY_BRACKET
    )
      // ns-plain-char
      && c !== CHAR_SHARP // false on '#'
      && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
      || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'
      || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'
  }

  // Simplified test for values allowed as the first character in plain style.
  function isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part
    return isPrintable(c) && c !== CHAR_BOM
      && !isWhitespace(c) // - s-white
      // - (c-indicator ::=
      // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
      && c !== CHAR_MINUS
      && c !== CHAR_QUESTION
      && c !== CHAR_COLON
      && c !== CHAR_COMMA
      && c !== CHAR_LEFT_SQUARE_BRACKET
      && c !== CHAR_RIGHT_SQUARE_BRACKET
      && c !== CHAR_LEFT_CURLY_BRACKET
      && c !== CHAR_RIGHT_CURLY_BRACKET
      // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
      && c !== CHAR_SHARP
      && c !== CHAR_AMPERSAND
      && c !== CHAR_ASTERISK
      && c !== CHAR_EXCLAMATION
      && c !== CHAR_VERTICAL_LINE
      && c !== CHAR_EQUALS
      && c !== CHAR_GREATER_THAN
      && c !== CHAR_SINGLE_QUOTE
      && c !== CHAR_DOUBLE_QUOTE
      // | “%” | “@” | “`”)
      && c !== CHAR_PERCENT
      && c !== CHAR_COMMERCIAL_AT
      && c !== CHAR_GRAVE_ACCENT;
  }

  // Simplified test for values allowed as the last character in plain style.
  function isPlainSafeLast(c) {
    // just not whitespace or colon, it will be checked to be plain character later
    return !isWhitespace(c) && c !== CHAR_COLON;
  }

  // Same as 'string'.codePointAt(pos), but works in older browsers.
  function codePointAt(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
      second = string.charCodeAt(pos + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }

  // Determines whether block indentation indicator is required.
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }

  var STYLE_PLAIN   = 1,
      STYLE_SINGLE  = 2,
      STYLE_LITERAL = 3,
      STYLE_FOLDED  = 4,
      STYLE_DOUBLE  = 5;

  // Determines which scalar styles are possible and returns the preferred style.
  // lineWidth = -1 => no limit.
  // Pre-conditions: str.length > 0.
  // Post-conditions:
  //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
  //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
  //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,
    testAmbiguousType, quotingType, forceQuotes, inblock) {

    var i;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly
    var plain = isPlainSafeFirst(codePointAt(string, 0))
            && isPlainSafeLast(codePointAt(string, string.length - 1));

    if (singleLineOnly || forceQuotes) {
      // Case: no block styles.
      // Check for disallowed characters to rule out plain and single.
      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      // Case: block styles permitted.
      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          // Check if any line can be folded.
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine ||
              // Foldable line = too long, and not more-indented.
              (i - previousLineBreak - 1 > lineWidth &&
               string[previousLineBreak + 1] !== ' ');
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      // in case the end is missing a \n
      hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
        (i - previousLineBreak - 1 > lineWidth &&
         string[previousLineBreak + 1] !== ' '));
    }
    // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.
    if (!hasLineBreak && !hasFoldableLine) {
      // Strings interpretable as another type have to be quoted;
      // e.g. the string 'true' vs. the boolean true.
      if (plain && !forceQuotes && !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    // Edge case: block indentation indicator can only have one digit.
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }

  // Note: line breaking/folding is implemented for only the folded style.
  // NB. We drop the last trailing newline (if any) of a returned block scalar
  //  since the dumper adds its own newline. This always works:
  //    • No ending newline => unaffected; already using strip "-" chomping.
  //    • Ending newline    => removed then restored.
  //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = (function () {
      if (string.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? ('"' + string + '"') : ("'" + string + "'");
        }
      }

      var indent = state.indent * Math.max(1, level); // no 0-indent scalars
      // As indentation gets deeper, let the width decrease monotonically
      // to the lower bound min(state.lineWidth, 40).
      // Note that this implies
      //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
      //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
      // This behaves better than a constant minimum width which disallows narrower options,
      // or an indent threshold which causes the width to suddenly increase.
      var lineWidth = state.lineWidth === -1
        ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

      // Without knowing if keys are implicit/explicit, assume implicit for safety.
      var singleLineOnly = iskey
        // No block styles in flow mode.
        || (state.flowLevel > -1 && level >= state.flowLevel);
      function testAmbiguity(string) {
        return testImplicitResolving(state, string);
      }

      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,
        testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {

        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return '|' + blockHeader(string, state.indent)
            + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return '>' + blockHeader(string, state.indent)
            + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new exception('impossible error: invalid scalar style');
      }
    }());
  }

  // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

    // note the special case: the string '\n' counts as a "trailing" empty line.
    var clip =          string[string.length - 1] === '\n';
    var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
    var chomp = keep ? '+' : (clip ? '' : '-');

    return indentIndicator + chomp + '\n';
  }

  // (See the note for writeScalar.)
  function dropEndingNewline(string) {
    return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
  }

  // Note: a long line without a suitable break point will exceed the width limit.
  // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
  function foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g;

    // first line (possibly an empty line)
    var result = (function () {
      var nextLF = string.indexOf('\n');
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }());
    // If we haven't reached the first content line yet, don't add an extra \n.
    var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
    var moreIndented;

    // rest of the lines
    var match;
    while ((match = lineRe.exec(string))) {
      var prefix = match[1], line = match[2];
      moreIndented = (line[0] === ' ');
      result += prefix
        + (!prevMoreIndented && !moreIndented && line !== ''
          ? '\n' : '')
        + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }

    return result;
  }

  // Greedy line breaking.
  // Picks the longest line under the limit each time,
  // otherwise settles for the shortest line over the limit.
  // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
  function foldLine(line, width) {
    if (line === '' || line[0] === ' ') return line;

    // Since a more-indented line adds a \n, breaks can't be followed by a space.
    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
    var match;
    // start is an inclusive index. end, curr, and next are exclusive.
    var start = 0, end, curr = 0, next = 0;
    var result = '';

    // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.
    while ((match = breakRe.exec(line))) {
      next = match.index;
      // maintain invariant: curr - start <= width
      if (next - start > width) {
        end = (curr > start) ? curr : next; // derive end <= length-2
        result += '\n' + line.slice(start, end);
        // skip the space that was output as \n
        start = end + 1;                    // derive start <= length-1
      }
      curr = next;
    }

    // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.
    result += '\n';
    // Insert a break if the remainder is too long and there is a break available.
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }

    return result.slice(1); // drop extra \n joiner
  }

  // Escapes a double-quoted string.
  function escapeString(string) {
    var result = '';
    var char = 0;
    var escapeSeq;

    for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      escapeSeq = ESCAPE_SEQUENCES[char];

      if (!escapeSeq && isPrintable(char)) {
        result += string[i];
        if (char >= 0x10000) result += string[i + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }

    return result;
  }

  function writeFlowSequence(state, level, object) {
    var _result = '',
        _tag    = state.tag,
        index,
        length,
        value;

    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];

      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }

      // Write only valid elements, put null instead of invalid elements.
      if (writeNode(state, level, value, false, false) ||
          (typeof value === 'undefined' &&
           writeNode(state, level, null, false, false))) {

        if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = '[' + _result + ']';
  }

  function writeBlockSequence(state, level, object, compact) {
    var _result = '',
        _tag    = state.tag,
        index,
        length,
        value;

    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];

      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }

      // Write only valid elements, put null instead of invalid elements.
      if (writeNode(state, level + 1, value, true, true, false, true) ||
          (typeof value === 'undefined' &&
           writeNode(state, level + 1, null, true, true, false, true))) {

        if (!compact || _result !== '') {
          _result += generateNextLine(state, level);
        }

        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += '-';
        } else {
          _result += '- ';
        }

        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = _result || '[]'; // Empty sequence if no valid values.
  }

  function writeFlowMapping(state, level, object) {
    var _result       = '',
        _tag          = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        pairBuffer;

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {

      pairBuffer = '';
      if (_result !== '') pairBuffer += ', ';

      if (state.condenseFlow) pairBuffer += '"';

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }

      if (!writeNode(state, level, objectKey, false, false)) {
        continue; // Skip this pair because of invalid key;
      }

      if (state.dump.length > 1024) pairBuffer += '? ';

      pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

      if (!writeNode(state, level, objectValue, false, false)) {
        continue; // Skip this pair because of invalid value.
      }

      pairBuffer += state.dump;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = '{' + _result + '}';
  }

  function writeBlockMapping(state, level, object, compact) {
    var _result       = '',
        _tag          = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        explicitPair,
        pairBuffer;

    // Allow sorting keys so that the output file is deterministic
    if (state.sortKeys === true) {
      // Default sorting
      objectKeyList.sort();
    } else if (typeof state.sortKeys === 'function') {
      // Custom sort function
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      // Something is wrong
      throw new exception('sortKeys must be a boolean or a function');
    }

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';

      if (!compact || _result !== '') {
        pairBuffer += generateNextLine(state, level);
      }

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }

      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue; // Skip this pair because of invalid key.
      }

      explicitPair = (state.tag !== null && state.tag !== '?') ||
                     (state.dump && state.dump.length > 1024);

      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += '?';
        } else {
          pairBuffer += '? ';
        }
      }

      pairBuffer += state.dump;

      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }

      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue; // Skip this pair because of invalid value.
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ':';
      } else {
        pairBuffer += ': ';
      }

      pairBuffer += state.dump;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
  }

  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;

    typeList = explicit ? state.explicitTypes : state.implicitTypes;

    for (index = 0, length = typeList.length; index < length; index += 1) {
      type = typeList[index];

      if ((type.instanceOf  || type.predicate) &&
          (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
          (!type.predicate  || type.predicate(object))) {

        if (explicit) {
          if (type.multi && type.representName) {
            state.tag = type.representName(object);
          } else {
            state.tag = type.tag;
          }
        } else {
          state.tag = '?';
        }

        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;

          if (_toString.call(type.represent) === '[object Function]') {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
          }

          state.dump = _result;
        }

        return true;
      }
    }

    return false;
  }

  // Serializes `object` and writes it to global `result`.
  // Returns true on success, or false on invalid object.
  //
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;

    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }

    var type = _toString.call(state.dump);
    var inblock = block;
    var tagStr;

    if (block) {
      block = (state.flowLevel < 0 || state.flowLevel > level);
    }

    var objectOrArray = type === '[object Object]' || type === '[object Array]',
        duplicateIndex,
        duplicate;

    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }

    if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
      compact = false;
    }

    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = '*ref_' + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type === '[object Object]') {
        if (block && (Object.keys(state.dump).length !== 0)) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object Array]') {
        if (block && (state.dump.length !== 0)) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object String]') {
        if (state.tag !== '?') {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type === '[object Undefined]') {
        return false;
      } else {
        if (state.skipInvalid) return false;
        throw new exception('unacceptable kind of an object to dump ' + type);
      }

      if (state.tag !== null && state.tag !== '?') {
        // Need to encode all characters except those allowed by the spec:
        //
        // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
        // [36] ns-hex-digit    ::=  ns-dec-digit
        //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
        // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
        // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”
        // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”
        //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”
        //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”
        //
        // Also need to encode '!' because it has special meaning (end of tag prefix).
        //
        tagStr = encodeURI(
          state.tag[0] === '!' ? state.tag.slice(1) : state.tag
        ).replace(/!/g, '%21');

        if (state.tag[0] === '!') {
          tagStr = '!' + tagStr;
        } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
          tagStr = '!!' + tagStr.slice(18);
        } else {
          tagStr = '!<' + tagStr + '>';
        }

        state.dump = tagStr + ' ' + state.dump;
      }
    }

    return true;
  }

  function getDuplicateReferences(object, state) {
    var objects = [],
        duplicatesIndexes = [],
        index,
        length;

    inspectNode(object, objects, duplicatesIndexes);

    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }

  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList,
        index,
        length;

    if (object !== null && typeof object === 'object') {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);

        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);

          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }

  function dump$1(input, options) {
    options = options || {};

    var state = new State(options);

    if (!state.noRefs) getDuplicateReferences(input, state);

    var value = input;

    if (state.replacer) {
      value = state.replacer.call({ '': value }, '', value);
    }

    if (writeNode(state, 0, value, true, true)) return state.dump + '\n';

    return '';
  }

  var dump_1 = dump$1;

  var dumper = {
  	dump: dump_1
  };

  function renamed(from, to) {
    return function () {
      throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +
        'Use yaml.' + to + ' instead, which is now safe by default.');
    };
  }


  var Type                = type;
  var Schema              = schema;
  var FAILSAFE_SCHEMA     = failsafe;
  var JSON_SCHEMA         = json;
  var CORE_SCHEMA         = core;
  var DEFAULT_SCHEMA      = _default;
  var load                = loader.load;
  var loadAll             = loader.loadAll;
  var dump                = dumper.dump;
  var YAMLException       = exception;

  // Re-export all types in case user wants to create custom schema
  var types = {
    binary:    binary,
    float:     float,
    map:       map,
    null:      _null,
    pairs:     pairs,
    set:       set,
    timestamp: timestamp,
    bool:      bool,
    int:       int,
    merge:     merge,
    omap:      omap,
    seq:       seq,
    str:       str
  };

  // Removed functions from JS-YAML 3.0.x
  var safeLoad            = renamed('safeLoad', 'load');
  var safeLoadAll         = renamed('safeLoadAll', 'loadAll');
  var safeDump            = renamed('safeDump', 'dump');

  var jsYaml = {
  	Type: Type,
  	Schema: Schema,
  	FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
  	JSON_SCHEMA: JSON_SCHEMA,
  	CORE_SCHEMA: CORE_SCHEMA,
  	DEFAULT_SCHEMA: DEFAULT_SCHEMA,
  	load: load,
  	loadAll: loadAll,
  	dump: dump,
  	YAMLException: YAMLException,
  	types: types,
  	safeLoad: safeLoad,
  	safeLoadAll: safeLoadAll,
  	safeDump: safeDump
  };

  const createCardContainers = (md, option) => {
    option.forEach((item) => createCardContainer(md, item));
  };
  const createCardContainer = (md, option) => {
    const { type, className, beforeHtmlRender, htmlRender, afterHtmlRender, transformHtml } = option;
    md.use(container_plugin, type, {});
    md.renderer.rules[`container_${type}_open`] = (tokens, idx) => {
      const containerToken = tokens[idx];
      let html = `<div class="${className || `${type}-container`}">`;
      for (let i = idx; i < tokens.length; i++) {
        const token = tokens[i];
        if (token.type === `container_${type}_close`) break;
        if (!["yaml", "yml"].includes(token.info)) continue;
        const yamlContent = jsYaml.load(token.content.trim());
        let data = [];
        let config = {};
        if (Array.isArray(yamlContent)) data = yamlContent;
        else {
          data = yamlContent.data || [];
          config = yamlContent.config || {};
        }
        const info = containerToken.info.trim().slice(type.length).trim();
        const result = beforeHtmlRender?.({ data, config }, info, tokens, i);
        if (result === false) continue;
        html += htmlRender({ data, config }, info, tokens, i);
        afterHtmlRender?.({ data, config }, info, tokens, i);
      }
      html = transformHtml?.(html) ?? html;
      return html;
    };
  };

  const version = "1.5.1";

  var index = {
    extends: DefaultTheme,
    Layout: TeekConfigProvider(_sfc_main),
    async enhanceApp({ app, siteData, router }) {
      app.component("TkCataloguePage", _sfc_main$T);
      app.component("TkArchivesPage", _sfc_main$16);
      app.component("TkArticleOverviewPage", _sfc_main$Z);
      app.component("TkLoginPage", _sfc_main$5);
      app.component("TkRiskLinkPage", _sfc_main$4);
      app.component("TkDemoCode", _sfc_main$M);
      app.component("TkTitleTag", _sfc_main$1b);
      app.component("TkIcon", _sfc_main$1t);
      if (!isClient) return;
      const { themeConfig } = siteData.value;
      processSiteAnalytics(themeConfig);
      if (themeConfig.permalinks) await processPermalinkNotFoundWhenFirstLoaded({ siteData, router });
    }
  };
  const processSiteAnalytics = (themeConfig) => {
    const siteAnalytics = themeConfig.siteAnalytics || [];
    const siteAnalysis = {
      baidu: (options) => {
        baiduAnalytics(options);
        if (isClient) trackPageview(options, window.location.href);
      },
      google: (options) => googleAnalytics(options),
      umami: (options) => umamiAnalytics(options)
    };
    siteAnalytics.forEach((item) => {
      siteAnalysis[item.provider]?.(item.options);
    });
  };
  const processPermalinkNotFoundWhenFirstLoaded = async ({ siteData, router }) => {
    const { base, cleanUrls, themeConfig } = siteData.value;
    if (router.route.path === base && router.route.data.isNotFound) {
      const { pathname, search, hash } = new URL(location.href);
      const decodePath = "/" + decodeURIComponent(pathname.slice(base.length)).replace(/\/$/, "").replace(/\.html/, "");
      const link = cleanUrls ? decodePath : decodePath + ".html";
      const filePath = themeConfig.permalinks.inv[link];
      if (filePath) {
        const targetUrl = base + filePath + search + hash;
        await router.go(targetUrl);
      }
    }
  };

  Object.defineProperty(exports, "addIcons", {
    enumerable: true,
    get: function () { return vue.addCollection; }
  });
  exports.LayoutMode = LayoutMode;
  exports.SpotlightStyle = SpotlightStyle;
  exports.StorageSerializers = StorageSerializers;
  exports.TeekConfigProvider = TeekConfigProvider;
  exports.ThemeColorName = ThemeColorName;
  exports.TkArchivesPage = _sfc_main$16;
  exports.TkArticleAnalyze = _sfc_main$13;
  exports.TkArticleBreadcrumb = _sfc_main$15;
  exports.TkArticleHeadingHighlight = _sfc_main$$;
  exports.TkArticleImagePreview = _sfc_main$_;
  exports.TkArticleInfo = _sfc_main$14;
  exports.TkArticleOverviewPage = _sfc_main$Z;
  exports.TkArticlePage = _sfc_main$1y;
  exports.TkArticlePageStyle = _sfc_main$Y;
  exports.TkArticleShare = _sfc_main$X;
  exports.TkArticleTitle = _sfc_main$17;
  exports.TkArticleUpdate = _sfc_main$W;
  exports.TkAsideBottomAppreciation = _sfc_main$12;
  exports.TkAvatar = _sfc_main$1s;
  exports.TkBodyBgImage = _sfc_main$V;
  exports.TkBreadcrumb = _sfc_main$1r;
  exports.TkBreadcrumbItem = _sfc_main$1q;
  exports.TkCatalogueItem = _sfc_main$U;
  exports.TkCataloguePage = _sfc_main$T;
  exports.TkCodeBlockToggle = _sfc_main$R;
  exports.TkCommentArtalk = _sfc_main$Q;
  exports.TkCommentGiscus = _sfc_main$P;
  exports.TkCommentTwikoo = _sfc_main$O;
  exports.TkCommentWaline = _sfc_main$N;
  exports.TkDemoCode = _sfc_main$M;
  exports.TkDocAfterAppreciation = _sfc_main$11;
  exports.TkDocAfterAppreciationPopper = _sfc_main$10;
  exports.TkDocAsideOutline = _sfc_main$1z;
  exports.TkFocusTrap = TkFocusTrap;
  exports.TkFooterGroup = _sfc_main$L;
  exports.TkFooterInfo = _sfc_main$K;
  exports.TkHome = _sfc_main$p;
  exports.TkHomeBanner = _sfc_main$A;
  exports.TkHomeBannerBgImage = _sfc_main$E;
  exports.TkHomeBannerBgPure = _sfc_main$F;
  exports.TkHomeBannerContent = _sfc_main$D;
  exports.TkHomeBannerFeature = _sfc_main$C;
  exports.TkHomeBannerWaves = _sfc_main$B;
  exports.TkHomeCardList = _sfc_main$q;
  exports.TkHomeCategoryCard = _sfc_main$v;
  exports.TkHomeDocAnalysisCard = _sfc_main$r;
  exports.TkHomeFeature = _sfc_main$o;
  exports.TkHomeFriendLinkCard = _sfc_main$s;
  exports.TkHomeFullscreenWallpaper = _sfc_main$J;
  exports.TkHomeMyCard = _sfc_main$y;
  exports.TkHomeMyCardScreen = _sfc_main$x;
  exports.TkHomePostItem = _sfc_main$I;
  exports.TkHomePostList = _sfc_main$G;
  exports.TkHomeTagCard = _sfc_main$u;
  exports.TkHomeTopArticleCard = _sfc_main$w;
  exports.TkIcon = _sfc_main$1t;
  exports.TkImageViewer = _sfc_main$1n;
  exports.TkInputSlide = _sfc_main$1m;
  exports.TkLayout = _sfc_main;
  exports.TkLoginPage = _sfc_main$5;
  exports.TkMessage = message;
  exports.TkNotice = _sfc_main$6;
  exports.TkPageCard = _sfc_main$z;
  exports.TkPagination = _sfc_main$1f;
  exports.TkPopover = _sfc_main$1e;
  exports.TkRightBottomButton = _sfc_main$7;
  exports.TkRiskLinkPage = _sfc_main$4;
  exports.TkRouteLoading = _sfc_main$2;
  exports.TkSegmented = _sfc_main$1c;
  exports.TkSegmentedItem = _sfc_main$1d;
  exports.TkSidebarTrigger = _sfc_main$3;
  exports.TkSwitch = _sfc_main$g;
  exports.TkThemeEnhance = _sfc_main$b;
  exports.TkThemeEnhanceBaseTemplate = _sfc_main$k;
  exports.TkTitleTag = _sfc_main$1b;
  exports.TkTransitionCollapse = _sfc_main$1a;
  exports.TkVerifyCode = _sfc_main$19;
  exports.TkVpContainer = _sfc_main$18;
  exports.WhatsApp = WhatsApp;
  exports.Z_INDEX_INJECTION_KEY = Z_INDEX_INJECTION_KEY;
  exports.activateMaxWidthSlideMedia = activateMaxWidthSlideMedia;
  exports.addUnit = addUnit;
  exports.aliPayIcon = aliPayIcon;
  exports.alignLeftIcon = alignLeftIcon;
  exports.alignTextLeftIcon = alignTextLeftIcon;
  exports.arrowDownIcon = arrowDownIcon;
  exports.arrowLeftIcon = arrowLeftIcon;
  exports.arrowRightIcon = arrowRightIcon;
  exports.artalkContext = artalkContext;
  exports.autoWidthIcon = autoWidthIcon;
  exports.baiduAnalytics = baiduAnalytics;
  exports.bilibili = bilibili;
  exports.calendarIcon = calendarIcon;
  exports.callBusuanzi = callBusuanzi;
  exports.callVercount = callVercount;
  exports.caretTopIcon = caretTopIcon;
  exports.categoryIcon = categoryIcon;
  exports.circleCloseFilledIcon = circleCloseFilledIcon;
  exports.clickIcon = clickIcon;
  exports.clockIcon = clockIcon;
  exports.closeIcon = closeIcon;
  exports.codeIcon = codeIcon;
  exports.collectionTagIcon = collectionTagIcon;
  exports.commentIcon = commentIcon;
  exports.copyIcon = copyIcon;
  exports.copyrightIcon = copyrightIcon;
  exports.createCardContainer = createCardContainer;
  exports.createCardContainers = createCardContainers;
  exports.createContainerThenGet = createContainerThenGet;
  exports.createContainerThenUse = createContainerThenUse;
  exports.createContainersThenGet = createContainersThenGet;
  exports.createContainersThenUse = createContainersThenUse;
  exports.createDynamicComponent = createDynamicComponent;
  exports.createImageViewer = createImageViewer;
  exports.createScript = createScript;
  exports.dArrowLeftIcon = dArrowLeftIcon;
  exports.dArrowRightIcon = dArrowRightIcon;
  exports.default = index;
  exports.defaultInitialZIndex = defaultInitialZIndex;
  exports.defaultPrivateConfig = defaultPrivateConfig;
  exports.docAnalysisIcon = docAnalysisIcon;
  exports.docMaxWidthSlideStorageKey = docMaxWidthSlideStorageKey;
  exports.docMaxWidthVar = docMaxWidthVar;
  exports.editPenIcon = editPenIcon;
  exports.email = email;
  exports.emptyIcon = emptyIcon;
  exports.en = en;
  exports.externalLinkIcon = externalLinkIcon;
  exports.folderOpenedIcon = folderOpenedIcon;
  exports.formatDate = formatDate;
  exports.formatDiffDate = formatDiffDate;
  exports.formatDiffDateToDay = formatDiffDateToDay;
  exports.friendLinkIcon = friendLinkIcon;
  exports.fullScreenOneIcon = fullScreenOneIcon;
  exports.fullscreenIcon = fullscreenIcon;
  exports.fullscreenTwoIcon = fullscreenTwoIcon;
  exports.get = get;
  exports.getDarkColor = getDarkColor;
  exports.getInstance = getInstance;
  exports.getLastOffset = getLastOffset;
  exports.getLightColor = getLightColor;
  exports.getLoginStorageKey = getLoginStorageKey;
  exports.getNowDate = getNowDate;
  exports.getOffsetOrSpace = getOffsetOrSpace;
  exports.giscusContext = giscusContext;
  exports.gitee = gitee;
  exports.github = github;
  exports.githubIcon = githubIcon;
  exports.googleAnalytics = googleAnalytics;
  exports.guessSerializerType = guessSerializerType;
  exports.hexToRgb = hexToRgb;
  exports.houseIcon = houseIcon;
  exports.icpRecordIcon = icpRecordIcon;
  exports.inBrowser = inBrowser;
  exports.infoFilledIcon = infoFilledIcon;
  exports.instances = instances;
  exports.is = is;
  exports.isArray = isArray$1;
  exports.isAsyncFunction = isAsyncFunction;
  exports.isBoolean = isBoolean$1;
  exports.isClient = isClient;
  exports.isDate = isDate;
  exports.isDef = isDef;
  exports.isElement = isElement;
  exports.isEmpty = isEmpty;
  exports.isExternal = isExternal;
  exports.isFocusable = isFocusable;
  exports.isFunction = isFunction;
  exports.isImageDom = isImageDom;
  exports.isImagePath = isImagePath;
  exports.isIos = isIos;
  exports.isNull = isNull$1;
  exports.isNullAndUnDef = isNullAndUnDef;
  exports.isNullOrUnDef = isNullOrUnDef;
  exports.isNumber = isNumber;
  exports.isObject = isObject$2;
  exports.isPhone = isPhone;
  exports.isPlainFunction = isPlainFunction;
  exports.isPromise = isPromise;
  exports.isServer = isServer;
  exports.isString = isString$1;
  exports.isStringNumber = isStringNumber;
  exports.isType = isType;
  exports.isUnDef = isUnDef;
  exports.isValidURL = isValidURL;
  exports.layoutIcon = layoutIcon;
  exports.layoutModeAttribute = layoutModeAttribute;
  exports.layoutModeStorageKey = layoutModeStorageKey;
  exports.localeContextKey = localeContextKey;
  exports.lockIcon = lockIcon;
  exports.loginUrlKeyMap = loginUrlKeyMap;
  exports.magicIcon = magicIcon;
  exports.mobileMaxWidthMedia = mobileMaxWidthMedia;
  exports.moblieQQ = moblieQQ;
  exports.moreFilledIcon = moreFilledIcon;
  exports.music = music;
  exports.noticeIcon = noticeIcon;
  exports.ns = ns$1;
  exports.onClickOutside = onClickOutside;
  exports.overallReductionIcon = overallReductionIcon;
  exports.pageMaxWidthSlideStorageKey = pageMaxWidthSlideStorageKey;
  exports.pageMaxWidthVar = pageMaxWidthVar;
  exports.pageNumKey = pageNumKey;
  exports.playgroundIcon = playgroundIcon;
  exports.postDataUpdateSymbol = postDataUpdateSymbol;
  exports.postsContext = postsContext;
  exports.questionFilledIcon = questionFilledIcon;
  exports.readingIcon = readingIcon;
  exports.refreshLeftIcon = refreshLeftIcon;
  exports.refreshRightIcon = refreshRightIcon;
  exports.removeStorageItem = removeStorageItem;
  exports.removeUnit = removeUnit;
  exports.rgbToHex = rgbToHex;
  exports.rocketIcon = rocketIcon;
  exports.scaleIcon = scaleIcon;
  exports.scaleToOriginalIcon = scaleToOriginalIcon;
  exports.shareIcon = shareIcon;
  exports.sizeIcon = size;
  exports.spotlightStorageKey = spotlightStorageKey;
  exports.spotlightStyleStorageKey = spotlightStyleStorageKey;
  exports.successFilledIcon = successFilledIcon;
  exports.tagIcon = tagIcon;
  exports.teekConfigContext = teekConfigContext;
  exports.telegram = telegram;
  exports.themeBgColorStorageKey = themeBgColorStorageKey;
  exports.themeColorAttribute = themeColorAttribute;
  exports.themeColorList = themeColorList;
  exports.themeColorStorageKey = themeColorStorageKey;
  exports.themeIcon = themeIcon;
  exports.thumbsIcon = thumbsIcon;
  exports.topArticleIcon = topArticleIcon;
  exports.topIcon = topIcon;
  exports.touchMedia = touchMedia;
  exports.trackPageview = trackPageview;
  exports.transitionName = transitionName;
  exports.twikooContext = twikooContext;
  exports.umamiAnalytics = umamiAnalytics;
  exports.upperFirst = upperFirst;
  exports.useAllPosts = useAllPosts;
  exports.useAnchorScroll = useAnchorScroll;
  exports.useClipboard = useClipboard;
  exports.useCommon = useCommon;
  exports.useCopyBanner = useCopyBanner;
  exports.useDebounce = useDebounce;
  exports.useElementHover = useElementHover;
  exports.useEventListener = useEventListener;
  exports.useIntersectionObserver = useIntersectionObserver;
  exports.useLocale = useLocale;
  exports.useMediaQuery = useMediaQuery;
  exports.useMounted = useMounted;
  exports.useNamespace = useNamespace;
  exports.usePagePath = usePagePath;
  exports.usePageState = usePageState;
  exports.usePopoverSize = usePopoverSize;
  exports.usePosts = usePosts;
  exports.useRiskLink = useRiskLink;
  exports.useScopeDispose = useScopeDispose;
  exports.useScrollData = useScrollData;
  exports.useSidebar = useSidebar;
  exports.useStorage = useStorage;
  exports.useSwitchData = useSwitchData;
  exports.useTagColor = useTagColor;
  exports.useTeekConfig = useTeekConfig;
  exports.useTextTypes = useTextTypes;
  exports.useThemeColor = useThemeColor;
  exports.useThemeColorList = useThemeColorList;
  exports.useUvPv = useUvPv;
  exports.useViewTransition = useViewTransition;
  exports.useVpRouter = useVpRouter;
  exports.useWatchLogin = useWatchLogin;
  exports.useWindowSize = useWindowSize;
  exports.useWindowTransition = useWindowTransition;
  exports.useWindowTransitionConfig = useWindowTransitionConfig;
  exports.useZIndex = useZIndex;
  exports.userIcon = userIcon;
  exports.varNameList = varNameList;
  exports.verifyModeMap = verifyModeMap;
  exports.version = version;
  exports.viewIcon = viewIcon;
  exports.walineContext = walineContext;
  exports.warningFilledIcon = warningFilledIcon;
  exports.waterIcon = waterIcon;
  exports.weChatPayIcon = weChatPayIcon;
  exports.withBase = withBase;
  exports.zIndexContextKey = zIndexContextKey;
  exports.zhCn = zhCn;
  exports.zoomInIcon = zoomInIcon;
  exports.zoomOutIcon = zoomOutIcon;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
