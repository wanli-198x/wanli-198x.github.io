import crypto from 'crypto';

const replacePlaceholder = (placeholderStr, path) => {
  let result = placeholderStr.replace(/\$UUID(\d*)/gi, (_, numStr) => {
    const length = numStr ? parseInt(numStr, 10) : 6;
    return createRandomUuid(length);
  });
  result = result.replace(/\$PATH(\d*)/gi, (_, numStr) => {
    let length = 6;
    if (numStr) {
      const parsed = parseInt(numStr, 10);
      length = Math.max(6, Math.min(parsed, 10));
    }
    const firstSegment = getFirstPathSegment(path).replace(/^\d+[.\-_]/, "");
    const hasChinese = /[\u4e00-\u9fa5]/.test(firstSegment);
    return hasChinese ? getHashByFirstPath(firstSegment, length) : firstSegment;
  });
  return result;
};
const createRandomUuid = (length = 6) => {
  return (Math.random() + Math.random()).toString(16).slice(2, length + 2);
};
const getFirstPathSegment = (path) => {
  const segments = path.split("/").filter((segment) => segment.trim());
  return segments.length ? segments[0] : "";
};
const getHashByFirstPath = (path, length) => {
  const hash = crypto.createHash("sha256").update(path, "utf8").digest("hex");
  return hash.slice(0, Math.min(length, hash.length));
};
const cleanPathSpaces = (path) => {
  const segments = path.split("/");
  const validSegments = segments.filter((segment) => segment.trim());
  return validSegments.length ? `/${validSegments.join("/")}` : "";
};

export { cleanPathSpaces, createRandomUuid, getFirstPathSegment, replacePlaceholder };
