import { defineComponent, mergeModels, useModel, ref, onMounted, watch, createElementBlock, openBlock, normalizeClass, unref, createElementVNode, withDirectives, createVNode, vModelText, Transition, withCtx, toDisplayString, vShow } from 'vue';
import { useEventListener } from '../../../../composables/useEventListener.mjs';
import 'vitepress';
import { useNamespace } from '../../../../composables/useNamespace.mjs';
import 'vitepress-theme-teek/theme-chalk/tk-copy-banner.css';
import { useElementHover } from '../../../../composables/useElementHover.mjs';
import '../../../../composables/useZIndex.mjs';

const _hoisted_1 = ["name", "min", "max", "disabled", "step"];
var _sfc_main = /* @__PURE__ */ defineComponent({
  ...{ name: "InputSlide" },
  __name: "index",
  props: /* @__PURE__ */ mergeModels({
    name: { default: "Slider" },
    disabled: { type: Boolean },
    min: { default: 0 },
    max: { default: 100 },
    step: { default: 1 },
    format: { type: Function }
  }, {
    "modelValue": { default: 0 },
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const ns = useNamespace("input-slide");
    const inputValue = useModel(__props, "modelValue");
    const inputSliderRef = ref();
    const inputSliderTooltipRef = ref();
    const hovering = useElementHover(inputSliderRef);
    const positioning = ref(false);
    const sliderValueVar = ns.cssVarName("slider-value");
    const sliderMinVar = ns.cssVarName("slider-min");
    const sliderMaxVar = ns.cssVarName("slider-max");
    useEventListener(inputSliderRef, "input", () => {
      if (!inputSliderRef.value) return;
      inputSliderRef.value.style.setProperty(sliderValueVar, inputSliderRef.value.value.toString());
    });
    onMounted(() => {
      if (!inputSliderRef.value) return;
      const inputSliderStyle = inputSliderRef.value.style;
      inputSliderStyle.setProperty(sliderValueVar, inputValue.value.toString());
      inputSliderStyle.setProperty(sliderMinVar, __props.min?.toString() ?? "0");
      inputSliderStyle.setProperty(sliderMaxVar, __props.max?.toString() ?? "100");
    });
    const calTipPosition = (inputElement, inputTooltipElement) => {
      const finalMax = __props.max || 100;
      const finalMin = __props.min || 0;
      const ratio = (inputValue.value - finalMin) / (finalMax - finalMin);
      const rect = inputElement.getBoundingClientRect();
      const tooltipRect = inputTooltipElement.getBoundingClientRect();
      const centeringShift = (tooltipRect.width - 32) / 2;
      inputTooltipElement.style.setProperty("left", `${ratio * (rect.width - 32) - centeringShift}px`);
    };
    watch(hovering, () => {
      positioning.value = true;
      setTimeout(() => {
        if (!hovering.value) {
          positioning.value = false;
          return;
        }
        if (!inputSliderRef.value) {
          positioning.value = false;
          return;
        }
        if (!inputSliderTooltipRef.value) {
          positioning.value = false;
          return;
        }
        calTipPosition(inputSliderRef.value, inputSliderTooltipRef.value);
        positioning.value = false;
      }, 50);
    });
    watch(inputValue, (val) => {
      if (val < __props.min) val = __props.min;
      if (val > __props.max) val = __props.max;
      if (!inputSliderRef.value || !inputSliderTooltipRef.value) return;
      calTipPosition(inputSliderRef.value, inputSliderTooltipRef.value);
    });
    watch(
      () => __props.min,
      (val) => {
        if (inputValue.value >= val) return;
        inputValue.value = val;
      }
    );
    watch(
      () => __props.max,
      (val) => {
        if (inputValue.value <= val) return;
        inputValue.value = val;
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(unref(ns).b())
        },
        [
          createElementVNode(
            "label",
            {
              class: normalizeClass(unref(ns).e("label"))
            },
            [
              withDirectives(createElementVNode("input", {
                ref_key: "inputSliderRef",
                ref: inputSliderRef,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inputValue.value = $event),
                type: "range",
                name: __props.name,
                min: __props.min,
                max: __props.max,
                disabled: __props.disabled,
                step: __props.step,
                class: normalizeClass([unref(ns).e("label__input"), unref(ns).e("label__input-progress"), unref(ns).is("disabled", __props.disabled)])
              }, null, 10, _hoisted_1), [
                [
                  vModelText,
                  inputValue.value,
                  void 0,
                  { number: true }
                ]
              ]),
              createVNode(Transition, {
                name: "fade",
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createElementVNode(
                    "span",
                    {
                      ref_key: "inputSliderTooltipRef",
                      ref: inputSliderTooltipRef,
                      class: normalizeClass([unref(ns).e("label__tooltip"), unref(ns).is("opacity-0", unref(hovering) && positioning.value)])
                    },
                    toDisplayString(!!__props.format ? __props.format(inputValue.value) : inputValue.value),
                    3
                    /* TEXT, CLASS */
                  ), [
                    [vShow, unref(hovering)]
                  ])
                ]),
                _: 1
                /* STABLE */
              })
            ],
            2
            /* CLASS */
          )
        ],
        2
        /* CLASS */
      );
    };
  }
});

export { _sfc_main as default };
