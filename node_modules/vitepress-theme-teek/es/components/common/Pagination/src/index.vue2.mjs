import { defineComponent, mergeModels, useSlots, useModel, computed, watch, provide, h, createElementBlock, openBlock, normalizeClass, unref, Fragment, renderList, createBlock, resolveDynamicComponent } from 'vue';
import 'vitepress';
import { useNamespace } from '../../../../composables/useNamespace.mjs';
import 'vitepress-theme-teek/theme-chalk/tk-copy-banner.css';
import '../../../../composables/useZIndex.mjs';
import arrowLeftIcon from '../../../../static/icons/arrowLeft.mjs';
import arrowRightIcon from '../../../../static/icons/arrowRight.mjs';
import { paginationKey } from './pagination.mjs';
import _sfc_main$5 from './components/prev.vue2.mjs';
import _sfc_main$2 from './components/next.vue2.mjs';
import _sfc_main$4 from './components/jumper.vue2.mjs';
import _sfc_main$1 from './components/total.vue2.mjs';
import _sfc_main$3 from './components/pager.vue2.mjs';

var _sfc_main = /* @__PURE__ */ defineComponent({
  ...{ name: "Pagination" },
  __name: "index",
  props: /* @__PURE__ */ mergeModels({
    total: {},
    pageCount: {},
    pagerCount: { default: 7 },
    layout: { default: ["prev, pager, next, jumper, ->, total"].join(", ") },
    prevText: {},
    prevIcon: { default: () => arrowLeftIcon },
    nextText: {},
    nextIcon: { default: () => arrowRightIcon },
    size: { default: "default" },
    background: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    hideOnSinglePage: { type: Boolean, default: false }
  }, {
    "currentPage": { type: Number, default: 1 },
    "currentPageModifiers": {},
    "pageSize": { type: Number, default: 10 },
    "pageSizeModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["size-change", "change", "current-change", "prev-click", "next-click"], ["update:currentPage", "update:pageSize"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const ns = useNamespace("pagination");
    const slots = useSlots();
    const currentPageModel = useModel(__props, "currentPage");
    const pageSizeModel = useModel(__props, "pageSize");
    const isAbsent = (v) => typeof v !== "number";
    const pageCountBridge = computed(() => {
      let pageCount = 0;
      if (!isAbsent(props.pageCount)) pageCount = props.pageCount;
      else if (!isAbsent(props.total)) pageCount = Math.max(1, Math.ceil(props.total / pageSizeModel.value));
      return pageCount;
    });
    watch(pageCountBridge, (val) => {
      if (currentPageModel.value > val) currentPageModel.value = val;
    });
    watch(
      [currentPageModel, pageSizeModel],
      (value) => {
        emit("change", ...value);
      },
      { flush: "post" }
    );
    const handleSizeChange = (val) => {
      pageSizeModel.value = val;
      emit("size-change", pageSizeModel.value);
      const newPageCount = pageCountBridge.value;
      if (currentPageModel.value > newPageCount) currentPageModel.value = newPageCount;
    };
    const prev = () => {
      if (props.disabled) return;
      handleCurrentChange(currentPageModel.value - 1);
      emit("prev-click", currentPageModel.value);
    };
    const next = () => {
      if (props.disabled) return;
      handleCurrentChange(currentPageModel.value + 1);
      emit("next-click", currentPageModel.value);
    };
    const handleCurrentChange = (val) => {
      currentPageModel.value = val;
      const newPageCount = pageCountBridge.value;
      if (currentPageModel.value < 1) currentPageModel.value = 1;
      else if (currentPageModel.value > newPageCount) currentPageModel.value = newPageCount;
      emit("current-change", currentPageModel.value);
    };
    const addClass = (element, cls) => {
      if (element) {
        if (!element.props) element.props = {};
        element.props.class = [element.props.class, cls].join(" ");
      }
    };
    provide(paginationKey, {
      pageCount: pageCountBridge,
      disabled: computed(() => props.disabled),
      currentPage: currentPageModel,
      changeEvent: handleCurrentChange,
      handleSizeChange
    });
    const components = computed(() => {
      if (!props.layout) return [];
      if (props.hideOnSinglePage && pageCountBridge.value <= 1) return [];
      const components2 = props.layout.split(",").map((item) => item.trim());
      const rootChildren = [];
      const rightWrapperChildren = [];
      const rightWrapperRoot = h("div", { class: ns.e("right-wrapper") }, rightWrapperChildren);
      let haveRightWrapper = false;
      components2.forEach((c) => {
        if (c === "->") {
          haveRightWrapper = true;
          return;
        }
        if (!haveRightWrapper) rootChildren.push(componentMap.value[c]);
        else rightWrapperChildren.push(componentMap.value[c]);
      });
      addClass(rootChildren[0], ns.is("first"));
      addClass(rootChildren[rootChildren.length - 1], ns.is("last"));
      if (rightWrapperChildren.length > 0) {
        addClass(rightWrapperChildren[0], ns.is("first"));
        addClass(rightWrapperChildren[rightWrapperChildren.length - 1], ns.is("last"));
        rootChildren.push(rightWrapperRoot);
      }
      return rootChildren;
    });
    const componentMap = computed(() => ({
      prev: h(_sfc_main$5, {
        disabled: props.disabled,
        currentPage: currentPageModel.value,
        prevText: props.prevText,
        prevIcon: props.prevIcon,
        onClick: prev
      }),
      jumper: h(_sfc_main$4, {
        size: props.size
      }),
      pager: h(_sfc_main$3, {
        currentPage: currentPageModel.value,
        pageCount: pageCountBridge.value,
        pagerCount: props.pagerCount,
        onChange: handleCurrentChange,
        disabled: props.disabled
      }),
      next: h(_sfc_main$2, {
        disabled: props.disabled,
        currentPage: currentPageModel.value,
        pageCount: pageCountBridge.value,
        nextText: props.nextText,
        nextIcon: props.nextIcon,
        onClick: next
      }),
      slot: slots?.default?.() ?? null,
      total: h(_sfc_main$1, { total: isAbsent(props.total) ? 0 : props.total })
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass([unref(ns).b(), unref(ns).is("background", __props.background), unref(ns).m(__props.size)])
        },
        [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList(components.value, (component) => {
              return openBlock(), createBlock(resolveDynamicComponent(component), { key: component });
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ],
        2
        /* CLASS */
      );
    };
  }
});

export { _sfc_main as default };
