import { computed, toValue, ref, watch } from 'vue';
import { useScopeDispose } from './useScopeDispose.mjs';

const useSwitchData = (dataList, options = {}) => {
  const {
    timeout = 4e3,
    shuffle = false,
    reloadWhenDataChanged = false,
    onBeforeUpdate,
    onUpdate,
    onAfterUpdate
  } = options;
  const dataListComputed = computed(() => toValue(dataList) || []);
  const index = ref(-1);
  let timer;
  const splitOutRandom = (dataList2) => {
    let newIndex;
    do {
      newIndex = Math.floor(Math.random() * dataList2.length);
    } while (newIndex === index.value);
    index.value = newIndex;
    return dataList2[newIndex];
  };
  const data = ref(shuffle ? splitOutRandom(dataListComputed.value) : dataListComputed.value[0]);
  const splitOutOrder = (dataList2) => {
    index.value = (index.value + 1) % dataList2.length;
    return dataList2[index.value];
  };
  const clearTimer = () => {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  const startTimer = () => {
    clearTimer();
    if (timeout > 0) {
      timer = setTimeout(start, timeout);
    }
  };
  const start = () => {
    const dataListConst = dataListComputed.value;
    if (dataListConst.length < 1) return;
    if (dataListConst.length === 1) {
      data.value = dataListConst[0];
      return;
    }
    startTimer();
    let newValue;
    if (shuffle) newValue = splitOutRandom(dataListConst);
    else newValue = splitOutOrder(dataListConst);
    if (newValue === data.value) return;
    onBeforeUpdate?.(newValue);
    if (onUpdate) return onUpdate(data, newValue);
    data.value = newValue;
    onAfterUpdate?.(newValue);
  };
  const stop = (restore = false) => {
    clearTimer();
    if (restore) index.value = -1;
  };
  const restart = () => {
    stop(true);
    start();
  };
  if (reloadWhenDataChanged) watch(dataListComputed, () => restart());
  useScopeDispose(stop);
  return { data, index, start, stop, restart };
};

export { useSwitchData };
