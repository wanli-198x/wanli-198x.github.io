'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Vue = require('vue');
var onClickOutside = require('../../../../composables/onClickOutside.js');
require('vitepress');
var index = require('../../../../helper/dist/index.js');
var useNamespace = require('../../../../composables/useNamespace.js');
require('vitepress-theme-teek/theme-chalk/tk-copy-banner.css');
var useElementHover = require('../../../../composables/useElementHover.js');
var usePopoverSize = require('../../../../composables/usePopoverSize.js');
var useZIndex = require('../../../../composables/useZIndex.js');
var index$1 = require('../../FocusTrap/src/index.vue.js');
var useFocusTrap = require('./useFocusTrap.js');

var _sfc_main = /* @__PURE__ */ Vue.defineComponent({
  ...{ name: "Popover" },
  __name: "index",
  props: /* @__PURE__ */ Vue.mergeModels({
    trigger: { default: "hover" },
    placement: { default: "bottom" },
    content: { default: "" },
    width: {},
    height: {},
    offset: { default: 0 },
    xOffset: { default: 0 },
    yOffset: { default: 0 },
    disabled: { type: Boolean, default: false },
    transition: { type: Boolean, default: true },
    transitionName: {},
    triggerEl: {},
    zIndex: {},
    popperClass: {},
    popperStyle: {},
    beforePopup: { type: Function }
  }, {
    "modelValue": { default: false },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ Vue.mergeModels(["focus", "blur", "close"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const ns = useNamespace.useNamespace("popover");
    const { nextZIndex } = useZIndex.useZIndex();
    const zIndexRef = Vue.ref(__props.zIndex ?? nextZIndex());
    const visible = Vue.useModel(__props, "modelValue");
    const triggerRef = Vue.ref();
    const popoverRef = Vue.ref();
    const isHovered = useElementHover.useElementHover(triggerRef);
    const popupVisible = useElementHover.useElementHover(popoverRef);
    const triggerElComputed = Vue.computed(() => __props.triggerEl || triggerRef.value);
    const { top, right, left, bottom, update } = usePopoverSize.usePopoverSize(triggerElComputed, popoverRef, {
      placement: __props.placement,
      offset: __props.offset,
      xOffset: __props.xOffset,
      yOffset: __props.yOffset
    });
    const popupStyle = Vue.computed(() => {
      return {
        zIndex: zIndexRef.value,
        top: index.addUnit(top.value),
        right: index.addUnit(right.value),
        bottom: index.addUnit(bottom.value),
        left: index.addUnit(left.value),
        width: index.addUnit(__props.width),
        height: index.addUnit(__props.height),
        ...__props.popperStyle
      };
    });
    const calculatePopoverPosition = () => {
      if (!triggerRef.value || !popoverRef.value) {
        visible.value = false;
        return;
      }
      update();
      const result = __props.beforePopup?.({
        top: top.value,
        right: right.value,
        bottom: left.value,
        left: bottom.value,
        triggerElement: __props.triggerEl || triggerRef.value,
        popoverElement: popoverRef.value
      }) ?? {};
      if (result.top) top.value = result.top;
      if (result.right) right.value = result.right;
      if (result.bottom) bottom.value = result.bottom;
      if (result.left) left.value = result.left;
    };
    if (__props.trigger === "hover") {
      Vue.watch(isHovered, (newVal) => {
        if (__props.trigger === "hover") visible.value = newVal;
      });
    }
    const toggleVisible = (event) => {
      if (event === __props.trigger) visible.value = !visible.value;
    };
    Vue.watch(visible, (newVal) => {
      if (newVal) calculatePopoverPosition();
    });
    Vue.watch(popupVisible, (newVal) => {
      if (__props.trigger === "hover") visible.value = newVal;
    });
    onClickOutside.onClickOutside(popoverRef, (e) => {
      if (e.composedPath().includes(triggerRef.value)) return;
      if (__props.trigger === "hover") return;
      if (visible.value !== false) visible.value = false;
    });
    const popoverContainerId = ns.join("popover-container");
    Vue.onBeforeMount(() => {
      const popoverContainer = document.querySelector(`#${popoverContainerId}`);
      if (!popoverContainer) {
        const container = document.createElement("div");
        container.id = popoverContainerId;
        document.body.appendChild(container);
      }
    });
    const emit = __emit;
    const {
      focusStartRef,
      onFocusAfterTrapped,
      onFocusAfterReleased,
      onFocusInTrap,
      onFocusoutPrevented,
      onReleaseRequested
    } = useFocusTrap.useFocusTrap(visible, emit);
    return (_ctx, _cache) => {
      return Vue.openBlock(), Vue.createElementBlock(
        Vue.Fragment,
        null,
        [
          Vue.createElementVNode(
            "div",
            Vue.mergeProps({
              ref_key: "triggerRef",
              ref: triggerRef,
              onClick: _cache[0] || (_cache[0] = ($event) => toggleVisible("click")),
              onContextmenu: _cache[1] || (_cache[1] = ($event) => toggleVisible("contextmenu")),
              onFocus: _cache[2] || (_cache[2] = ($event) => toggleVisible("focus")),
              onTouchstart: _cache[3] || (_cache[3] = ($event) => visible.value = !visible.value)
            }, _ctx.$attrs),
            [
              Vue.renderSlot(_ctx.$slots, "reference")
            ],
            16
            /* FULL_PROPS */
          ),
          (Vue.openBlock(), Vue.createBlock(Vue.Teleport, {
            to: `#${Vue.unref(popoverContainerId)}`
          }, [
            Vue.createVNode(Vue.Transition, {
              name: __props.transition ? __props.transitionName || Vue.unref(ns).join("fade-linear") : ""
            }, {
              default: Vue.withCtx(() => [
                !__props.disabled ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock(
                  "div",
                  {
                    key: 0,
                    ref_key: "popoverRef",
                    ref: popoverRef,
                    style: Vue.normalizeStyle(popupStyle.value),
                    class: Vue.normalizeClass([Vue.unref(ns).b(), __props.popperClass]),
                    onClick: _cache[4] || (_cache[4] = Vue.withModifiers(() => {
                    }, ["stop"])),
                    onTouchstart: _cache[5] || (_cache[5] = Vue.withModifiers(() => {
                    }, ["stop"]))
                  },
                  [
                    Vue.createVNode(Vue.unref(index$1.default), {
                      loop: "",
                      trapped: visible.value,
                      "focus-trap-el": popoverRef.value,
                      "focus-start-el": Vue.unref(focusStartRef),
                      onFocusAfterTrapped: Vue.unref(onFocusAfterTrapped),
                      onFocusAfterReleased: Vue.unref(onFocusAfterReleased),
                      onFocusin: Vue.unref(onFocusInTrap),
                      onFocusoutPrevented: Vue.unref(onFocusoutPrevented),
                      onReleaseRequested: Vue.unref(onReleaseRequested)
                    }, {
                      default: Vue.withCtx(() => [
                        Vue.renderSlot(_ctx.$slots, "default", {}, () => [
                          Vue.createTextVNode(
                            Vue.toDisplayString(__props.content),
                            1
                            /* TEXT */
                          )
                        ])
                      ]),
                      _: 3
                      /* FORWARDED */
                    }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
                  ],
                  38
                  /* CLASS, STYLE, NEED_HYDRATION */
                )), [
                  [Vue.vShow, visible.value]
                ]) : Vue.createCommentVNode("v-if", true)
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["name"])
          ], 8, ["to"]))
        ],
        64
        /* STABLE_FRAGMENT */
      );
    };
  }
});

exports.default = _sfc_main;
