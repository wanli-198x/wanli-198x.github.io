'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Vue = require('vue');
var useEscapeKeydown = require('./useEscapeKeydown.js');
var index = require('../../../../helper/dist/index.js');
var utils = require('./utils.js');
var tokens = require('./tokens.js');

var _sfc_main = Vue.defineComponent({
  name: "FocusTrap",
  inheritAttrs: false,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [tokens.ON_TRAP_FOCUS_EVT, tokens.ON_RELEASE_FOCUS_EVT, "focusin", "focusout", "focusout-prevented", "release-requested"],
  setup(props, { emit }) {
    const forwardRef = Vue.ref();
    let lastFocusBeforeTrapped;
    let lastFocusAfterTrapped;
    const { focusReason } = utils.useFocusReason();
    useEscapeKeydown.useEscapeKeydown((event) => {
      if (props.trapped && !focusLayer.paused) emit("release-requested", event);
    });
    const focusLayer = {
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    };
    const onKeydown = (e) => {
      if (!props.loop && !props.trapped) return;
      if (focusLayer.paused) return;
      const { code, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
      const { loop } = props;
      const isTabbing = code === "Tab" && !altKey && !ctrlKey && !metaKey;
      const currentFocusingEl = document.activeElement;
      if (isTabbing && currentFocusingEl) {
        const container = currentTarget;
        const [first, last] = utils.getEdges(container);
        const isTabbable = first && last;
        if (!isTabbable) {
          if (currentFocusingEl === container) {
            const focusoutPreventedEvent = utils.createFocusOutPreventedEvent({
              focusReason: focusReason.value
            });
            emit("focusout-prevented", focusoutPreventedEvent);
            if (!focusoutPreventedEvent.defaultPrevented) e.preventDefault();
          }
        } else {
          if (!shiftKey && currentFocusingEl === last) {
            const focusoutPreventedEvent = utils.createFocusOutPreventedEvent({
              focusReason: focusReason.value
            });
            emit("focusout-prevented", focusoutPreventedEvent);
            if (!focusoutPreventedEvent.defaultPrevented) {
              e.preventDefault();
              if (loop) utils.tryFocus(first, true);
            }
          } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
            const focusoutPreventedEvent = utils.createFocusOutPreventedEvent({
              focusReason: focusReason.value
            });
            emit("focusout-prevented", focusoutPreventedEvent);
            if (!focusoutPreventedEvent.defaultPrevented) {
              e.preventDefault();
              if (loop) utils.tryFocus(last, true);
            }
          }
        }
      }
    };
    Vue.provide(tokens.FOCUS_TRAP_INJECTION_KEY, {
      focusTrapRef: forwardRef,
      onKeydown
    });
    Vue.watch(
      () => props.focusTrapEl,
      (focusTrapEl) => {
        if (focusTrapEl) forwardRef.value = focusTrapEl;
      },
      { immediate: true }
    );
    Vue.watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
      if (forwardRef2) {
        forwardRef2.addEventListener("keydown", onKeydown);
        forwardRef2.addEventListener("focusin", onFocusIn);
        forwardRef2.addEventListener("focusout", onFocusOut);
      }
      if (oldForwardRef) {
        oldForwardRef.removeEventListener("keydown", onKeydown);
        oldForwardRef.removeEventListener("focusin", onFocusIn);
        oldForwardRef.removeEventListener("focusout", onFocusOut);
      }
    });
    const trapOnFocus = (e) => {
      emit(tokens.ON_TRAP_FOCUS_EVT, e);
    };
    const releaseOnFocus = (e) => emit(tokens.ON_RELEASE_FOCUS_EVT, e);
    const onFocusIn = (e) => {
      const trapContainer = forwardRef.value;
      if (!trapContainer) return;
      const target = e.target;
      const relatedTarget = e.relatedTarget;
      const isFocusedInTrap = target && trapContainer.contains(target);
      if (!props.trapped) {
        const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
        if (!isPrevFocusedInTrap) lastFocusBeforeTrapped = relatedTarget;
      }
      if (isFocusedInTrap) emit("focusin", e);
      if (focusLayer.paused) return;
      if (props.trapped) {
        if (isFocusedInTrap) lastFocusAfterTrapped = target;
        else utils.tryFocus(lastFocusAfterTrapped, true);
      }
    };
    const onFocusOut = (e) => {
      const trapContainer = forwardRef.value;
      if (focusLayer.paused || !trapContainer) return;
      if (props.trapped) {
        const relatedTarget = e.relatedTarget;
        if (!relatedTarget && !trapContainer.contains(relatedTarget)) {
          setTimeout(() => {
            if (!focusLayer.paused && props.trapped) {
              const focusoutPreventedEvent = utils.createFocusOutPreventedEvent({
                focusReason: focusReason.value
              });
              emit("focusout-prevented", focusoutPreventedEvent);
              if (!focusoutPreventedEvent.defaultPrevented) {
                utils.tryFocus(lastFocusAfterTrapped, true);
              }
            }
          }, 0);
        }
      } else {
        const target = e.target;
        const isFocusedInTrap = target && trapContainer.contains(target);
        if (!isFocusedInTrap) emit("focusout", e);
      }
    };
    async function startTrap() {
      await Vue.nextTick();
      const trapContainer = forwardRef.value;
      if (trapContainer) {
        utils.focusableStack.push(focusLayer);
        const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
        lastFocusBeforeTrapped = prevFocusedElement;
        const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
        if (!isPrevFocusContained) {
          const focusEvent = new Event(tokens.FOCUS_AFTER_TRAPPED, tokens.FOCUS_AFTER_TRAPPED_OPTS);
          trapContainer.addEventListener(tokens.FOCUS_AFTER_TRAPPED, trapOnFocus);
          trapContainer.dispatchEvent(focusEvent);
          if (!focusEvent.defaultPrevented) {
            Vue.nextTick(() => {
              let focusStartEl = props.focusStartEl;
              if (!index.isString(focusStartEl)) {
                utils.tryFocus(focusStartEl);
                if (document.activeElement !== focusStartEl) focusStartEl = "first";
              }
              if (focusStartEl === "first") utils.focusFirstDescendant(utils.obtainAllFocusableElements(trapContainer), true);
              if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                utils.tryFocus(trapContainer);
              }
            });
          }
        }
      }
    }
    function stopTrap() {
      const trapContainer = forwardRef.value;
      if (trapContainer) {
        trapContainer.removeEventListener(tokens.FOCUS_AFTER_TRAPPED, trapOnFocus);
        const releasedEvent = new CustomEvent(tokens.FOCUS_AFTER_RELEASED, {
          ...tokens.FOCUS_AFTER_TRAPPED_OPTS,
          detail: {
            focusReason: focusReason.value
          }
        });
        trapContainer.addEventListener(tokens.FOCUS_AFTER_RELEASED, releaseOnFocus);
        trapContainer.dispatchEvent(releasedEvent);
        if (!releasedEvent.defaultPrevented && (focusReason.value === "keyboard" || !utils.isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
          utils.tryFocus(lastFocusBeforeTrapped ?? document.body);
        }
        trapContainer.removeEventListener(tokens.FOCUS_AFTER_RELEASED, releaseOnFocus);
        utils.focusableStack.remove(focusLayer);
      }
    }
    Vue.onMounted(() => {
      if (props.trapped) startTrap();
      Vue.watch(
        () => props.trapped,
        (trapped) => {
          if (trapped) startTrap();
          else stopTrap();
        }
      );
    });
    Vue.onBeforeUnmount(() => {
      if (props.trapped) stopTrap();
      if (forwardRef.value) {
        forwardRef.value.removeEventListener("keydown", onKeydown);
        forwardRef.value.removeEventListener("focusin", onFocusIn);
        forwardRef.value.removeEventListener("focusout", onFocusOut);
        forwardRef.value = void 0;
      }
    });
    return {
      onKeydown
    };
  }
});

exports.default = _sfc_main;
