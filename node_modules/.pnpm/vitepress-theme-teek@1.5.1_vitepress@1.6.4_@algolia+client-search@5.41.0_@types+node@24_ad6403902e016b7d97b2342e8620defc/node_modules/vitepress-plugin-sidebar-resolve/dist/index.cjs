'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const node_path = require('node:path');
const node_fs = require('node:fs');
const matter = require('gray-matter');
const vite = require('vite');
const picocolors = require('picocolors');
const fs = require('fs');
const path = require('path');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const matter__default = /*#__PURE__*/_interopDefaultCompat(matter);
const picocolors__default = /*#__PURE__*/_interopDefaultCompat(picocolors);

const getTitleFromMarkdown = (mdContent) => {
  const lines = mdContent.trimStart().split(/\r?\n/);
  for (const line of lines) {
    if (line.startsWith("# ")) {
      return line.substring(2).trim();
    }
  }
  return void 0;
};
const isIllegalIndex = (index) => {
  return isNaN(index) || index < 0;
};
const isSome = (arr, name) => {
  return arr.some((item) => item === name || item instanceof RegExp && item.test(name));
};

const version = "1.2.1";

const logger = vite.createLogger("info", {
  prefix: `[vitepress-plugin-sidebar-resolve v${version}]`
});
const info = (message, level = "green", option = { timestamp: true }) => {
  logger.info(picocolors__default[level](message), option);
};
const warn = (message, level = "yellow", option = { timestamp: true }) => {
  logger.warn(picocolors__default[level](message), option);
};
const warnOnce = (message, level = "yellow", option = { timestamp: true }) => {
  logger.info(picocolors__default[level](message), option);
};
const error = (message, level = "red", option = { timestamp: true }) => {
  logger.error(picocolors__default[level](message), option);
};
const logger$1 = {
  info,
  warn,
  warnOnce,
  error
};

const resolveFileName = (filename, filePath, separator = ".") => {
  if (!fs.existsSync(filePath)) return { index: "", title: filename, type: "", name: filename };
  const stat = fs.statSync(filePath);
  if (separator !== "." && isExtraSeparator(filename, separator)) {
    return parseExtraSeparator(filename, stat.isDirectory(), separator);
  }
  if (filename.includes(".")) {
    return parseDotSeparator(filename, stat.isDirectory());
  }
  return { index: "", title: filename, type: "", name: filename };
};
const parseDotSeparator = (filename, isDirectory) => {
  const parts = filename.split(".");
  if (parts.length === 2) {
    const index = parts[0] === "index" ? "0" : parts[0];
    const title = isDirectory ? parts[1] : parts[0];
    const type = isDirectory ? "" : parts[1];
    const name = parts[0];
    return { index, title, type, name };
  } else {
    const firstDotIndex = filename.indexOf(".");
    const lastDotIndex = filename.lastIndexOf(".");
    const index = filename.substring(0, firstDotIndex);
    const title = filename.substring(firstDotIndex + 1, lastDotIndex);
    const type = isDirectory ? "" : filename.substring(lastDotIndex + 1);
    const name = isDirectory ? filename : filename.substring(0, lastDotIndex);
    return { index, title, type, name };
  }
};
const isExtraSeparator = (filename, separator) => {
  if (!filename.includes(separator)) return false;
  const parts = filename.split(separator, 2);
  if (!/^\d+$/.test(parts[0])) return false;
  return true;
};
const parseExtraSeparator = (filename, isDirectory, separator) => {
  const firstSeparatorIndex = filename.indexOf(separator);
  const lastDotIndex = filename.lastIndexOf(".");
  const index = filename.substring(0, firstSeparatorIndex);
  const title = isDirectory ? filename.substring(firstSeparatorIndex + 1) : filename.substring(firstSeparatorIndex + 1, lastDotIndex);
  const type = isDirectory ? "" : filename.substring(lastDotIndex + 1);
  const name = isDirectory ? filename : filename.substring(0, lastDotIndex);
  return { index, title, type, name };
};
const getInfoFromMarkdownDir = (root, dirOrFilename) => {
  const state = {
    title: void 0,
    sort: void 0,
    prefix: "",
    suffix: ""
  };
  const filePaths = [
    path.join(root, dirOrFilename, "index.md"),
    path.join(root, dirOrFilename, "index.MD"),
    path.join(root, dirOrFilename, dirOrFilename + ".md")
  ];
  for (const filePath of filePaths) {
    if (!fs.existsSync(filePath)) continue;
    const content = fs.readFileSync(filePath, "utf-8");
    const { data: { title, sidebarSort, sidebarPrefix, sidebarSuffix } = {}, content: mdContent } = matter__default(content, {});
    const t = title || getTitleFromMarkdown(mdContent);
    if (!state.title) state.title = t;
    if (!state.sort) state.sort = sidebarSort;
    if (!state.prefix) state.prefix = sidebarPrefix;
    if (!state.suffix) state.suffix = sidebarSuffix;
  }
  return state;
};

const DEFAULT_IGNORE_DIR = ["node_modules", "dist", ".vitepress", "public"];
const createFilePathSidebar = (option = {}, prefix = "/") => {
  const {
    path,
    ignoreList = [],
    scannerRootMd = true,
    collapsed,
    titleFormMd = false,
    initItems = true,
    initItemsText = false,
    sidebarResolved,
    ignoreWarn = false,
    indexSeparator,
    prefixTransform,
    suffixTransform,
    type = "object",
    rootTitle = "Root"
  } = option;
  const isSidebarObject = type === "object";
  if (!path) return isSidebarObject ? {} : [];
  prefix = prefix.replace(/\/$/, "") + "/";
  const sidebarObj = {};
  const sidebarArray = [];
  const key = prefix === "/" ? prefix : `/${prefix}`;
  if (scannerRootMd) {
    const rootSidebarItems = createSidebarItems$1(path, { ...option, ignoreIndexMd: true }, key, scannerRootMd);
    if (rootSidebarItems?.length) {
      if (isSidebarObject) sidebarObj[key] = rootSidebarItems;
      else sidebarArray.push({ text: rootTitle, items: rootSidebarItems });
    }
  }
  const dirPaths = readDirPaths(path, ignoreList);
  dirPaths.forEach((dirPath) => {
    const fileName = node_path.basename(dirPath);
    const sidebarItems = createSidebarItems$1(dirPath, option, `${key}${fileName}/`);
    if (!ignoreWarn && !sidebarItems.length) {
      return logger$1.warn(`\u8BE5\u76EE\u5F55 '${dirPath}' \u5185\u90E8\u6CA1\u6709\u4EFB\u4F55\u6587\u4EF6\u6216\u6587\u4EF6\u5E8F\u53F7\u51FA\u9519\uFF0C\u5C06\u5FFD\u7565\u751F\u6210\u5BF9\u5E94\u4FA7\u8FB9\u680F`);
    }
    const { name, title } = resolveFileName(fileName, dirPath, indexSeparator);
    const info = getInfoFromMarkdownDir(dirPath, fileName);
    const mdTitle = titleFormMd ? info.title : "";
    const sidebarPrefix = (info.prefix && (prefixTransform?.(info.prefix) ?? info.prefix)) ?? "";
    const sidebarSuffix = (info.suffix && (suffixTransform?.(info.suffix) ?? info.suffix)) ?? "";
    const text = sidebarPrefix + (mdTitle || title) + sidebarSuffix;
    const sidebarItem = {
      text,
      collapsed: typeof collapsed === "function" ? collapsed(prefix + name, text) : collapsed,
      items: sidebarItems
    };
    if (isSidebarObject) {
      sidebarObj[`${key}${fileName}/`] = initItems ? [{ ...sidebarItem, text: initItemsText ? text : "" }] : sidebarItems;
    } else sidebarArray.push(sidebarItem);
  });
  const finalSidebar = isSidebarObject ? sidebarObj : sidebarArray;
  return sidebarResolved?.(finalSidebar) ?? finalSidebar;
};
const readDirPaths = (sourceDir, ignoreList = []) => {
  const dirPaths = [];
  if (!node_fs.existsSync(sourceDir)) return dirPaths;
  const ignoreListAll = [...DEFAULT_IGNORE_DIR, ...ignoreList];
  const dirOrFilenames = node_fs.readdirSync(sourceDir);
  dirOrFilenames.forEach((dirOrFilename) => {
    const secondDirPath = node_path.resolve(sourceDir, dirOrFilename);
    if (!node_fs.existsSync(secondDirPath)) return;
    if (!isSome(ignoreListAll, dirOrFilename) && node_fs.statSync(secondDirPath).isDirectory()) {
      dirPaths.push(secondDirPath);
    }
  });
  return dirPaths;
};
const createSidebarItems$1 = (root, option, prefix = "/", onlyScannerRootMd = false) => {
  const {
    collapsed,
    ignoreList = [],
    ignoreIndexMd = false,
    fileIndexPrefix = false,
    sidebarItemsResolved,
    beforeCreateSidebarItems,
    titleFormMd = false,
    ignoreWarn = false,
    sort = true,
    defaultSortNum = 9999,
    sortNumFromFileName = false,
    indexSeparator,
    prefixTransform,
    suffixTransform
  } = option;
  const ignoreListAll = [...DEFAULT_IGNORE_DIR, ...ignoreList];
  let sidebarItems = [];
  const sidebarItemsNoIndex = [];
  let dirOrFilenames = node_fs.readdirSync(root);
  dirOrFilenames = beforeCreateSidebarItems?.(dirOrFilenames) ?? dirOrFilenames;
  dirOrFilenames.forEach((dirOrFilename) => {
    if (isSome(ignoreListAll, dirOrFilename)) return [];
    const filePath = node_path.resolve(root, dirOrFilename);
    if (!node_fs.existsSync(filePath)) return;
    const { index: indexStr, title, type, name } = resolveFileName(dirOrFilename, filePath, indexSeparator);
    const index = parseInt(indexStr, 10);
    if (!ignoreWarn && fileIndexPrefix && isIllegalIndex(index)) {
      logger$1.warn(`\u8BE5\u6587\u4EF6 '${filePath}' \u5E8F\u53F7\u51FA\u9519\uFF0C\u8BF7\u586B\u5199\u6B63\u786E\u7684\u5E8F\u53F7`);
      return [];
    }
    if (!ignoreWarn && sidebarItems[index]) logger$1.warn(`\u8BE5\u6587\u4EF6 '${filePath}' \u7684\u5E8F\u53F7\u5728\u540C\u4E00\u7EA7\u522B\u4E2D\u91CD\u590D\u51FA\u73B0\uFF0C\u5C06\u4F1A\u88AB\u8986\u76D6`);
    if (!onlyScannerRootMd && node_fs.statSync(filePath).isDirectory()) {
      const info = getInfoFromMarkdownDir(root, dirOrFilename);
      const mdTitle = titleFormMd ? info.title : "";
      const sidebarPrefix = (info.prefix && (prefixTransform?.(info.prefix) ?? info.prefix)) ?? "";
      const sidebarSuffix = (info.suffix && (suffixTransform?.(info.suffix) ?? info.suffix)) ?? "";
      const text = sidebarPrefix + (mdTitle || title) + sidebarSuffix;
      const childSidebarItems = createSidebarItems$1(filePath, option, `${prefix}${dirOrFilename}/`);
      let sidebarItem = {
        text,
        collapsed: typeof collapsed === "function" ? collapsed(prefix + name, text) : collapsed,
        items: childSidebarItems
      };
      if (sort) {
        sidebarItem = {
          ...sidebarItem,
          // 对子侧边栏进行排序
          items: childSidebarItems.sort((a, b) => (a.sort || defaultSortNum) - (b.sort || defaultSortNum)).map((item) => {
            delete item.sort;
            return item;
          }),
          sort: sortNumFromFileName ? index : info.sort
        };
      }
      if (isIllegalIndex(index)) sidebarItemsNoIndex.push(sidebarItem);
      else sidebarItems[index] = sidebarItem;
    } else {
      if (onlyScannerRootMd && dirOrFilename === "index.md") return [];
      if (ignoreIndexMd && ["index.md", "index.MD"].includes(dirOrFilename)) return [];
      if (!["md", "MD"].includes(type)) {
        if (!ignoreWarn && !onlyScannerRootMd) logger$1.warn(`\u8BE5\u6587\u4EF6 '${filePath}' \u975E .md \u683C\u5F0F\u6587\u4EF6\uFF0C\u4E0D\u652F\u6301\u8BE5\u6587\u4EF6\u7C7B\u578B`);
        return [];
      }
      const content = node_fs.readFileSync(filePath, "utf-8");
      const {
        data: { title: frontmatterTitle, sidebar = true, sidebarSort, sidebarPrefix, sidebarSuffix } = {},
        content: mdContent
      } = matter__default(content, {});
      if (!sidebar) return [];
      const mdTitle = titleFormMd ? getTitleFromMarkdown(mdContent) : "";
      const finalSidebarPrefix = (sidebarPrefix && (prefixTransform?.(sidebarPrefix) ?? sidebarPrefix)) ?? "";
      const finalSidebarSuffix = (sidebarSuffix && (suffixTransform?.(sidebarSuffix) ?? sidebarSuffix)) ?? "";
      const text = finalSidebarPrefix + (frontmatterTitle || mdTitle || title) + finalSidebarSuffix;
      let sidebarItem = {
        text,
        collapsed: typeof collapsed === "function" ? collapsed(prefix + name, text) : collapsed,
        link: prefix + name
      };
      if (sort) sidebarItem = { ...sidebarItem, sort: sortNumFromFileName ? index : sidebarSort };
      if (isIllegalIndex(index)) sidebarItemsNoIndex.push(sidebarItem);
      else sidebarItems[index] = sidebarItem;
    }
  });
  sidebarItems = [...sidebarItems, ...sidebarItemsNoIndex].filter(Boolean);
  if (sort) {
    sidebarItems = sidebarItems.sort((a, b) => (a.sort || defaultSortNum) - (b.sort || defaultSortNum)).map((item) => {
      delete item.sort;
      return item;
    });
  }
  return sidebarItemsResolved?.(sidebarItems) ?? sidebarItems;
};

function createRewritesSidebar(rewrites = {}, option = {}, prefix = "/") {
  const {
    path,
    ignoreList = [],
    scannerRootMd = true,
    collapsed,
    titleFormMd = false,
    initItems = true,
    initItemsText = false,
    sidebarResolved,
    ignoreWarn = false,
    checkRewritesPrefix = false,
    indexSeparator,
    prefixTransform,
    suffixTransform,
    type = "object",
    rootTitle = "Root"
  } = option;
  const isSidebarObject = type === "object";
  if (!path) return isSidebarObject ? {} : [];
  prefix = prefix.replace(/\/$/, "") + "/";
  const dirStructure = buildDirectoryStructure(rewrites);
  const sidebarObj = {};
  const sidebarArray = [];
  if (scannerRootMd) {
    const key = prefix === "/" ? prefix : `/${prefix}`;
    const rootSidebarItems = createSidebarItems(
      dirStructure,
      path,
      { ...option, ignoreIndexMd: true },
      key,
      scannerRootMd
    );
    if (rootSidebarItems.length > 0) {
      if (isSidebarObject) sidebarObj[key] = rootSidebarItems;
      else sidebarArray.push({ text: rootTitle, items: rootSidebarItems });
    }
  }
  Object.entries(dirStructure).forEach(([dirName, dirOrFileInfo]) => {
    if (typeof dirOrFileInfo === "string") return;
    const dirPath = `${prefix}${dirName}/`;
    const dirRelativePath = node_path.join(path, dirPath);
    if (!node_fs.existsSync(dirRelativePath)) return;
    if (!isSome(ignoreList, dirName) && !node_fs.statSync(dirRelativePath).isDirectory()) return;
    const key = Object.keys(rewrites).find((item) => item.startsWith(dirName));
    if (!key) return;
    !ignoreWarn && checkRewritesPrefix && validateRewritesPrefix(rewrites, dirName, ignoreList);
    const sidebarItems = createSidebarItems(dirOrFileInfo, dirRelativePath, option, dirPath);
    if (!ignoreWarn && sidebarItems.length === 0) {
      return logger$1.warn(`\u8BE5\u76EE\u5F55 '${dirName}' \u5185\u90E8\u6CA1\u6709\u4EFB\u4F55\u6587\u4EF6\u6216\u6587\u4EF6\u5E8F\u53F7\u51FA\u9519\uFF0C\u5C06\u5FFD\u7565\u751F\u6210\u5BF9\u5E94\u4FA7\u8FB9\u680F`);
    }
    const { name, title } = resolveFileName(dirName, dirRelativePath, indexSeparator);
    const info = getInfoFromMarkdownDir(path, dirName);
    const mdTitle = titleFormMd ? info.title : "";
    const sidebarPrefix = (info.prefix && (prefixTransform?.(info.prefix) ?? info.prefix)) ?? "";
    const sidebarSuffix = (info.suffix && (suffixTransform?.(info.suffix) ?? info.suffix)) ?? "";
    const text = sidebarPrefix + (mdTitle || title) + sidebarSuffix;
    const sidebarItem = {
      text,
      collapsed: typeof collapsed === "function" ? collapsed(prefix + name, text) : collapsed,
      items: sidebarItems
    };
    if (isSidebarObject) {
      const path2 = rewrites[key].split("/")[0];
      sidebarObj[`/${path2}/`] = initItems ? [{ ...sidebarItem, text: initItemsText ? text : "" }] : sidebarItems;
    } else sidebarArray.push(sidebarItem);
  });
  const finalSidebar = isSidebarObject ? sidebarObj : sidebarArray;
  return sidebarResolved?.(finalSidebar) ?? finalSidebar;
}
const createSidebarItems = (structure, root, option, prefix = "/", onlyScannerRootMd = false) => {
  const {
    collapsed,
    ignoreList = [],
    ignoreIndexMd = false,
    fileIndexPrefix = false,
    sidebarItemsResolved,
    beforeCreateSidebarItems,
    titleFormMd = false,
    ignoreWarn = false,
    sort = true,
    defaultSortNum = 9999,
    sortNumFromFileName = false,
    indexSeparator,
    prefixTransform,
    suffixTransform
  } = option;
  const ignoreListAll = [...ignoreList];
  let sidebarItems = [];
  const sidebarItemsNoIndex = [];
  const entries = Object.entries(beforeCreateSidebarItems?.(structure) || structure);
  entries.forEach(([dirOrFilename, dirOrFileInfo]) => {
    if (isSome(ignoreListAll, dirOrFilename)) return;
    const filePath = node_path.join(root, dirOrFilename);
    if (!node_fs.existsSync(filePath)) return;
    const { index: indexStr, title, type, name } = resolveFileName(dirOrFilename, filePath, indexSeparator);
    const index = parseInt(indexStr, 10);
    if (!ignoreWarn && fileIndexPrefix && isIllegalIndex(index)) {
      logger$1.warn(`\u8BE5\u6587\u4EF6 '${dirOrFilename}' \u5E8F\u53F7\u51FA\u9519\uFF0C\u8BF7\u586B\u5199\u6B63\u786E\u7684\u5E8F\u53F7`);
      return;
    }
    if (!onlyScannerRootMd && node_fs.statSync(filePath).isDirectory() && typeof dirOrFileInfo === "object") {
      const info = getInfoFromMarkdownDir(root, dirOrFilename);
      const mdTitle = titleFormMd ? info.title : "";
      const sidebarPrefix = (info.prefix && (prefixTransform?.(info.prefix) ?? info.prefix)) ?? "";
      const sidebarSuffix = (info.suffix && (suffixTransform?.(info.suffix) ?? info.suffix)) ?? "";
      const text = sidebarPrefix + (mdTitle || title) + sidebarSuffix;
      const childSidebarItems = createSidebarItems(dirOrFileInfo, filePath, option, `${prefix}${dirOrFilename}/`);
      let sidebarItem = {
        text,
        collapsed: typeof collapsed === "function" ? collapsed(prefix + name, text) : collapsed,
        items: childSidebarItems
      };
      if (sort) {
        sidebarItem = {
          ...sidebarItem,
          // 对子侧边栏进行排序
          items: childSidebarItems.sort((a, b) => (a.sort || defaultSortNum) - (b.sort || defaultSortNum)).map((item) => {
            delete item.sort;
            return item;
          }),
          sort: sortNumFromFileName ? index : info.sort
        };
      }
      if (isIllegalIndex(index)) sidebarItemsNoIndex.push(sidebarItem);
      else sidebarItems[index] = sidebarItem;
    } else {
      if (onlyScannerRootMd && dirOrFilename === "index.md") return [];
      if (ignoreIndexMd && ["index.md", "index.MD"].includes(dirOrFilename)) return [];
      if (!["md", "MD"].includes(type)) {
        if (!ignoreWarn && !onlyScannerRootMd) logger$1.warn(`\u8BE5\u6587\u4EF6 '${filePath}' \u975E .md \u683C\u5F0F\u6587\u4EF6\uFF0C\u4E0D\u652F\u6301\u8BE5\u6587\u4EF6\u7C7B\u578B`);
        return [];
      }
      const content = node_fs.readFileSync(filePath, "utf-8");
      const {
        data: { title: frontmatterTitle, sidebar = true, sidebarSort, sidebarPrefix, sidebarSuffix } = {},
        content: mdContent
      } = matter__default(content, {});
      if (!sidebar) return [];
      const mdTitle = titleFormMd ? getTitleFromMarkdown(mdContent) : "";
      const finalSidebarPrefix = (sidebarPrefix && (prefixTransform?.(sidebarPrefix) ?? sidebarPrefix)) ?? "";
      const finalSidebarSuffix = (sidebarSuffix && (suffixTransform?.(sidebarSuffix) ?? sidebarSuffix)) ?? "";
      const text = finalSidebarPrefix + (frontmatterTitle || mdTitle || title) + finalSidebarSuffix;
      let sidebarItem = {
        text,
        collapsed: typeof collapsed === "function" ? collapsed(prefix + name, text) : collapsed,
        link: `/${dirOrFileInfo}`
        // 此时是 rewrites 的文件路径
      };
      if (sort) sidebarItem = { ...sidebarItem, sort: sortNumFromFileName ? index : sidebarSort };
      if (isIllegalIndex(index)) sidebarItemsNoIndex.push(sidebarItem);
      else sidebarItems[index] = sidebarItem;
    }
  });
  sidebarItems = [...sidebarItems.filter(Boolean), ...sidebarItemsNoIndex];
  if (sort) {
    sidebarItems = sidebarItems.sort((a, b) => (a.sort || defaultSortNum) - (b.sort || defaultSortNum)).map((item) => {
      delete item.sort;
      return item;
    });
  }
  return sidebarItemsResolved?.(sidebarItems) ?? sidebarItems;
};
const buildDirectoryStructure = (rewrites) => {
  const structure = {};
  Object.entries(rewrites).forEach(([key, value]) => {
    const parts = key.split("/");
    let currentLevel = structure;
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const isLast = i === parts.length - 1;
      if (isLast) currentLevel[part] = value;
      else {
        if (!currentLevel[part]) currentLevel[part] = {};
        currentLevel = currentLevel[part];
      }
    }
  });
  return structure;
};
const validateRewritesPrefix = (rewrites, keyPrefix, ignoreList = []) => {
  const filteredEntries = Object.entries(rewrites).filter(([key, value]) => {
    if (!key.startsWith(keyPrefix)) return false;
    const isInIgnoreList = isSome(ignoreList, key);
    if (isInIgnoreList) return false;
    return value.includes("/");
  });
  if (filteredEntries.length === 0) return;
  const valuePrefixes = filteredEntries.map(([key, value]) => {
    const firstSegment = value.split("/")[0];
    return { key, value, prefix: firstSegment };
  });
  const basePrefix = valuePrefixes[0].prefix;
  const inconsistentEntries = valuePrefixes.filter((item) => item.prefix !== basePrefix);
  if (inconsistentEntries.length > 0) {
    console.warn(
      `\u68C0\u6D4B\u5230 '${keyPrefix}' \u8DEF\u5F84\u4E0B\u7684\u90E8\u5206\u6587\u4EF6 Rewrites \u524D\u7F00\u4E0D\u4E00\u81F4\uFF0C\u8981\u6C42\u7684\u57FA\u51C6\u524D\u7F00 '/${basePrefix}'\uFF0C\u4E0D\u4E00\u81F4\u7684\u6587\u4EF6\u5982\u4E0B:`
    );
    inconsistentEntries.forEach((item) => console.warn(`  ${item.key}`));
  }
};

function VitePluginVitePressSidebarResolve(option = {}) {
  let isExecute = false;
  return {
    name: "vite-plugin-vitepress-sidebar-resolve",
    configureServer({ watcher, restart }) {
      if (!option.restart) return;
      watcher.add("*.md");
      watcher.on("add", async (path) => {
        if (!path.endsWith(".md")) return;
        await restart();
      }).on("unlink", async (path) => {
        if (!path.endsWith(".md")) return;
        await restart();
      });
    },
    config(config) {
      if (isExecute) return;
      isExecute = true;
      const {
        site: { themeConfig = {}, locales = {} },
        srcDir,
        rewrites: rewritesObj
      } = config.vitepress;
      const { path, ignoreList, localeRootDir, type = "object", resolveRule = "filePath" } = option;
      const baseDir = path ? node_path.join(srcDir, path) : srcDir;
      const rewrites = rewritesObj.map || {};
      const rewritesLength = Object.keys(rewrites).length;
      const isFilePathRule = resolveRule === "filePath" || resolveRule === "rewrites" && !rewritesLength;
      const isRewritesRule = resolveRule === "rewrites" && rewritesLength;
      const localesKeys = Object.keys(locales).filter((key) => key !== "root");
      if (isFilePathRule) {
        if (!localesKeys.length) {
          return setSideBar(themeConfig, createFilePathSidebar({ ...option, path: baseDir }), type);
        }
        localesKeys.forEach((localesKey) => {
          const sidebar = createFilePathSidebar({ ...option, path: `${baseDir}/${localesKey}` }, localesKey);
          setSideBar(locales[localesKey].themeConfig, sidebar, type);
        });
        const rootDir = localeRootDir ? `/${localeRootDir}` : "";
        const rootSideBar = createFilePathSidebar({
          ...option,
          path: `${baseDir}${rootDir}`,
          ignoreList: [...ignoreList || [], ...localesKeys]
        });
        setSideBar(locales["root"].themeConfig, rootSideBar, type);
      } else if (isRewritesRule) {
        if (!localesKeys.length) {
          return setSideBar(themeConfig, createRewritesSidebar(rewrites, { ...option, path: baseDir }), type);
        }
        localesKeys.forEach((localesKey) => {
          const sidebar = createRewritesSidebar(rewrites, { ...option, path: `${baseDir}/${localesKey}` }, localesKey);
          setSideBar(locales[localesKey].themeConfig, sidebar, type);
        });
        const rootDir = localeRootDir ? `/${localeRootDir}` : "";
        const rootSideBar = createRewritesSidebar(rewrites, {
          ...option,
          path: `${baseDir}${rootDir}`,
          ignoreList: [...ignoreList || [], ...localesKeys]
        });
        setSideBar(locales["root"].themeConfig, rootSideBar, type);
      }
    }
  };
}
const setSideBar = (themeConfig, sidebar, type) => {
  themeConfig = themeConfig || {};
  if (type === "object") {
    themeConfig.sidebar = {
      ...sidebar,
      ...Array.isArray(themeConfig.sidebar) ? logger$1.warn("\u81EA\u5B9A\u4E49 Sidebar \u5FC5\u987B\u662F\u5BF9\u8C61\u5F62\u5F0F") : themeConfig.sidebar
    };
  } else {
    themeConfig.sidebar = [
      ...sidebar,
      ...Object.prototype.toString.call(themeConfig.sidebar) === "[object Object]" ? logger$1.warn("\u81EA\u5B9A\u4E49 Sidebar \u5FC5\u987B\u662F\u6570\u7EC4\u5F62\u5F0F") : themeConfig.sidebar || []
    ];
  }
  logger$1.info("Injected Sidebar Data Successfully. \u6CE8\u5165\u4FA7\u8FB9\u680F\u6570\u636E\u6210\u529F!");
};

exports.default = VitePluginVitePressSidebarResolve;
exports.getTitleFromMarkdown = getTitleFromMarkdown;
exports.isIllegalIndex = isIllegalIndex;
exports.isSome = isSome;
