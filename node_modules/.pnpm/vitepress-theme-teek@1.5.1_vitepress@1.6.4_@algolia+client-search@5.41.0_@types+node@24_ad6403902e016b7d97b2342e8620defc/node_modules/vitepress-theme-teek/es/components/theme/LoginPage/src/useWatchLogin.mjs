import { watch } from 'vue';
import { useRouter, useData } from 'vitepress';
import { isClient } from '../../../../helper/dist/index.mjs';
import { usePagePath, useTeekConfig } from '../../ConfigProvider/index.mjs';
import { getLoginStorageKey, defaultPrivateConfig, loginUrlKeyMap, verifyModeMap } from './login.mjs';

const useWatchLogin = () => {
  const router = useRouter();
  const { frontmatter } = useData();
  const { loginPath } = usePagePath();
  const { siteLoginKey, pagesLoginKey, pageLoginKey, realmLoginKey } = getLoginStorageKey();
  const { getTeekConfigRef } = useTeekConfig();
  const privateConfig = getTeekConfigRef("private", defaultPrivateConfig);
  const getLoginInfo = (key) => {
    const infoStr = localStorage.getItem(key) || sessionStorage.getItem(key);
    return infoStr ? JSON.parse(infoStr) : null;
  };
  const isValidCredential = (credentialList, loginInfo) => {
    const decrypt = privateConfig.value.decrypt;
    return credentialList.some(
      (item) => item.username === loginInfo.username && item.password === (decrypt ? decrypt(loginInfo.password, frontmatter) : loginInfo.password)
    );
  };
  const isLoginExpired = (loginInfo, key) => {
    const { expire, loginTime, strategy } = loginInfo;
    if (strategy === "always") {
      sessionStorage.removeItem(key);
      localStorage.removeItem(key);
    }
    return expire && loginTime && (/* @__PURE__ */ new Date()).getTime() - loginTime > expire;
  };
  const isLogin = (loginKey, credentialList, type) => {
    const nativeValidate = () => {
      const loginInfo = getLoginInfo(loginKey);
      return !!(loginInfo && isValidCredential(credentialList, loginInfo) && !isLoginExpired(loginInfo, loginKey));
    };
    return privateConfig.value.doValidate ? privateConfig.value.doValidate(type, frontmatter.value, nativeValidate) : nativeValidate();
  };
  const watchSite = () => {
    if (!isClient) return;
    if (!privateConfig.value.enabled) return;
    if (!privateConfig.value.siteLogin || !loginPath.value || router.route.data.frontmatter.loginPage) return;
    const { verifyMode, toPath } = loginUrlKeyMap;
    const goLogin = `${loginPath.value}?${verifyMode}=${verifyModeMap.site}&${toPath}=${window.location.href}`;
    if (!isLogin(siteLoginKey, privateConfig.value.site || [], "site")) router.go(goLogin);
  };
  const watchPages = () => {
    if (!isClient) return;
    if (!privateConfig.value.enabled) return;
    watch(
      router.route,
      (newVal) => {
        if (!privateConfig.value.enabled) return;
        if (!frontmatter.value.private || !loginPath.value || newVal.data.frontmatter.loginPage) return;
        if (isLogin(siteLoginKey, privateConfig.value.site || [], "site")) {
          const siteLoginInfo = getLoginInfo(siteLoginKey);
          if (siteLoginInfo.role === "admin") return;
        }
        const { verifyMode, toPath, realm: realmKey } = loginUrlKeyMap;
        const goLogin = `${loginPath.value}?${verifyMode}={verifyMode}&${toPath}=${newVal.path}`;
        const realm = frontmatter.value.privateRealm;
        const page = [
          ...frontmatter.value.loginInfo || [],
          { username: frontmatter.value.username, password: frontmatter.value.password }
        ].filter((item) => ![void 0, ""].includes(item.username) && ![void 0, ""].includes(item.password));
        if (page.length) {
          const path = "/" + newVal.data.filePath.replace(".md", "");
          const key = pageLoginKey + path;
          if (isLogin(key, page, "page") || isLogin(`${key}.html`, page, "page")) return;
        }
        if (realm) {
          const goRealm = goLogin.replace("{verifyMode}", verifyModeMap.realm) + `&${realmKey}=${realm}`;
          if (!isLogin(realmLoginKey + realm, privateConfig.value.realm[realm] || [], "realm")) router.go(goRealm);
          return;
        }
        if (page.length) {
          const goPage = goLogin.replace("{verifyMode}", verifyModeMap.page);
          return router.go(goPage);
        }
        const goPages = goLogin.replace("{verifyMode}", verifyModeMap.pages);
        if (!isLogin(pagesLoginKey, privateConfig.value.pages || [], "pages")) router.go(goPages);
      },
      { immediate: true }
    );
  };
  return { watchSite, watchPages };
};

export { useWatchLogin };
