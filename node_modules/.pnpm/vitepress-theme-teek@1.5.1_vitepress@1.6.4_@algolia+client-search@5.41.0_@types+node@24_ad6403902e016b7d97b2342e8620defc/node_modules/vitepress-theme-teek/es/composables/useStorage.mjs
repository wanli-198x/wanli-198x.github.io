import { toValue, ref, computed, watch } from 'vue';
import { isClient } from '../helper/dist/index.mjs';
import { useMounted } from './useMounted.mjs';
import { useEventListener } from './useEventListener.mjs';

const StorageSerializers = {
  boolean: { read: (v) => v === "true", write: (v) => String(v) },
  object: { read: (v) => JSON.parse(v), write: (v) => JSON.stringify(v) },
  number: { read: (v) => Number.parseFloat(v), write: (v) => String(v) },
  any: { read: (v) => v, write: (v) => String(v) },
  string: { read: (v) => v, write: (v) => String(v) },
  map: {
    read: (v) => new Map(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v.entries()))
  },
  set: { read: (v) => new Set(JSON.parse(v)), write: (v) => JSON.stringify(Array.from(v)) },
  date: { read: (v) => new Date(v), write: (v) => v.toISOString() }
};
const guessSerializerType = (rawInit) => {
  if (rawInit == null) return "any";
  if (rawInit instanceof Set) return "set";
  if (rawInit instanceof Map) return "map";
  if (rawInit instanceof Date) return "date";
  if (typeof rawInit === "boolean") return "boolean";
  if (typeof rawInit === "string") return "string";
  if (typeof rawInit === "number") return "number";
  if (typeof rawInit === "object") return "object";
  return "any";
};
const useStorage = (key, defaults, storageType = "localStorage", options = {}) => {
  const { flush = "pre", deep = true, writeDefaults = true, mergeDefaults = false, initOnMounted } = options;
  const rawInit = toValue(defaults);
  const data = ref(rawInit);
  if (!isClient) return data;
  const type = guessSerializerType(rawInit);
  const serializer = StorageSerializers[type];
  const keyComputed = computed(() => toValue(key));
  const storage = storageType === "localStorage" ? localStorage : sessionStorage;
  watch(keyComputed, () => update(), { flush });
  watch(data, () => write(data.value), { flush, deep });
  useMounted(() => {
    if (initOnMounted) update();
  });
  const dispatchWriteEvent = (oldValue, newValue) => {
    if (window) {
      const payload = { key: keyComputed.value, oldValue, newValue, storageArea: storage };
      window.dispatchEvent(new StorageEvent("storage", payload));
    }
  };
  const write = (val) => {
    const oldValue = storage.getItem(keyComputed.value);
    if (val == null) {
      dispatchWriteEvent(oldValue, null);
      storage.removeItem(keyComputed.value);
    } else {
      const serialized = serializer.write(val);
      if (oldValue !== serialized) {
        storage.setItem(keyComputed.value, serialized);
        dispatchWriteEvent(oldValue, serialized);
      }
    }
  };
  const read = (event) => {
    const rawValue = event ? event.newValue : storage.getItem(keyComputed.value);
    if (rawValue == null) {
      if (writeDefaults && rawInit != null) storage.setItem(keyComputed.value, serializer.write(rawInit));
      return rawInit;
    }
    if (!event && mergeDefaults) {
      const value = serializer.read(rawValue);
      if (typeof mergeDefaults === "function") return mergeDefaults(value, rawInit);
      if (type === "object" && !Array.isArray(value)) return { ...rawInit, ...value };
      return value;
    }
    if (typeof rawValue !== "string") return rawValue;
    else return serializer.read(rawValue);
  };
  const update = (event) => {
    if (event && event.storageArea !== storage) return;
    if (event && event.key == null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== keyComputed.value) return;
    if (event?.newValue !== serializer.write(data.value)) data.value = read(event);
  };
  if (!initOnMounted) update();
  useEventListener(() => window, "storage", update, { passive: true });
  return data;
};

export { StorageSerializers, guessSerializerType, useStorage };
