import { isArray } from '../helper/dist/index.mjs';
import { useScopeDispose } from './useScopeDispose.mjs';
import { useMounted } from './useMounted.mjs';
import { watch, unref, nextTick } from 'vue';

const useWindowTransition = (element, immediate = true) => {
  let startInMounted = false;
  const cleanup = [];
  const start = () => {
    const elementConst = unref(element);
    if (!elementConst) return;
    if (isArray(elementConst)) elementConst.forEach((el) => initTransition(el));
    else initTransition(elementConst);
  };
  const initTransition = (el) => {
    el.classList.add("scroll__animate");
    const { create, clean } = useIntersectionObserver(
      el,
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            requestAnimationFrame(() => {
              try {
                el.classList.add("visible");
                clean();
              } catch (error) {
                console.error("\u521D\u59CB\u5316\u52A8\u753B\u5931\u8D25:", error);
              }
            });
          }
        });
      },
      0.1
    );
    create();
    cleanup.push(clean);
  };
  const stop = () => {
    cleanup.forEach((fn) => fn());
  };
  const restart = () => {
    stop();
    start();
  };
  watch(
    () => unref(element),
    () => {
      !startInMounted && restart();
    },
    { deep: true }
  );
  useMounted(async () => {
    startInMounted = true;
    immediate && restart();
    await nextTick();
    startInMounted = false;
  });
  useScopeDispose(stop);
  return { start, stop, restart };
};
const useIntersectionObserver = (observerDom, callback, threshold) => {
  let intersectionObserver = null;
  const createIntersectionObserver = () => {
    const observerDomValue = unref(observerDom);
    if (intersectionObserver || !observerDomValue) return;
    intersectionObserver = new IntersectionObserver(callback, { threshold });
    intersectionObserver.observe(observerDomValue);
  };
  const cleanIntersectionObserver = () => {
    if (intersectionObserver) {
      intersectionObserver.disconnect();
      intersectionObserver = null;
    }
  };
  useScopeDispose(cleanIntersectionObserver);
  return { create: createIntersectionObserver, clean: cleanIntersectionObserver };
};

export { useIntersectionObserver, useWindowTransition };
