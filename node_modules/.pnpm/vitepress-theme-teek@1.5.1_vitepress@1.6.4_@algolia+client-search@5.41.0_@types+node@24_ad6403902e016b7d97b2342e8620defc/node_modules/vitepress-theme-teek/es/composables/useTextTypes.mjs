import { computed, toValue, ref, watch } from 'vue';
import { useScopeDispose } from './useScopeDispose.mjs';

const useTextTypes = (data, options = {}) => {
  const { inputTime = 200, outputTime = 100, nextTime = 800, shuffle = false, reloadWhenDataChanged = false } = options;
  const dataComputed = computed(() => toValue(data) || []);
  const text = ref("");
  const isFinished = ref(false);
  let originText = "";
  let inputTimer;
  let outputTimer;
  let textIndex = 0;
  let dataIndex = 0;
  const clearInputTimer = () => {
    if (inputTimer) {
      clearInterval(inputTimer);
      inputTimer = null;
    }
  };
  const clearOutputTimer = () => {
    if (outputTimer) {
      clearInterval(outputTimer);
      outputTimer = null;
    }
  };
  const typesIn = () => {
    isFinished.value = false;
    originText = dataComputed.value[dataIndex];
    if (!originText) return stop();
    text.value = originText.substring(0, textIndex++);
    if (textIndex > originText.length) {
      clearInputTimer();
      isFinished.value = true;
      setTimeout(() => {
        outputTimer = setInterval(() => {
          typesOut();
        }, outputTime);
      }, nextTime);
    }
  };
  const typesOut = () => {
    if (textIndex >= 0) {
      isFinished.value = false;
      text.value = originText.substring(0, textIndex--);
    } else {
      clearOutputTimer();
      isFinished.value = true;
      setTimeout(() => {
        if (shuffle) {
          let newIndex;
          do {
            newIndex = Math.floor(Math.random() * dataComputed.value.length);
          } while (newIndex === dataIndex);
          dataIndex = newIndex;
        } else {
          dataIndex = (dataIndex + 1) % dataComputed.value.length;
        }
        inputTimer = setInterval(() => {
          typesIn();
        }, inputTime);
      }, nextTime);
    }
  };
  const start = () => {
    isFinished.value = false;
    inputTimer = setInterval(() => {
      typesIn();
    }, inputTime);
  };
  const stop = (restore = false) => {
    clearInputTimer();
    clearOutputTimer();
    isFinished.value = false;
    if (restore) {
      text.value = "";
      originText = "";
      textIndex = 0;
      dataIndex = 0;
    }
  };
  const restart = () => {
    stop(true);
    start();
  };
  if (reloadWhenDataChanged) watch(dataComputed, () => restart());
  useScopeDispose(stop);
  return { text, isFinished, start, stop, restart };
};

export { useTextTypes };
