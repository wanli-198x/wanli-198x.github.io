'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Vue = require('vue');
var index = require('../../../../helper/dist/index.js');
var index_vue_vue_type_script_setup_true_name_Message_lang = require('./index.vue2.js');
var message$1 = require('./message.js');
var instance = require('./instance.js');

let seed = 1;
const normalizeOptions = (params) => {
  const options = !params || index.isString(params) || Vue.isVNode(params) || index.isFunction(params) ? { message: params } : params;
  const normalized = {
    ...message$1.messageDefaults,
    ...options
  };
  if (!normalized.appendTo) normalized.appendTo = document.body;
  else if (index.isString(normalized.appendTo)) {
    let appendTo = document.querySelector(normalized.appendTo);
    if (!index.isElement(appendTo)) {
      console.warn("Message", "the appendTo option is not an HTMLElement. Falling back to document.body.");
      appendTo = document.body;
    }
    normalized.appendTo = appendTo;
  }
  return normalized;
};
const closeMessage = (instance$1) => {
  const idx = instance.instances.indexOf(instance$1);
  if (idx === -1) return;
  instance.instances.splice(idx, 1);
  const { handler } = instance$1;
  handler.close();
};
const createMessage = ({ appendTo, ...options }, context) => {
  const id = `message_${seed++}`;
  const userOnClose = options.onClose;
  const container = document.createElement("div");
  const props = {
    ...options,
    // now the zIndex will be used inside the message.vue component instead of here.
    // zIndex: nextIndex() + options.zIndex
    id,
    onClose: () => {
      userOnClose?.();
      closeMessage(instance);
    },
    // clean message element preventing mem leak
    onDestroy: () => {
      Vue.render(null, container);
    }
  };
  const vnode = Vue.createVNode(
    index_vue_vue_type_script_setup_true_name_Message_lang.default,
    props,
    index.isFunction(props.message) || Vue.isVNode(props.message) ? {
      default: index.isFunction(props.message) ? props.message : () => props.message
    } : null
  );
  vnode.appContext = context || message._context;
  Vue.render(vnode, container);
  appendTo.appendChild(container.firstElementChild);
  const vm = vnode.component;
  const handler = {
    // instead of calling the onClose function directly, setting this value so that we can have the full lifecycle
    // for out component, so that all closing steps will not be skipped.
    close: () => {
      vm.exposed.close();
    }
  };
  const instance = {
    id,
    vnode,
    vm,
    handler,
    props: vnode.component.props
  };
  return instance;
};
const message = (options = {}, context) => {
  if (!index.isClient) return { close: () => void 0 };
  const normalized = normalizeOptions(options);
  if (normalized.grouping && instance.instances.length) {
    const instance2 = instance.instances.find(({ vnode: vm }) => vm.props?.message === normalized.message);
    if (instance2) {
      instance2.props.repeatNum += 1;
      instance2.props.type = normalized.type;
      return instance2.handler;
    }
  }
  const instance$1 = createMessage(normalized, context);
  instance.instances.push(instance$1);
  return instance$1.handler;
};
message$1.messageTypes.forEach((type) => {
  message[type] = (options = {}, appContext) => {
    const normalized = normalizeOptions(options);
    return message({ ...normalized, type }, appContext);
  };
});
function closeAll(type) {
  const instancesToClose = [...instance.instances];
  for (const instance of instancesToClose) {
    if (!type || type === instance.props.type) {
      instance.handler.close();
    }
  }
}
message.closeAll = closeAll;
message._context = null;

exports.closeAll = closeAll;
exports.default = message;
