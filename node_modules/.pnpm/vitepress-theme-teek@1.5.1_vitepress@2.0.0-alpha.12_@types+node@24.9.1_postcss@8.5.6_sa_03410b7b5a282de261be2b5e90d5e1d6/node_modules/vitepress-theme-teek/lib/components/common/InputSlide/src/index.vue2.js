'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Vue = require('vue');
var useEventListener = require('../../../../composables/useEventListener.js');
require('vitepress');
var useNamespace = require('../../../../composables/useNamespace.js');
require('vitepress-theme-teek/theme-chalk/tk-copy-banner.css');
var useElementHover = require('../../../../composables/useElementHover.js');
require('../../../../composables/useZIndex.js');

const _hoisted_1 = ["name", "min", "max", "disabled", "step"];
var _sfc_main = /* @__PURE__ */ Vue.defineComponent({
  ...{ name: "InputSlide" },
  __name: "index",
  props: /* @__PURE__ */ Vue.mergeModels({
    name: { default: "Slider" },
    disabled: { type: Boolean },
    min: { default: 0 },
    max: { default: 100 },
    step: { default: 1 },
    format: { type: Function }
  }, {
    "modelValue": { default: 0 },
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const ns = useNamespace.useNamespace("input-slide");
    const inputValue = Vue.useModel(__props, "modelValue");
    const inputSliderRef = Vue.ref();
    const inputSliderTooltipRef = Vue.ref();
    const hovering = useElementHover.useElementHover(inputSliderRef);
    const positioning = Vue.ref(false);
    const sliderValueVar = ns.cssVarName("slider-value");
    const sliderMinVar = ns.cssVarName("slider-min");
    const sliderMaxVar = ns.cssVarName("slider-max");
    useEventListener.useEventListener(inputSliderRef, "input", () => {
      if (!inputSliderRef.value) return;
      inputSliderRef.value.style.setProperty(sliderValueVar, inputSliderRef.value.value.toString());
    });
    Vue.onMounted(() => {
      if (!inputSliderRef.value) return;
      const inputSliderStyle = inputSliderRef.value.style;
      inputSliderStyle.setProperty(sliderValueVar, inputValue.value.toString());
      inputSliderStyle.setProperty(sliderMinVar, __props.min?.toString() ?? "0");
      inputSliderStyle.setProperty(sliderMaxVar, __props.max?.toString() ?? "100");
    });
    const calTipPosition = (inputElement, inputTooltipElement) => {
      const finalMax = __props.max || 100;
      const finalMin = __props.min || 0;
      const ratio = (inputValue.value - finalMin) / (finalMax - finalMin);
      const rect = inputElement.getBoundingClientRect();
      const tooltipRect = inputTooltipElement.getBoundingClientRect();
      const centeringShift = (tooltipRect.width - 32) / 2;
      inputTooltipElement.style.setProperty("left", `${ratio * (rect.width - 32) - centeringShift}px`);
    };
    Vue.watch(hovering, () => {
      positioning.value = true;
      setTimeout(() => {
        if (!hovering.value) {
          positioning.value = false;
          return;
        }
        if (!inputSliderRef.value) {
          positioning.value = false;
          return;
        }
        if (!inputSliderTooltipRef.value) {
          positioning.value = false;
          return;
        }
        calTipPosition(inputSliderRef.value, inputSliderTooltipRef.value);
        positioning.value = false;
      }, 50);
    });
    Vue.watch(inputValue, (val) => {
      if (val < __props.min) val = __props.min;
      if (val > __props.max) val = __props.max;
      if (!inputSliderRef.value || !inputSliderTooltipRef.value) return;
      calTipPosition(inputSliderRef.value, inputSliderTooltipRef.value);
    });
    Vue.watch(
      () => __props.min,
      (val) => {
        if (inputValue.value >= val) return;
        inputValue.value = val;
      }
    );
    Vue.watch(
      () => __props.max,
      (val) => {
        if (inputValue.value <= val) return;
        inputValue.value = val;
      }
    );
    return (_ctx, _cache) => {
      return Vue.openBlock(), Vue.createElementBlock(
        "div",
        {
          class: Vue.normalizeClass(Vue.unref(ns).b())
        },
        [
          Vue.createElementVNode(
            "label",
            {
              class: Vue.normalizeClass(Vue.unref(ns).e("label"))
            },
            [
              Vue.withDirectives(Vue.createElementVNode("input", {
                ref_key: "inputSliderRef",
                ref: inputSliderRef,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inputValue.value = $event),
                type: "range",
                name: __props.name,
                min: __props.min,
                max: __props.max,
                disabled: __props.disabled,
                step: __props.step,
                class: Vue.normalizeClass([Vue.unref(ns).e("label__input"), Vue.unref(ns).e("label__input-progress"), Vue.unref(ns).is("disabled", __props.disabled)])
              }, null, 10, _hoisted_1), [
                [
                  Vue.vModelText,
                  inputValue.value,
                  void 0,
                  { number: true }
                ]
              ]),
              Vue.createVNode(Vue.Transition, {
                name: "fade",
                persisted: ""
              }, {
                default: Vue.withCtx(() => [
                  Vue.withDirectives(Vue.createElementVNode(
                    "span",
                    {
                      ref_key: "inputSliderTooltipRef",
                      ref: inputSliderTooltipRef,
                      class: Vue.normalizeClass([Vue.unref(ns).e("label__tooltip"), Vue.unref(ns).is("opacity-0", Vue.unref(hovering) && positioning.value)])
                    },
                    Vue.toDisplayString(!!__props.format ? __props.format(inputValue.value) : inputValue.value),
                    3
                    /* TEXT, CLASS */
                  ), [
                    [Vue.vShow, Vue.unref(hovering)]
                  ])
                ]),
                _: 1
                /* STABLE */
              })
            ],
            2
            /* CLASS */
          )
        ],
        2
        /* CLASS */
      );
    };
  }
});

exports.default = _sfc_main;
