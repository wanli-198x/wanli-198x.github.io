import { defineComponent, mergeModels, ref, useModel, computed, watch, onBeforeMount, createElementBlock, openBlock, Fragment, createElementVNode, createBlock, mergeProps, renderSlot, Teleport, unref, createVNode, Transition, withCtx, withDirectives, createCommentVNode, withModifiers, normalizeClass, normalizeStyle, createTextVNode, toDisplayString, vShow } from 'vue';
import { onClickOutside } from '../../../../composables/onClickOutside.mjs';
import 'vitepress';
import { addUnit } from '../../../../helper/dist/index.mjs';
import { useNamespace } from '../../../../composables/useNamespace.mjs';
import 'vitepress-theme-teek/theme-chalk/tk-copy-banner.css';
import { useElementHover } from '../../../../composables/useElementHover.mjs';
import { usePopoverSize } from '../../../../composables/usePopoverSize.mjs';
import { useZIndex } from '../../../../composables/useZIndex.mjs';
import TkFocusTrap from '../../FocusTrap/src/index.vue.mjs';
import { useFocusTrap } from './useFocusTrap.mjs';

var _sfc_main = /* @__PURE__ */ defineComponent({
  ...{ name: "Popover" },
  __name: "index",
  props: /* @__PURE__ */ mergeModels({
    trigger: { default: "hover" },
    placement: { default: "bottom" },
    content: { default: "" },
    width: {},
    height: {},
    offset: { default: 0 },
    xOffset: { default: 0 },
    yOffset: { default: 0 },
    disabled: { type: Boolean, default: false },
    transition: { type: Boolean, default: true },
    transitionName: {},
    triggerEl: {},
    zIndex: {},
    popperClass: {},
    popperStyle: {},
    beforePopup: { type: Function }
  }, {
    "modelValue": { default: false },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["focus", "blur", "close"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const ns = useNamespace("popover");
    const { nextZIndex } = useZIndex();
    const zIndexRef = ref(__props.zIndex ?? nextZIndex());
    const visible = useModel(__props, "modelValue");
    const triggerRef = ref();
    const popoverRef = ref();
    const isHovered = useElementHover(triggerRef);
    const popupVisible = useElementHover(popoverRef);
    const triggerElComputed = computed(() => __props.triggerEl || triggerRef.value);
    const { top, right, left, bottom, update } = usePopoverSize(triggerElComputed, popoverRef, {
      placement: __props.placement,
      offset: __props.offset,
      xOffset: __props.xOffset,
      yOffset: __props.yOffset
    });
    const popupStyle = computed(() => {
      return {
        zIndex: zIndexRef.value,
        top: addUnit(top.value),
        right: addUnit(right.value),
        bottom: addUnit(bottom.value),
        left: addUnit(left.value),
        width: addUnit(__props.width),
        height: addUnit(__props.height),
        ...__props.popperStyle
      };
    });
    const calculatePopoverPosition = () => {
      if (!triggerRef.value || !popoverRef.value) {
        visible.value = false;
        return;
      }
      update();
      const result = __props.beforePopup?.({
        top: top.value,
        right: right.value,
        bottom: left.value,
        left: bottom.value,
        triggerElement: __props.triggerEl || triggerRef.value,
        popoverElement: popoverRef.value
      }) ?? {};
      if (result.top) top.value = result.top;
      if (result.right) right.value = result.right;
      if (result.bottom) bottom.value = result.bottom;
      if (result.left) left.value = result.left;
    };
    if (__props.trigger === "hover") {
      watch(isHovered, (newVal) => {
        if (__props.trigger === "hover") visible.value = newVal;
      });
    }
    const toggleVisible = (event) => {
      if (event === __props.trigger) visible.value = !visible.value;
    };
    watch(visible, (newVal) => {
      if (newVal) calculatePopoverPosition();
    });
    watch(popupVisible, (newVal) => {
      if (__props.trigger === "hover") visible.value = newVal;
    });
    onClickOutside(popoverRef, (e) => {
      if (e.composedPath().includes(triggerRef.value)) return;
      if (__props.trigger === "hover") return;
      if (visible.value !== false) visible.value = false;
    });
    const popoverContainerId = ns.join("popover-container");
    onBeforeMount(() => {
      const popoverContainer = document.querySelector(`#${popoverContainerId}`);
      if (!popoverContainer) {
        const container = document.createElement("div");
        container.id = popoverContainerId;
        document.body.appendChild(container);
      }
    });
    const emit = __emit;
    const {
      focusStartRef,
      onFocusAfterTrapped,
      onFocusAfterReleased,
      onFocusInTrap,
      onFocusoutPrevented,
      onReleaseRequested
    } = useFocusTrap(visible, emit);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        Fragment,
        null,
        [
          createElementVNode(
            "div",
            mergeProps({
              ref_key: "triggerRef",
              ref: triggerRef,
              onClick: _cache[0] || (_cache[0] = ($event) => toggleVisible("click")),
              onContextmenu: _cache[1] || (_cache[1] = ($event) => toggleVisible("contextmenu")),
              onFocus: _cache[2] || (_cache[2] = ($event) => toggleVisible("focus")),
              onTouchstart: _cache[3] || (_cache[3] = ($event) => visible.value = !visible.value)
            }, _ctx.$attrs),
            [
              renderSlot(_ctx.$slots, "reference")
            ],
            16
            /* FULL_PROPS */
          ),
          (openBlock(), createBlock(Teleport, {
            to: `#${unref(popoverContainerId)}`
          }, [
            createVNode(Transition, {
              name: __props.transition ? __props.transitionName || unref(ns).join("fade-linear") : ""
            }, {
              default: withCtx(() => [
                !__props.disabled ? withDirectives((openBlock(), createElementBlock(
                  "div",
                  {
                    key: 0,
                    ref_key: "popoverRef",
                    ref: popoverRef,
                    style: normalizeStyle(popupStyle.value),
                    class: normalizeClass([unref(ns).b(), __props.popperClass]),
                    onClick: _cache[4] || (_cache[4] = withModifiers(() => {
                    }, ["stop"])),
                    onTouchstart: _cache[5] || (_cache[5] = withModifiers(() => {
                    }, ["stop"]))
                  },
                  [
                    createVNode(unref(TkFocusTrap), {
                      loop: "",
                      trapped: visible.value,
                      "focus-trap-el": popoverRef.value,
                      "focus-start-el": unref(focusStartRef),
                      onFocusAfterTrapped: unref(onFocusAfterTrapped),
                      onFocusAfterReleased: unref(onFocusAfterReleased),
                      onFocusin: unref(onFocusInTrap),
                      onFocusoutPrevented: unref(onFocusoutPrevented),
                      onReleaseRequested: unref(onReleaseRequested)
                    }, {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "default", {}, () => [
                          createTextVNode(
                            toDisplayString(__props.content),
                            1
                            /* TEXT */
                          )
                        ])
                      ]),
                      _: 3
                      /* FORWARDED */
                    }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
                  ],
                  38
                  /* CLASS, STYLE, NEED_HYDRATION */
                )), [
                  [vShow, visible.value]
                ]) : createCommentVNode("v-if", true)
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["name"])
          ], 8, ["to"]))
        ],
        64
        /* STABLE_FRAGMENT */
      );
    };
  }
});

export { _sfc_main as default };
