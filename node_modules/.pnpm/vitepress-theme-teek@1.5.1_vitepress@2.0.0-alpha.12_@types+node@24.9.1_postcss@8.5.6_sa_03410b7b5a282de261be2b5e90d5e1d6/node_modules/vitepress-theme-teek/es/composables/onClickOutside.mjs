import { toValue } from 'vue';
import { isClient, isIos } from '../helper/dist/index.mjs';
import { useEventListener } from './useEventListener.mjs';

let _iOSWorkaround = false;
const onClickOutside = (target, handler, options = {}) => {
  const { ignore = [], capture = true, detectIframe = false, controls = false } = options;
  if (!isClient) {
    return controls ? { stop: () => {
    }, cancel: () => {
    }, trigger: () => {
    } } : () => {
    };
  }
  if (isIos() && !_iOSWorkaround) {
    _iOSWorkaround = true;
    const listenerOptions = { passive: true };
    Array.from(window.document.body.children).forEach((el) => useEventListener(el, "click", () => {
    }, listenerOptions));
    useEventListener(window.document.documentElement, "click", () => {
    }, listenerOptions);
  }
  let shouldListen = true;
  const shouldIgnore = (event) => {
    return toValue(ignore).some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window.document.querySelectorAll(target2)).some(
          (el) => el === event.target || event.composedPath().includes(el)
        );
      } else {
        const el = toValue(target2);
        return el && (event.target === el || event.composedPath().includes(el));
      }
    });
  };
  function hasMultipleRoots(target2) {
    const vm = toValue(target2);
    return vm && vm.$.subTree.shapeFlag === 16;
  }
  function checkMultipleRoots(target2, event) {
    const vm = toValue(target2);
    const children = vm.$.subTree && vm.$.subTree.children;
    if (children == null || !Array.isArray(children)) return false;
    return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));
  }
  const listener = (event) => {
    const plain = toValue(target);
    const el = plain?.$el ?? plain;
    if (event.target == null) return;
    if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event)) return;
    if (!el || el === event.target || event.composedPath().includes(el)) return;
    if ("detail" in event && event.detail === 0) shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  let isProcessingClick = false;
  const cleanup = [
    useEventListener(
      window,
      "click",
      (event) => {
        if (!isProcessingClick) {
          isProcessingClick = true;
          setTimeout(() => {
            isProcessingClick = false;
          }, 0);
          listener(event);
        }
      },
      { passive: true, capture }
    ),
    useEventListener(
      window,
      "pointerdown",
      (e) => {
        const plain = toValue(target);
        const el = plain?.$el ?? plain;
        shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));
      },
      { passive: true }
    ),
    detectIframe && useEventListener(
      window,
      "blur",
      (event) => {
        setTimeout(() => {
          const plain = toValue(target);
          const el = plain?.$el ?? plain;
          if (window.document.activeElement?.tagName === "IFRAME" && !el?.contains(window.document.activeElement)) {
            handler(event);
          }
        }, 0);
      },
      { passive: true }
    )
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn) => fn());
  if (controls) {
    return {
      stop,
      cancel: () => {
        shouldListen = false;
      },
      trigger: (event) => {
        shouldListen = true;
        listener(event);
        shouldListen = false;
      }
    };
  }
  return stop;
};

export { onClickOutside };
