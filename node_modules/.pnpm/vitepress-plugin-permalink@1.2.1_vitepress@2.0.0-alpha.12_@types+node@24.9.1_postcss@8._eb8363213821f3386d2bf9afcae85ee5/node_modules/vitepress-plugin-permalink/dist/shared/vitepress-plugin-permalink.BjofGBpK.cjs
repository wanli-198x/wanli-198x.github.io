'use strict';

const node_fs = require('node:fs');
const node_path = require('node:path');
const matter = require('gray-matter');
const vite = require('vite');
const picocolors = require('picocolors');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const matter__default = /*#__PURE__*/_interopDefaultCompat(matter);
const picocolors__default = /*#__PURE__*/_interopDefaultCompat(picocolors);

const DEFAULT_IGNORE_DIR = ["node_modules", "dist", ".vitepress", "public"];
const permalinks = {};
const createPermalinks = (option = {}, cleanUrls = false) => {
  const { path, ignoreList = [] } = option;
  if (!path) return {};
  const dirPaths = readDirPaths(path, ignoreList);
  scannerMdFile(path, option, "", cleanUrls, true);
  dirPaths.forEach((dirPath) => scannerMdFile(dirPath, option, node_path.basename(dirPath), cleanUrls));
  return permalinks;
};
const readDirPaths = (sourceDir, ignoreList = []) => {
  const dirPaths = [];
  const ignoreListAll = [...DEFAULT_IGNORE_DIR, ...ignoreList];
  const secondDirNames = node_fs.readdirSync(sourceDir);
  secondDirNames.forEach((secondDirName) => {
    const secondDirPath = node_path.resolve(sourceDir, secondDirName);
    if (!isSome(ignoreListAll, secondDirName) && node_fs.statSync(secondDirPath).isDirectory()) {
      dirPaths.push(secondDirPath);
    }
  });
  return dirPaths;
};
const scannerMdFile = (root, option, prefix = "", cleanUrls = false, onlyScannerRootMd = false) => {
  const { ignoreList = [] } = option;
  const ignoreListAll = [...DEFAULT_IGNORE_DIR, ...ignoreList];
  const secondDirOrFilenames = node_fs.readdirSync(root);
  secondDirOrFilenames.forEach((dirOrFilename) => {
    if (isSome(ignoreListAll, dirOrFilename)) return;
    const filePath = node_path.resolve(root, dirOrFilename);
    if (!onlyScannerRootMd && node_fs.statSync(filePath).isDirectory()) {
      scannerMdFile(filePath, option, `${prefix}/${dirOrFilename}`, cleanUrls);
    } else {
      if (!isMarkdownFile(dirOrFilename)) return;
      const content = node_fs.readFileSync(filePath, "utf-8");
      const { data: { permalink = "" } = {} } = matter__default(content, {});
      if (permalink) {
        const filename = node_path.basename(dirOrFilename, node_path.extname(dirOrFilename));
        const finalPermalink = standardLink(permalink);
        permalinks[`${prefix ? `${prefix}/` : ""}${filename}`] = cleanUrls ? finalPermalink : `${finalPermalink}.html`;
      }
    }
  });
};
const isMarkdownFile = (filePath) => {
  return filePath.includes("md") || filePath.includes("MD");
};
const isSome = (arr, name) => {
  return arr.some((item) => item === name || item instanceof RegExp && item.test(name));
};
const standardLink = (permalink = "") => {
  let finalPermalink = permalink;
  if (!finalPermalink.startsWith("/")) finalPermalink = "/" + finalPermalink;
  if (finalPermalink.endsWith("/")) finalPermalink = finalPermalink.replace(/\/$/, "");
  return finalPermalink;
};

const version = "1.2.1";

const logger = vite.createLogger("info", {
  prefix: `[vitepress-plugin-permalink v${version}]`
});
const info = (message, level = "green", option = { timestamp: true }) => {
  logger.info(picocolors__default[level](message), option);
};
const warn = (message, level = "yellow", option = { timestamp: true }) => {
  logger.warn(picocolors__default[level](message), option);
};
const warnOnce = (message, level = "yellow", option = { timestamp: true }) => {
  logger.info(picocolors__default[level](message), option);
};
const error = (message, level = "red", option = { timestamp: true }) => {
  logger.error(picocolors__default[level](message), option);
};
const logger$1 = {
  info,
  warn,
  warnOnce,
  error
};

const createRewrites = (options = {}) => {
  const { path, srcDir = ".", locales = {} } = options;
  const baseDir = path ? node_path.join(srcDir, path) : srcDir;
  const permalinks = createPermalinks({ ...options, path: baseDir }, true);
  const normalizedPermalinks = {};
  for (const [key, value] of Object.entries(permalinks)) {
    const normalizedKey = key + ".md";
    const normalizedValue = value.replace(/^\//, "").replace(/\.[^/.]+$/, "") + ".md";
    normalizedPermalinks[normalizedKey] = normalizedValue;
  }
  const pathToPermalink = {};
  const permalinkToPath = {};
  const localesKeys = Object.keys(locales || {});
  for (const [key, value] of Object.entries(normalizedPermalinks)) {
    const newValue = getLocalePermalink(localesKeys, key, value);
    if (permalinkToPath[newValue]) {
      logger$1.warn(`\u6C38\u4E45\u94FE\u63A5 '${newValue}' \u5DF2\u5B58\u5728\uFF0C\u5176\u5BF9\u5E94\u7684 '${permalinkToPath[newValue]}' \u5C06\u4F1A\u88AB '${key}' \u8986\u76D6`);
    }
    pathToPermalink[key] = newValue;
    permalinkToPath[newValue] = key;
  }
  logger$1.info("Injected Permalinks Rewrites Data Successfully. \u6CE8\u5165\u6C38\u4E45\u94FE\u63A5 Rewrites \u6570\u636E\u6210\u529F!");
  return { __create__: "vitepress-plugin-permalink", ...pathToPermalink };
};
const getLocalePermalink = (localesKeys = [], path = "", permalink = "") => {
  const localesKey = localesKeys.filter((key) => key !== "root").find((key) => path.startsWith(key));
  if (localesKey) return `/${localesKey}${permalink.startsWith("/") ? permalink : `/${permalink}`}`;
  return permalink;
};

exports.createPermalinks = createPermalinks;
exports.createRewrites = createRewrites;
exports.getLocalePermalink = getLocalePermalink;
exports.logger = logger$1;
exports.standardLink = standardLink;
