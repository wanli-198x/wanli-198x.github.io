import { resolve, relative, extname, join } from 'node:path';
import { readdirSync, statSync, readFileSync } from 'node:fs';
import matter from 'gray-matter';
import { exec } from 'child_process';
import { createLogger } from 'vite';
import picocolors from 'picocolors';

const DEFAULT_IGNORE_DIR = ["node_modules", "dist", ".vitepress", "public"];
const readFileList = (option = {}, prefix = "") => {
  const { path } = option;
  if (!path) return [];
  prefix = prefix.endsWith("/") ? prefix : `${prefix}/`;
  prefix = prefix.replace(/^\//, "");
  return readFileList$1(path, option, [], prefix);
};
function readFileList$1(root, option, fileList = [], prefix = "") {
  const { path = "", ignoreList = [], ignoreIndexMd } = option;
  const ignoreListAll = [...DEFAULT_IGNORE_DIR, ...ignoreList];
  const secondDirOrFilenames = readdirSync(root);
  secondDirOrFilenames.forEach((dirOrFilename) => {
    if (isSome(ignoreListAll, dirOrFilename)) return;
    const filePath = resolve(root, dirOrFilename);
    if (statSync(filePath).isDirectory()) {
      readFileList$1(filePath, option, fileList, prefix);
    } else {
      if (!isMarkdownFile(dirOrFilename)) return [];
      if (ignoreIndexMd && ["index.md", "index.MD"].includes(dirOrFilename)) return [];
      if (filePath === resolve(path, "index.md")) return [];
      const content = readFileSync(filePath, "utf-8");
      const { data: { layout, docAnalysis } = {} } = matter(content, {});
      if (layout === "home" || docAnalysis === false) return [];
      const workingDir = resolve(path);
      const absoluteFilePath = resolve(filePath);
      const relativePath = relative(workingDir, absoluteFilePath).replace(/\\/g, "/");
      const type = extname(dirOrFilename);
      if (type === ".md") fileList.push({ filePath, relativePath: prefix + relativePath });
    }
  });
  return fileList;
}
const isMarkdownFile = (filePath) => {
  return filePath.includes("md") || filePath.includes("MD");
};
const isSome = (arr, name) => {
  return arr.some((item) => item === name || item instanceof RegExp && item.test(name));
};

function getTotalFileWords(filePathList) {
  let wordCount = 0;
  filePathList.forEach((item) => {
    const fileContent = readFileSync(item, "utf8");
    const { content } = matter(fileContent, {});
    const len = getCounter(content);
    wordCount += len[0] + len[1];
  });
  return wordCount;
}
function getEachFileWords(fileList, cn = 300, en = 160) {
  const filePathListWords = [];
  fileList.forEach((item) => {
    const fileContent = readFileSync(item.filePath, "utf8");
    const { data, content } = matter(fileContent, {});
    const len = getCounter(content);
    const readingTime = getReadTime(len, cn, en);
    let wordCount = 0;
    wordCount = len[0] + len[1];
    filePathListWords.push({ fileInfo: item, wordCount, readingTime, frontmatter: data });
  });
  return filePathListWords;
}
function getReadTime(len, cn = 300, en = 160) {
  const readingTime = len[0] / cn + len[1] / en;
  if (readingTime > 60 && readingTime < 60 * 24) {
    const hour = Math.trunc(readingTime / 60);
    const minute = Math.trunc(readingTime - hour * 60);
    if (minute === 0) return hour + "h";
    return hour + "h" + minute + "m";
  } else if (readingTime > 60 * 24) {
    const day = Math.trunc(readingTime / (60 * 24));
    const hour = Math.trunc((readingTime - day * 24 * 60) / 60);
    if (hour === 0) return day + "d";
    return day + "d" + hour + "h";
  }
  return (readingTime < 1 ? "1" : Math.trunc(readingTime * 10) / 10) + "m";
}
function getCounter(content) {
  const cn = (content.match(/[\u4E00-\u9FA5]/g) || []).length;
  const en = (content.replace(/[\u4E00-\u9FA5]/g, "").match(
    /[a-zA-Z0-9_\u0392-\u03c9\u0400-\u04FF]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|[\u00E4\u00C4\u00E5\u00C5\u00F6\u00D6]+|\w+/g
  ) || []).length;
  return [cn, en];
}
function getLastUpdateTime(fileList) {
  const updateTime = [];
  fileList.forEach((item) => {
    updateTime.push(statSync(item).mtime.toLocaleString());
  });
  return updateTime.sort((a, b) => getTimeNum(b) - getTimeNum(a))[0];
}
function getTimeNum(dateStr) {
  let date = new Date(dateStr);
  if (date === "Invalid Date" && dateStr) date = new Date(dateStr.replace(/-/g, "/"));
  return date.getTime();
}
function getGitLastCommitTime() {
  return new Promise((resolve) => {
    exec('git log -1 --format=%cd --date=format:"%Y-%m-%d %H:%M:%S"', (error, stdout, stderr) => {
      if (error || stderr) return resolve(0);
      resolve(stdout.trim());
    });
  });
}

const version = "1.0.13";

const logger = createLogger("info", {
  prefix: `[vitepress-plugin-doc-analysis v${version}]`
});
const info = (message, level = "green", option = { timestamp: true }) => {
  logger.info(picocolors[level](message), option);
};
const warn = (message, level = "yellow", option = { timestamp: true }) => {
  logger.warn(picocolors[level](message), option);
};
const warnOnce = (message, level = "yellow", option = { timestamp: true }) => {
  logger.info(picocolors[level](message), option);
};
const error = (message, level = "red", option = { timestamp: true }) => {
  logger.error(picocolors[level](message), option);
};
const logger$1 = {
  info,
  warn,
  warnOnce,
  error
};

function VitePluginVitePressDocAnalysis(option = {}) {
  let isExecute = false;
  return {
    name: "vitepress-plugin-doc-analysis",
    config(config) {
      if (isExecute) return;
      isExecute = true;
      const {
        site: { themeConfig = {}, locales = {} },
        srcDir
      } = config.vitepress;
      const baseDir = option.path ? join(srcDir, option.path) : srcDir;
      const newOption = { ...option, path: baseDir };
      const localesKeys = Object.keys(locales).filter((key) => key !== "root");
      if (!localesKeys.length) return doDocAnalysisThenSet(themeConfig, readFileList(newOption), newOption);
      localesKeys.forEach((localesKey) => {
        const fileList = readFileList({ ...newOption, path: `${baseDir}/${localesKey}` }, localesKey);
        doDocAnalysisThenSet(locales[localesKey].themeConfig, fileList, newOption);
      });
      const rootFileList = readFileList({
        ...newOption,
        ignoreList: [...newOption.ignoreList || [], ...localesKeys]
      });
      doDocAnalysisThenSet(locales["root"].themeConfig, rootFileList, newOption);
    }
  };
}
const doDocAnalysisThenSet = async (themeConfig, fileList, option) => {
  const filePathList = fileList.map((item) => item.filePath);
  const { transformFile } = option;
  const newFileList = fileList.map((file) => {
    if (transformFile) file = { ...transformFile(file), ...file };
    return file;
  });
  const totalFileWords = getTotalFileWords(filePathList);
  const eachFileWords = getEachFileWords(newFileList, option.cn, option.en);
  const lastCommitTime = await getGitLastCommitTime() || getLastUpdateTime(filePathList);
  themeConfig = themeConfig || {};
  themeConfig.docAnalysisInfo = {
    fileList: newFileList,
    totalFileWords,
    eachFileWords,
    lastCommitTime
  };
  logger$1.info("Injected DocAnalysisInfo Data Successfully. \u6CE8\u5165\u6587\u6863\u5206\u6790\u6570\u636E\u6210\u529F!");
};

export { VitePluginVitePressDocAnalysis as default };
